<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GR2 Animation Debug & State Machine</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Consolas', monospace;
      background: #1a1a2e;
      color: #eee;
      display: flex;
      height: 100vh;
    }

    #sidebar {
      width: 420px;
      background: #16213e;
      padding: 15px;
      overflow-y: auto;
      border-right: 2px solid #0f3460;
    }

    #render-area {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    #render-container {
      flex: 1;
      position: relative;
    }

    #timeline {
      height: 80px;
      background: #0f0f23;
      padding: 10px;
      border-top: 2px solid #0f3460;
    }

    h1 {
      font-size: 18px;
      margin-bottom: 15px;
      color: #4a9eff;
    }

    h2 {
      font-size: 14px;
      margin: 15px 0 10px;
      color: #e94560;
    }

    h3 {
      font-size: 12px;
      margin: 10px 0 5px;
      color: #4ea;
    }

    .btn {
      background: #4a9eff;
      color: white;
      border: none;
      padding: 8px 15px;
      margin: 3px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .btn:hover {
      background: #3a8eef;
      transform: scale(1.02);
    }

    .btn.active {
      background: #e94560;
    }

    .btn.state-btn {
      min-width: 100px;
    }

    .btn.state-btn.current {
      background: #4e4;
      box-shadow: 0 0 10px #4e4;
    }

    #log {
      background: #0f0f23;
      padding: 10px;
      font-size: 11px;
      max-height: 300px;
      overflow-y: auto;
      border-radius: 4px;
      margin-top: 10px;
    }

    .log-info {
      color: #4ae;
    }

    .log-warn {
      color: #ea4;
    }

    .log-error {
      color: #e44;
    }

    .log-success {
      color: #4e4;
    }

    .log-anim {
      color: #e4a;
    }

    .log-state {
      color: #4ea;
    }

    .log-bone {
      color: #ae4;
    }

    .log-mesh {
      color: #a4e;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
      margin: 10px 0;
    }

    th,
    td {
      border: 1px solid #333;
      padding: 5px;
      text-align: left;
    }

    th {
      background: #0f3460;
    }

    .state-panel {
      background: #1a1a2e;
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
      border-left: 3px solid #4ea;
    }

    .state-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      background: #666;
    }

    .state-indicator.active {
      background: #4e4;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    .animation-list {
      max-height: 200px;
      overflow-y: auto;
      background: #0f0f23;
      border-radius: 4px;
      padding: 5px;
    }

    .animation-item {
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 3px;
      margin: 2px 0;
    }

    .animation-item:hover {
      background: #2a2a4e;
    }

    .animation-item.playing {
      background: #4a9eff33;
      border-left: 3px solid #4a9eff;
    }

    #timeline-slider {
      width: 100%;
      margin: 10px 0;
    }

    .timeline-info {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: #888;
    }

    .skeleton-tree {
      font-size: 11px;
      max-height: 150px;
      overflow-y: auto;
      background: #0f0f23;
      padding: 5px;
      border-radius: 4px;
    }

    .bone-item {
      padding: 2px 0;
      padding-left: calc(var(--depth) * 15px);
    }
  </style>
</head>

<body>
  <div id="sidebar">
    <h1>GR2 Animation Debug</h1>

    <div>
      <button class="btn" onclick="loadFile('empelium90_0.gr2')">empelium90_0</button>
      <button class="btn" onclick="loadFile('guildflag90_1.gr2')">guildflag90_1</button>
      <button class="btn" onclick="loadFile('kguardian90_7.gr2')">kguardian90_7</button>
      <button class="btn" onclick="loadFile('sguardian90_9.gr2')">sguardian90_9</button>
    </div>

    <h2>Animation State Machine</h2>
    <div class="state-panel">
      <div style="margin-bottom: 10px;">
        Current State: <strong id="currentState">NONE</strong>
      </div>
      <button class="btn state-btn" id="btnStop" onclick="stateMachine.setState('Stop')">Stop</button>
      <button class="btn state-btn" id="btnMoveout" onclick="stateMachine.setState('Moveout')">Moveout</button>
      <button class="btn state-btn" id="btnAttackout" onclick="stateMachine.setState('Attackout')">Attackout</button>
      <button class="btn state-btn" id="btnDamageout" onclick="stateMachine.setState('Damageout')">Damageout</button>
      <button class="btn state-btn" id="btnDeadout" onclick="stateMachine.setState('Deadout')">Deadout</button>
    </div>

    <h2>Available Animations</h2>
    <div id="animation-list" class="animation-list">
      <span style="color:#666;">Load a file to see animations...</span>
    </div>

    <h2>Playback Controls</h2>
    <div>
      <button class="btn" id="btnPlay" onclick="togglePlayback()">Play</button>
      <button class="btn" onclick="stopAnimation()">Stop</button>
      <button class="btn" onclick="resetAnimation()">Reset</button>
      <button class="btn" id="btnLoop" onclick="toggleLoop()">Loop: ON</button>
    </div>
    <div style="margin-top: 10px;">
      <label>Speed: <span id="speedValue">1.0x</span></label>
      <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1" onchange="setSpeed(this.value)">
    </div>

    <h2>Skeleton</h2>
    <div id="skeleton-info" class="skeleton-tree">
      <span style="color:#666;">No skeleton loaded...</span>
    </div>

    <h2>Debug Log</h2>
    <button class="btn" onclick="clearLog()">Clear Log</button>
    <div id="log"></div>
  </div>

  <div id="render-area">
    <div id="render-container"></div>
    <div id="timeline">
      <input type="range" id="timeline-slider" min="0" max="100" value="0" step="0.1"
        oninput="seekAnimation(this.value)">
      <div class="timeline-info">
        <span id="timelineCurrent">0.00s</span>
        <span id="timelineAnimation">No animation</span>
        <span id="timelineDuration">0.00s</span>
      </div>
    </div>
  </div>

  <script src="three.min.js"></script>
  <script src="const.js"></script>
  <script src="main.js"></script>
  <script src="memory.js"></script>
  <script src="io.js"></script>
  <script src="v86.js"></script>
  <script src="fpu.js"></script>
  <script src="granny2.js"></script>
  <script src="granny2.subs.js"></script>
  <script src="granny2.def.js"></script>
  <script src="pe_env.js"></script>

  <script>
    // Performance utilities
    function throttle(func, limit) {
      let inThrottle;
      return function (...args) {
        if (!inThrottle) {
          func.apply(this, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      };
    }

    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    // Cached DOM references
    const DOM = {
      log: null,
      renderContainer: null,
      animationList: null,
      skeletonInfo: null,
      currentState: null,
      timelineSlider: null,
      timelineCurrent: null,
      timelineAnimation: null,
      timelineDuration: null,
      btnPlay: null,
      btnLoop: null,
      speedValue: null,
      init() {
        this.log = document.getElementById('log');
        this.renderContainer = document.getElementById('render-container');
        this.animationList = document.getElementById('animation-list');
        this.skeletonInfo = document.getElementById('skeleton-info');
        this.currentState = document.getElementById('currentState');
        this.timelineSlider = document.getElementById('timeline-slider');
        this.timelineCurrent = document.getElementById('timelineCurrent');
        this.timelineAnimation = document.getElementById('timelineAnimation');
        this.timelineDuration = document.getElementById('timelineDuration');
        this.btnPlay = document.getElementById('btnPlay');
        this.btnLoop = document.getElementById('btnLoop');
        this.speedValue = document.getElementById('speedValue');
      }
    };

    // Logger with batched updates
    const Logger = {
      buffer: [],
      maxLogEntries: 200,
      flushScheduled: false,

      log: function (msg, type = 'info') {
        this.buffer.push({ msg, type, time: new Date().toLocaleTimeString() });
        console.log(`[${type.toUpperCase()}]`, msg);

        if (!this.flushScheduled) {
          this.flushScheduled = true;
          requestAnimationFrame(() => this.flush());
        }
      },

      flush: function () {
        if (this.buffer.length === 0) {
          this.flushScheduled = false;
          return;
        }

        const logEl = DOM.log;
        if (!logEl) {
          this.flushScheduled = false;
          return;
        }

        const fragment = document.createDocumentFragment();
        this.buffer.forEach(({ msg, type, time }) => {
          const div = document.createElement('div');
          div.className = 'log-' + type;
          div.textContent = `[${time}] ${msg}`;
          fragment.appendChild(div);
        });

        logEl.appendChild(fragment);
        this.buffer = [];
        this.flushScheduled = false;

        while (logEl.children.length > this.maxLogEntries) {
          logEl.removeChild(logEl.firstChild);
        }

        requestAnimationFrame(() => {
          logEl.scrollTop = logEl.scrollHeight;
        });
      },

      info: function (msg) { this.log(msg, 'info'); },
      warn: function (msg) { this.log(msg, 'warn'); },
      error: function (msg) { this.log(msg, 'error'); },
      success: function (msg) { this.log(msg, 'success'); },
      anim: function (msg) { this.log(msg, 'anim'); },
      state: function (msg) { this.log(msg, 'state'); },
      bone: function (msg) { this.log(msg, 'bone'); },
      mesh: function (msg) { this.log(msg, 'mesh'); }
    };

    // ==========================================
    // Memory Reading Helpers (manual offset reading)
    // ==========================================
    const MemHelper = {
      // Valid memory range for Granny2 DLL (loaded at 0x10000000)
      MIN_VALID_ADDR: 0x10000000,
      MAX_VALID_ADDR: 0x20000000,

      isValidPtr(ptr) {
        return ptr && ptr >= this.MIN_VALID_ADDR && ptr < this.MAX_VALID_ADDR;
      },

      readStr(gr2, ptr, maxLen = 256) {
        if (!this.isValidPtr(ptr)) return '';
        try {
          const physAddr = gr2.runtime.cpu.translate_address_read(ptr);
          const mem = gr2.runtime.cpu.memory.mem8;
          let str = '';
          for (let i = 0; i < maxLen; i++) {
            const byte = mem[physAddr + i];
            if (byte === 0) break;
            str += String.fromCharCode(byte);
          }
          return str;
        } catch (e) {
          return '';
        }
      },

      readF32(gr2, addr) {
        if (!this.isValidPtr(addr)) return 0;
        try {
          const physAddr = gr2.runtime.cpu.translate_address_read(addr);
          const mem = gr2.runtime.cpu.memory.mem8;
          const bytes = new Uint8Array([
            mem[physAddr], mem[physAddr + 1], mem[physAddr + 2], mem[physAddr + 3]
          ]);
          return new Float32Array(bytes.buffer)[0];
        } catch (e) {
          return 0;
        }
      },

      readI32(gr2, addr) {
        if (!this.isValidPtr(addr)) return 0;
        return gr2.runtime.get_dword_ptr(addr) | 0;
      },

      readU32(gr2, addr) {
        if (!this.isValidPtr(addr)) return 0;
        return gr2.runtime.get_dword_ptr(addr) >>> 0;
      }
    };

    // ==========================================
    // Animation State Machine
    // ==========================================
    class AnimationStateMachine {
      constructor() {
        this.states = ['Stop', 'Moveout', 'Attackout', 'Damageout', 'Deadout'];
        this.baseStates = ['Stop', 'Moveout']; // Looping base states
        this.overlayStates = ['Attackout', 'Damageout', 'Deadout']; // One-shot states
        this.currentState = null;
        this.previousBaseState = 'Stop'; // State to return to after overlay
        this.stateAnimations = new Map();
        this.onStateChange = null;
      }

      mapAnimationToState(animationName) {
        const name = animationName.toLowerCase();

        // Map animation names to states
        if (name.includes('stop') || name.includes('idle') || name.includes('wait') || name.includes('stand')) {
          return 'Stop';
        } else if (name.includes('move') || name.includes('walk') || name.includes('run')) {
          return 'Moveout';
        } else if (name.includes('attack') || name.includes('atk') || name.includes('hit') || name.includes('swing')) {
          return 'Attackout';
        } else if (name.includes('damage') || name.includes('hurt') || name.includes('pain') || name.includes('hit')) {
          return 'Damageout';
        } else if (name.includes('dead') || name.includes('die') || name.includes('death')) {
          return 'Deadout';
        }
        return null;
      }

      loadAnimations(animations) {
        this.stateAnimations.clear();
        this.allAnimations = animations;

        // First try to map by name
        animations.forEach(anim => {
          const state = this.mapAnimationToState(anim.name);
          if (state) {
            if (!this.stateAnimations.has(state)) {
              this.stateAnimations.set(state, []);
            }
            this.stateAnimations.get(state).push(anim);
            Logger.state(`Mapped "${anim.name}" -> ${state}`);
          }
        });

        // If no animations were mapped, use a default mapping strategy
        // Assign first animation to Stop (idle) state
        if (this.stateAnimations.size === 0 && animations.length > 0) {
          Logger.warn(`No animations mapped by name. Using default assignment.`);

          // First animation = Stop/Idle
          this.stateAnimations.set('Stop', [animations[0]]);
          Logger.state(`Default: "${animations[0].name}" -> Stop`);

          // If there are more animations, try to distribute them
          if (animations.length > 1) {
            this.stateAnimations.set('Moveout', [animations[Math.min(1, animations.length - 1)]]);
          }
          if (animations.length > 2) {
            this.stateAnimations.set('Attackout', [animations[Math.min(2, animations.length - 1)]]);
          }
          if (animations.length > 3) {
            this.stateAnimations.set('Damageout', [animations[Math.min(3, animations.length - 1)]]);
          }
          if (animations.length > 4) {
            this.stateAnimations.set('Deadout', [animations[Math.min(4, animations.length - 1)]]);
          }
        }

        // Log unmapped animations
        animations.forEach(anim => {
          if (!this.mapAnimationToState(anim.name)) {
            Logger.info(`Animation available: "${anim.name}" (${anim.duration.toFixed(2)}s)`);
          }
        });
      }

      isBaseState(state) {
        return this.baseStates.includes(state);
      }

      isOverlayState(state) {
        return this.overlayStates.includes(state);
      }

      setState(newState, forceLoop = null) {
        if (!this.states.includes(newState)) {
          Logger.error(`Invalid state: ${newState}`);
          return;
        }

        const prevState = this.currentState;

        // If transitioning from base state to overlay, save return state
        if (this.isBaseState(prevState) && this.isOverlayState(newState)) {
          this.previousBaseState = prevState;
          Logger.state(`Saved return state: ${prevState}`);
        }

        this.currentState = newState;

        Logger.state(`State transition: ${prevState || 'NONE'} -> ${newState}`);

        // Update UI
        this.updateStateButtons();
        DOM.currentState.textContent = newState;

        // Get animation for this state
        const animations = this.stateAnimations.get(newState);
        if (animations && animations.length > 0) {
          // Determine if should loop
          const shouldLoop = forceLoop !== null ? forceLoop : this.isBaseState(newState);

          if (this.onStateChange) {
            this.onStateChange(animations[0], shouldLoop);
          }
        } else {
          Logger.warn(`No animation found for state: ${newState}`);
        }
      }

      // Called when an animation finishes
      onAnimationFinished(animation) {
        // Don't return from Deadout (stay dead)
        if (this.currentState === 'Deadout') {
          Logger.state('Deadout complete - staying dead');
          return;
        }

        // Return to previous base state if we were in an overlay
        if (this.isOverlayState(this.currentState)) {
          Logger.state(`Overlay finished, returning to: ${this.previousBaseState}`);
          this.setState(this.previousBaseState);
        }
      }

      updateStateButtons() {
        this.states.forEach(state => {
          const btn = document.getElementById('btn' + state);
          if (btn) {
            btn.classList.toggle('current', state === this.currentState);
          }
        });
      }

      getAnimationsForState(state) {
        return this.stateAnimations.get(state) || [];
      }
    }

    // ==========================================
    // Animation Controller
    // ==========================================
    class AnimationController {
      constructor() {
        this.gr2 = null;
        this.animations = [];
        this.trackGroups = [];
        this.skeleton = null;
        this.bones = [];
        this.currentAnimation = null;
        this.currentTime = 0;
        this.duration = 0;
        this.isPlaying = false;
        this.isLooping = true;
        this.speed = 1.0;
        this.lastUpdateTime = 0;
        this.onFinished = null; // Callback when animation finishes
      }

      loadFromFileInfo(gr2, fileInfo) {
        this.gr2 = gr2;
        this.animations = [];
        this.trackGroups = [];
        this.bones = [];

        Logger.anim('='.repeat(50));
        Logger.anim('LOADING ANIMATIONS');
        Logger.anim('='.repeat(50));

        Logger.anim(`Animation count: ${fileInfo.AnimationCount}`);
        Logger.anim(`Track group count: ${fileInfo.TrackGroupCount}`);

        // Parse animations using manual offset reading
        // granny_animation layout:
        // +0: char* Name
        // +4: float Duration
        // +8: float TimeStep
        // +12: float Oversampling
        // +16: int TrackGroupCount
        // +20: void* TrackGroups
        for (let i = 0; i < fileInfo.AnimationCount; i++) {
          try {
            const animPtr = gr2.runtime.get_dword_ptr(fileInfo.Animations + 4 * i);

            // Validate pointer before reading
            if (!MemHelper.isValidPtr(animPtr)) {
              Logger.warn(`Animation ${i}: Invalid pointer 0x${animPtr.toString(16)}`);
              continue;
            }

            const namePtr = MemHelper.readU32(gr2, animPtr + 0);
            const duration = MemHelper.readF32(gr2, animPtr + 4);
            const timeStep = MemHelper.readF32(gr2, animPtr + 8);
            const oversampling = MemHelper.readF32(gr2, animPtr + 12);
            // +16 is TrackGroupCount (int), +20 is TrackGroups (pointer)
            const trackGroupCount = MemHelper.readU32(gr2, animPtr + 16);
            const trackGroupsPtr = MemHelper.readU32(gr2, animPtr + 20);

            const name = MemHelper.readStr(gr2, namePtr) || `Animation_${i}`;

            this.animations.push({
              index: i,
              ptr: animPtr,
              name,
              duration,
              timeStep,
              oversampling,
              trackGroupCount,
              trackGroupsPtr
            });

            Logger.anim(`Animation ${i}: "${name}" (${duration.toFixed(2)}s, TG=${trackGroupCount})`);
          } catch (e) {
            Logger.error(`Failed to read animation ${i}: ${e.message}`);
          }
        }

        // Parse track groups using manual offset reading
        // granny_track_group layout:
        // +0: char* Name
        // +4: int VectorTrackCount
        // +8: void* VectorTracks
        // +12: int TransformTrackCount
        // +16: void* TransformTracks
        for (let i = 0; i < fileInfo.TrackGroupCount; i++) {
          try {
            const tgPtr = gr2.runtime.get_dword_ptr(fileInfo.TrackGroups + 4 * i);

            // Validate pointer before reading
            if (!MemHelper.isValidPtr(tgPtr)) {
              Logger.warn(`TrackGroup ${i}: Invalid pointer 0x${tgPtr.toString(16)}`);
              continue;
            }

            const namePtr = MemHelper.readU32(gr2, tgPtr + 0);
            const vectorTrackCount = MemHelper.readU32(gr2, tgPtr + 4);
            const transformTrackCount = MemHelper.readU32(gr2, tgPtr + 12);

            const name = MemHelper.readStr(gr2, namePtr) || `TrackGroup_${i}`;

            this.trackGroups.push({
              index: i,
              ptr: tgPtr,
              name,
              vectorTrackCount,
              transformTrackCount
            });

            Logger.anim(`TrackGroup ${i}: "${name}" (VT=${vectorTrackCount}, TT=${transformTrackCount})`);
          } catch (e) {
            Logger.error(`Failed to read track group ${i}: ${e.message}`);
          }
        }

        // Load skeleton
        if (fileInfo.SkeletonCount > 0 && fileInfo.Skeletons && fileInfo.Skeletons.length > 0) {
          this.loadSkeleton(gr2, fileInfo.Skeletons[0]);
        }

        Logger.success(`Loaded ${this.animations.length} animations, ${this.trackGroups.length} track groups`);

        return this.animations;
      }

      // Helper to check if a pointer looks like a valid bone structure
      looksLikeBoneStruct(gr2, ptr, boneCount) {
        if (!MemHelper.isValidPtr(ptr)) return false;
        const namePtr = MemHelper.readU32(gr2, ptr + 0);
        if (!MemHelper.isValidPtr(namePtr)) return false;
        const name = MemHelper.readStr(gr2, namePtr, 64);
        if (!name || name.length === 0) return false;
        const parent = MemHelper.readI32(gr2, ptr + 4);
        // Parent should be -1 (root) or a valid bone index
        return parent >= -1 && parent < boneCount;
      }

      loadSkeleton(gr2, skeleton) {
        Logger.bone('='.repeat(50));
        Logger.bone('LOADING SKELETON');
        Logger.bone('='.repeat(50));

        this.skeleton = skeleton;
        this.bones = [];

        Logger.bone(`Skeleton: "${skeleton.Name}"`);
        Logger.bone(`Bone count: ${skeleton.BoneCount}`);

        if (skeleton.BoneCount > 0 && skeleton.Bones) {
          const base = skeleton.Bones;
          Logger.bone(`Bones base ptr: 0x${base.toString(16)}`);

          // Validate base pointer
          if (!MemHelper.isValidPtr(base)) {
            Logger.error(`Invalid bones base pointer: 0x${base.toString(16)}`);
            return;
          }

          // Detect if Bones is an array of pointers (bone**) or contiguous block (bone*)
          // Read first value and check if it looks like a pointer to a bone struct
          const firstValue = MemHelper.readU32(gr2, base);
          const isPtrArray = this.looksLikeBoneStruct(gr2, firstValue, skeleton.BoneCount);

          Logger.bone(`Bones format: ${isPtrArray ? 'pointer array (bone**)' : 'contiguous block (bone*)'}`);

          if (isPtrArray) {
            // Bones = bone** (array of pointers to bone structs)
            for (let i = 0; i < skeleton.BoneCount; i++) {
              try {
                const bonePtr = MemHelper.readU32(gr2, base + 4 * i);

                if (!this.looksLikeBoneStruct(gr2, bonePtr, skeleton.BoneCount)) {
                  Logger.warn(`Bone ${i}: Invalid pointer 0x${bonePtr.toString(16)}`);
                  continue;
                }

                const boneData = Granny2.readStructure(
                  gr2.runtime.cpu,
                  bonePtr,
                  Granny2.structs.granny_bone
                );

                const t = boneData.LocalTransform;
                const pos = (t && t.Position) ? t.Position : [0, 0, 0];

                this.bones.push({
                  index: i,
                  ptr: bonePtr,
                  name: boneData.Name || `Bone_${i}`,
                  parentIndex: boneData.ParentIndex,
                  localTransform: {
                    flags: t ? (t.Flags || 0) : 0,
                    position: pos
                  }
                });

              } catch (e) {
                Logger.warn(`Failed to read bone ${i}: ${e.message}`);
              }
            }
          } else {
            // Bones = bone* (contiguous block)
            let currentPtr = base;

            for (let i = 0; i < skeleton.BoneCount; i++) {
              try {
                const boneData = Granny2.readStructure(
                  gr2.runtime.cpu,
                  currentPtr,
                  Granny2.structs.granny_bone
                );

                const t = boneData.LocalTransform;
                const pos = (t && t.Position) ? t.Position : [0, 0, 0];

                this.bones.push({
                  index: i,
                  ptr: currentPtr,
                  name: boneData.Name || `Bone_${i}`,
                  parentIndex: boneData.ParentIndex,
                  localTransform: {
                    flags: t ? (t.Flags || 0) : 0,
                    position: pos
                  }
                });

                // Log the computed bone size for first bone
                if (i === 0) {
                  Logger.bone(`Bone struct size (computed): ${boneData._size} bytes`);
                }

                currentPtr += boneData._size;

              } catch (e) {
                Logger.warn(`Failed to read bone ${i}: ${e.message}`);
                break;
              }
            }
          }
        }

        // Log bone hierarchy
        this.bones.forEach(bone => {
          const indent = '  '.repeat(this.getBoneDepth(bone.index));
          const pos = (bone.localTransform && bone.localTransform.position) || [0, 0, 0];
          const posStr = Array.isArray(pos) ? pos.map(p => (p || 0).toFixed(2)).join(',') : '0,0,0';
          Logger.bone(`${indent}${bone.name} (idx=${bone.index}, parent=${bone.parentIndex}, pos=[${posStr}])`);
        });

        Logger.success(`Loaded ${this.bones.length}/${skeleton.BoneCount} bones`);
        this.updateSkeletonUI();
      }

      getBoneDepth(boneIndex) {
        let depth = 0;
        let current = this.bones[boneIndex];
        while (current && current.parentIndex >= 0 && depth < 20) {
          depth++;
          current = this.bones[current.parentIndex];
        }
        return depth;
      }

      updateSkeletonUI() {
        if (this.bones.length === 0) {
          DOM.skeletonInfo.innerHTML = '<span style="color:#666;">No skeleton data</span>';
          return;
        }

        let html = `<div style="margin-bottom:5px;color:#4ea;">Bones: ${this.bones.length}</div>`;

        this.bones.forEach(bone => {
          const depth = this.getBoneDepth(bone.index);
          html += `<div class="bone-item" style="--depth:${depth}">
            ${bone.name} <span style="color:#666;">(${bone.index})</span>
          </div>`;
        });

        DOM.skeletonInfo.innerHTML = html;
      }

      playAnimation(animation, loop = true) {
        this.currentAnimation = animation;
        this.currentTime = 0;
        this.duration = animation.duration;
        this.isPlaying = true;
        this.isLooping = loop;
        this.lastUpdateTime = performance.now();

        Logger.anim(`Playing: "${animation.name}" (${animation.duration.toFixed(2)}s, loop=${loop})`);

        this.updateTimelineUI();
        DOM.btnPlay.textContent = 'Pause';
        DOM.btnLoop.textContent = 'Loop: ' + (loop ? 'ON' : 'OFF');
        DOM.btnLoop.classList.toggle('active', loop);
        DOM.timelineAnimation.textContent = animation.name;
        DOM.timelineDuration.textContent = animation.duration.toFixed(2) + 's';
      }

      update(timestamp) {
        if (!this.isPlaying || !this.currentAnimation) return;

        const deltaTime = (timestamp - this.lastUpdateTime) / 1000;
        this.lastUpdateTime = timestamp;

        this.currentTime += deltaTime * this.speed;

        if (this.currentTime >= this.duration) {
          if (this.isLooping) {
            this.currentTime = this.currentTime % this.duration;
          } else {
            this.currentTime = this.duration;
            this.isPlaying = false;
            DOM.btnPlay.textContent = 'Play';

            // Trigger onFinished callback
            if (this.onFinished) {
              this.onFinished(this.currentAnimation);
            }
          }
        }

        this.updateTimelineUI();
      }

      updateTimelineUI() {
        if (!this.currentAnimation) return;

        const progress = this.duration > 0 ? (this.currentTime / this.duration) * 100 : 0;
        DOM.timelineSlider.value = progress;
        DOM.timelineCurrent.textContent = this.currentTime.toFixed(2) + 's';
      }

      seek(percent) {
        if (!this.currentAnimation) return;
        this.currentTime = (percent / 100) * this.duration;
        this.updateTimelineUI();
      }

      togglePlayback() {
        this.isPlaying = !this.isPlaying;
        if (this.isPlaying) {
          this.lastUpdateTime = performance.now();
        }
        DOM.btnPlay.textContent = this.isPlaying ? 'Pause' : 'Play';
      }

      stop() {
        this.isPlaying = false;
        this.currentTime = 0;
        this.updateTimelineUI();
        DOM.btnPlay.textContent = 'Play';
      }

      reset() {
        this.currentTime = 0;
        this.updateTimelineUI();
      }

      setSpeed(speed) {
        this.speed = speed;
        DOM.speedValue.textContent = speed.toFixed(1) + 'x';
      }

      toggleLoop() {
        this.isLooping = !this.isLooping;
        DOM.btnLoop.textContent = 'Loop: ' + (this.isLooping ? 'ON' : 'OFF');
        DOM.btnLoop.classList.toggle('active', this.isLooping);
      }
    }

    // ==========================================
    // Global State
    // ==========================================
    let scene, camera, renderer;
    let currentModel = null;
    let granny2Binary = null;
    let gr2Instance = null;
    let needsRender = true;
    let lastRenderTime = 0;
    const MIN_RENDER_INTERVAL = 16;

    const animController = new AnimationController();
    const stateMachine = new AnimationStateMachine();

    // Connect state machine to animation controller
    stateMachine.onStateChange = (animation, shouldLoop) => {
      animController.playAnimation(animation, shouldLoop);
      updateAnimationListUI();
    };

    // Connect animation controller to state machine for return-to-base logic
    animController.onFinished = (animation) => {
      Logger.anim(`Animation finished: "${animation.name}"`);
      stateMachine.onAnimationFinished(animation);
      updateAnimationListUI();
    };

    function clearLog() {
      if (DOM.log) DOM.log.innerHTML = '';
      Logger.buffer = [];
    }

    function init() {
      DOM.init();

      Logger.info('Initializing Animation Debug...');

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);

      const container = DOM.renderContainer;
      camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 10000);
      camera.position.set(25, 35, 25);
      camera.lookAt(new THREE.Vector3(0, 10, 0));

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0x404040));
      const directional = new THREE.DirectionalLight(0xffffff, 0.5);
      directional.position.set(0, 20, -50);
      scene.add(directional);

      scene.add(new THREE.AxesHelper(100));
      scene.add(new THREE.GridHelper(100, 10));

      setupControls();
      window.addEventListener('resize', debounce(onWindowResize, 100));

      animate();
      loadGranny2Binary();
    }

    function setupControls() {
      let isDragging = false;
      let previousMouseX = 0;
      let previousMouseY = 0;

      renderer.domElement.addEventListener('mousedown', () => isDragging = true);
      renderer.domElement.addEventListener('mouseup', () => isDragging = false);
      renderer.domElement.addEventListener('mouseleave', () => isDragging = false);

      const handleMouseMove = throttle((e) => {
        if (isDragging && currentModel) {
          currentModel.rotation.y += (e.offsetX - previousMouseX) * 0.01;
          currentModel.rotation.x += (e.offsetY - previousMouseY) * 0.01;
          needsRender = true;
        }
        previousMouseX = e.offsetX;
        previousMouseY = e.offsetY;
      }, 16);

      renderer.domElement.addEventListener('mousemove', handleMouseMove);

      const handleWheel = throttle((e) => {
        e.preventDefault();
        camera.position.z += e.deltaY * 0.1;
        needsRender = true;
      }, 16);

      renderer.domElement.addEventListener('wheel', handleWheel, { passive: false });
    }

    async function loadGranny2Binary() {
      try {
        Logger.info('Loading granny2.bin...');
        const response = await fetch('granny2.bin');
        granny2Binary = await response.arrayBuffer();
        Logger.success('granny2.bin loaded successfully!');
      } catch (error) {
        Logger.error('Failed to load granny2.bin: ' + error.message);
      }
    }

    async function loadFile(filename) {
      if (!granny2Binary) {
        Logger.error('granny2.bin not loaded yet!');
        return;
      }

      try {
        Logger.info(`Loading ${filename}...`);

        const response = await fetch(filename);
        const arrayBuffer = await response.arrayBuffer();

        Logger.info(`File size: ${arrayBuffer.byteLength} bytes`);

        parseAndAnalyze(arrayBuffer, filename);

      } catch (error) {
        Logger.error('Error loading file: ' + error.message);
      }
    }

    function parseAndAnalyze(gr2ArrayBuffer, filename) {
      Logger.info('='.repeat(50));
      Logger.info(`PARSING: ${filename}`);
      Logger.info('='.repeat(50));

      const gr2 = new Granny2(granny2Binary);
      gr2Instance = gr2;

      const grannyFilePtr = gr2.ReadEntireFileFromMemory(gr2ArrayBuffer);
      const fileInfoPtr = gr2.GetFileInfo(grannyFilePtr);
      const fileInfo = Granny2.readStructure(gr2.runtime.cpu, fileInfoPtr, Granny2.structs.granny_file_info);

      Logger.info('--- FILE INFO ---');
      Logger.info(`Models: ${fileInfo.ModelCount}`);
      Logger.info(`Meshes: ${fileInfo.MeshCount}`);
      Logger.info(`Skeletons: ${fileInfo.SkeletonCount}`);
      Logger.info(`Animations: ${fileInfo.AnimationCount}`);
      Logger.info(`Track Groups: ${fileInfo.TrackGroupCount}`);

      // Load animations
      const animations = animController.loadFromFileInfo(gr2, fileInfo);

      // Map animations to state machine
      stateMachine.loadAnimations(animations);

      // Update UI
      updateAnimationListUI();

      // Load model for visualization
      loadModelMesh(gr2, fileInfo);

      // Default to Stop state if available
      if (stateMachine.stateAnimations.has('Stop')) {
        stateMachine.setState('Stop');
      } else if (animations.length > 0) {
        animController.playAnimation(animations[0]);
      }
    }

    function updateAnimationListUI() {
      if (animController.animations.length === 0) {
        DOM.animationList.innerHTML = '<span style="color:#666;">No animations found</span>';
        return;
      }

      let html = '';
      animController.animations.forEach((anim, i) => {
        const isPlaying = animController.currentAnimation === anim;
        const state = stateMachine.mapAnimationToState(anim.name);
        const stateTag = state ? `<span style="color:#4ea;font-size:10px;">[${state}]</span>` : '';

        html += `<div class="animation-item ${isPlaying ? 'playing' : ''}"
                     onclick="playAnimationByIndex(${i})">
          ${anim.name} ${stateTag}
          <span style="color:#888;font-size:10px;">(${anim.duration.toFixed(2)}s)</span>
        </div>`;
      });

      DOM.animationList.innerHTML = html;
    }

    function playAnimationByIndex(index) {
      const anim = animController.animations[index];
      if (anim) {
        animController.playAnimation(anim);
        updateAnimationListUI();
      }
    }

    // Cleanup Three.js resources to prevent memory leaks
    function disposeObject(obj) {
      if (!obj) return;
      obj.traverse((child) => {
        if (child.geometry) {
          child.geometry.dispose();
        }
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(mat => {
              if (mat.map) mat.map.dispose();
              mat.dispose();
            });
          } else {
            if (child.material.map) child.material.map.dispose();
            child.material.dispose();
          }
        }
      });
    }

    function loadModelMesh(gr2, fileInfo) {
      Logger.info('='.repeat(50));
      Logger.info('LOADING 3D MESH');
      Logger.info('='.repeat(50));

      if (fileInfo.ModelCount === 0 || !fileInfo.Models || fileInfo.Models.length === 0) {
        Logger.warn('No models to render');
        return;
      }

      // Clear previous model and dispose resources
      if (currentModel) {
        disposeObject(currentModel);
        scene.remove(currentModel);
      }

      currentModel = new THREE.Group();

      // Build mesh lookup map for O(1) access
      const meshLookup = new Map();
      for (let k = 0; k < fileInfo.Meshes.length; k++) {
        meshLookup.set(fileInfo.Meshes[k]._ptr, fileInfo.Meshes[k]);
      }

      let meshCount = 0;

      // Process each model
      for (let i = 0; i < fileInfo.ModelCount; i++) {
        const model = fileInfo.Models[i];
        Logger.mesh(`Model ${i}: ${model.Name || 'unnamed'} (${model.MeshBindingsCount} mesh bindings)`);

        for (let j = 0; j < model.MeshBindingsCount; j++) {
          const meshPtr = model.MeshBindings[j]._ptr;
          const mesh = meshLookup.get(meshPtr);

          if (!mesh) {
            Logger.warn(`Mesh not found for binding ${j}`);
            continue;
          }

          Logger.mesh(`  Mesh ${j}: ${mesh.Name || 'unnamed'}`);

          // Get vertices and indices
          const vertexCount = gr2.GetMeshVertexCount(mesh._ptr);
          const vertices = gr2.CopyMeshVertices(mesh._ptr);
          const indices = gr2.CopyMeshIndices(mesh._ptr);
          const indexCount = gr2.GetMeshIndexCount(mesh._ptr);

          Logger.mesh(`    Vertices: ${vertexCount}, Indices: ${indexCount}`);

          if (vertexCount === 0 || indexCount === 0) {
            Logger.warn(`    Empty mesh, skipping`);
            continue;
          }

          // Create Three.js geometry
          const geometry = new THREE.BufferGeometry();
          const floats = new Float32Array(vertices.buffer);

          // Pre-allocate typed arrays
          const positions = new Float32Array(vertexCount * 3);
          const normals = new Float32Array(vertexCount * 3);
          const uvs = new Float32Array(vertexCount * 2);

          for (let v = 0; v < vertexCount; v++) {
            const srcOffset = v * 8;
            const posOffset = v * 3;
            const uvOffset = v * 2;

            // Position (X, Y, Z)
            positions[posOffset] = floats[srcOffset];
            positions[posOffset + 1] = floats[srcOffset + 1];
            positions[posOffset + 2] = floats[srcOffset + 2];

            // Normal (NX, NY, NZ)
            normals[posOffset] = floats[srcOffset + 3];
            normals[posOffset + 1] = floats[srcOffset + 4];
            normals[posOffset + 2] = floats[srcOffset + 5];

            // UV (U, 1-V) - flip V coordinate
            uvs[uvOffset] = floats[srcOffset + 6];
            uvs[uvOffset + 1] = 1.0 - floats[srcOffset + 7];
          }

          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
          geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
          geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(indices.buffer), 1));
          geometry.computeBoundingSphere();

          // Create material (basic color since we're focused on animation)
          const material = new THREE.MeshLambertMaterial({
            color: 0x4a9eff,
            side: THREE.DoubleSide
          });

          const threeMesh = new THREE.Mesh(geometry, material);
          threeMesh.name = mesh.Name || `Mesh_${j}`;
          currentModel.add(threeMesh);
          meshCount++;
        }
      }

      // Apply coordinate system transformation (GR2 -> Three.js)
      const matrix = new THREE.Matrix4().set(
        1, 0, 0, 0,
        0, 0, 1, 0,
        0, 1, 0, 0,
        0, 0, 0, 1
      );
      currentModel.applyMatrix4(matrix);

      // Add skeleton visualization if bones are loaded
      if (animController.bones.length > 0) {
        const skeletonGroup = new THREE.Group();
        skeletonGroup.name = 'skeleton';

        const boneMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        const jointMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });

        // Create bone connections and joints
        animController.bones.forEach(bone => {
          // Create joint sphere at bone position
          if (bone.localTransform && bone.localTransform.position) {
            const pos = bone.localTransform.position;
            const jointGeom = new THREE.SphereGeometry(0.3, 8, 8);
            const joint = new THREE.Mesh(jointGeom, jointMaterial);
            joint.position.set(pos[0], pos[2], pos[1]); // Swap Y/Z for coordinate system
            joint.name = `joint_${bone.name}`;
            skeletonGroup.add(joint);
          }
        });

        currentModel.add(skeletonGroup);
        Logger.bone(`Added ${animController.bones.length} bone joints to visualization`);
      }

      scene.add(currentModel);

      // Auto-center and fit model to camera
      const box = new THREE.Box3().setFromObject(currentModel);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());

      Logger.info(`Model bounds: center=(${center.x.toFixed(1)}, ${center.y.toFixed(1)}, ${center.z.toFixed(1)}), size=(${size.x.toFixed(1)}, ${size.y.toFixed(1)}, ${size.z.toFixed(1)})`);

      // Center the model
      currentModel.position.sub(center);

      // Adjust camera distance based on model size
      const maxDim = Math.max(size.x, size.y, size.z);
      const distance = maxDim * 2.5;
      camera.position.set(distance, distance * 0.8, distance);
      camera.lookAt(0, 0, 0);

      Logger.info(`Camera positioned at distance: ${distance.toFixed(1)}`);

      needsRender = true;

      Logger.success(`Model rendered with ${meshCount} meshes`);
    }

    // Playback controls
    function togglePlayback() {
      animController.togglePlayback();
    }

    function stopAnimation() {
      animController.stop();
    }

    function resetAnimation() {
      animController.reset();
    }

    function toggleLoop() {
      animController.toggleLoop();
    }

    function setSpeed(value) {
      animController.setSpeed(parseFloat(value));
    }

    function seekAnimation(value) {
      animController.seek(parseFloat(value));
    }

    function animate(timestamp) {
      requestAnimationFrame(animate);

      if (timestamp - lastRenderTime < MIN_RENDER_INTERVAL) {
        return;
      }

      // Update animation
      animController.update(timestamp);

      if (animController.isPlaying || needsRender) {
        renderer.render(scene, camera);
        needsRender = false;
        lastRenderTime = timestamp;
      }
    }

    function onWindowResize() {
      const container = DOM.renderContainer;
      if (!container) return;

      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
      needsRender = true;
    }

    // Initialize
    init();
  </script>
</body>

</html>