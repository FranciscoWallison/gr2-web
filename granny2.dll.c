/* This file was generated by the Hex-Rays decompiler version 9.0.0.240807.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

_DWORD *__cdecl sub_10001000(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
BOOL __cdecl sub_10001080(int *a1, char *a2, char *a3, char *a4);
_DWORD *__cdecl sub_10001190(_DWORD *a1);
_DWORD *__cdecl sub_100011F0(_DWORD *a1);
double __cdecl sub_10001230(float *a1);
float *__cdecl sub_10001270(float *a1, int a2);
float *__cdecl sub_100012D0(float *a1, float *a2);
float *__cdecl sub_10001360(float *a1, float *a2, float *a3);
float *__cdecl sub_100013D0(float *a1, float *a2);
float *__cdecl sub_10001450(float *a1, float *a2, float *a3);
int __cdecl sub_100014D0(void *a1, int a2);
int __cdecl sub_10001500(void *a1, int a2);
int __cdecl sub_10001530(int a1, int a2, int a3);
BOOL __cdecl sub_10001690(int *a1, float *a2);
float *__cdecl sub_10001820(float *a1, float *a2, float *a3, float *a4);
float *__cdecl sub_10001850(int a1, int a2, float *a3);
_DWORD *__cdecl sub_100018D0(int a1, _DWORD *a2);
int __cdecl sub_10001980(_DWORD *a1);
int __cdecl sub_10001990(int a1);
int __cdecl sub_100019C0(_DWORD *a1);
int __cdecl sub_100019F0(int *a1);
char *__cdecl sub_10001A10(int a1);
int __cdecl sub_10001A20(int a1);
char __cdecl sub_10001A30(int *a1);
char __cdecl sub_10001A70(_DWORD *a1);
int __cdecl sub_10001AA0(int a1);
int __cdecl sub_10001AD0(_DWORD *a1);
BOOL __cdecl sub_10001B00(int a1);
// int __usercall sub_10001B10@<eax>(int a1@<ebx>, int a2, char *a3);
int __cdecl sub_10001B60(_DWORD *a1, int a2);
int __cdecl sub_10001B90(int a1);
int __cdecl sub_10001BB0(_DWORD *a1);
int __cdecl sub_10001BD0(_DWORD *a1);
bool __cdecl sub_10001BF0(_DWORD *a1, int a2);
_DWORD *__cdecl sub_10001CD0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_10001D50(_DWORD *a1, int a2, unsigned int *a3);
_DWORD *__cdecl sub_10001DD0(int a1, _DWORD *a2);
int __cdecl sub_10001DE0(int a1, char *a2);
char __cdecl sub_10001E40(char **a1, char *a2);
int __cdecl sub_10001E80(_DWORD *a1);
_DWORD *__cdecl sub_10001EC0(_DWORD *a1);
int *__cdecl sub_10001EE0(int a1, int a2, int a3, int a4);
int __cdecl sub_10001FC0(int *a1);
char __cdecl sub_10002020(int *a1, int a2, int a3, int a4);
char __cdecl sub_10002060(int *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_100020A0(int a1);
int *__cdecl sub_100020D0(int a1);
int __cdecl sub_10002100(int a1);
int __cdecl sub_10002120(int);
int __cdecl sub_10002130(int a1);
int __cdecl sub_10002150(int a1);
int __cdecl sub_10002160(int);
_DWORD *__cdecl sub_10002170(int a1);
void __cdecl sub_100021A0(unsigned int a1);
int __cdecl sub_100021D0(int a1);
int __cdecl sub_100021E0(int a1);
void __cdecl sub_100021F0(int a1, float a2);
char __cdecl sub_10002230(int a1);
char __cdecl sub_10002260(int a1, int a2, int a3, int a4);
int __cdecl sub_100022A0(int a1, int a2, int a3, int *a4);
int __cdecl sub_10002390(int a1, int a2, float *a3, float *a4);
int __cdecl sub_10002790(int a1);
BOOL __cdecl sub_100027A0(int a1);
BOOL __cdecl sub_100027C0(_DWORD *a1, _DWORD *a2);
BOOL __cdecl sub_10002820(int a1);
int __cdecl sub_10002830(int *a1, int a2, int a3);
int __cdecl sub_10002880(int *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_100028E0(int *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10002940(_DWORD *a1);
int __cdecl nullsub_1(_DWORD, _DWORD); // weak
unsigned int *__cdecl sub_10002980(unsigned int a1, int a2, _DWORD *a3, int a4, int *a5, unsigned int *a6, int a7, unsigned int *a8);
int __cdecl sub_10002B30(int a1, int a2);
unsigned int __cdecl sub_10002B50(int *a1, _DWORD *a2, unsigned int a3);
unsigned int __cdecl sub_10002BB0(unsigned int a1, int a2);
// int __usercall sub_10002BD0@<eax>(__m128 a1@<xmm6>, __m128 a2@<xmm7>, int a3, unsigned int *a4, float *a5, __m128 *a6);
// int __usercall sub_10002E50@<eax>(__m128 a1@<xmm6>, __m128 a2@<xmm7>, int a3, unsigned int *a4, float *a5, int a6);
void __cdecl sub_10002FB0(int a1, unsigned int *a2, float *a3, int a4);
// int __usercall sub_10003100@<eax>(__m128 a1@<xmm6>, __m128 a2@<xmm7>, int a3, unsigned int *a4, float *a5, __m128 *a6);
// int __usercall sub_10003390@<eax>(__m128 a1@<xmm6>, __m128 a2@<xmm7>, int a3, unsigned int *a4, float *a5, int a6);
int __cdecl sub_10003500(int a1, unsigned int *a2, float *a3, int a4);
int __cdecl sub_10003650(int a1, unsigned int *a2, float *a3, int a4, int a5);
int __cdecl sub_10003740(int a1, unsigned int *a2, float *a3, int a4);
// float *__usercall sub_10003820@<eax>(__m128 a1@<xmm6>, __m128 a2@<xmm7>, int a3, unsigned int *a4, float *a5, int a6, int a7);
// float *__usercall sub_100038D0@<eax>(__m128 a1@<xmm6>, __m128 a2@<xmm7>, int a3, unsigned int *a4, float *a5, int a6);
// float *__usercall sub_10003980@<eax>(__m128 a1@<xmm6>, __m128 a2@<xmm7>, int a3, unsigned int *a4, float *a5, int a6, int a7);
// float *__usercall sub_10003A30@<eax>(__m128 a1@<xmm6>, __m128 a2@<xmm7>, int a3, unsigned int *a4, float *a5, int a6);
void __cdecl sub_10003AE0(int a1, int a2, float *a3, __m128 *a4);
void __cdecl sub_10003C20(int a1, int a2, float *a3, _DWORD *a4, int a5);
void __cdecl sub_10003D10(int a1, int a2, float *a3, __m128 *a4);
char sub_10003DE0();
bool sub_10003EA0();
char __cdecl sub_10003EE0(int a1, char *a2, int *a3);
void __cdecl sub_10003F40(int a1, float a2, float *a3, float *a4, float *a5, float *a6, float *a7, float *a8, float *a9);
// int __usercall sub_100040C0@<eax>(double a1@<st0>, int a2, float *a3, float *a4, float *a5);
int __cdecl sub_100041C0(int a1, float *a2, float *a3, float *a4);
// int __usercall sub_10004220@<eax>(double a1@<st0>, _DWORD *a2, float *a3, float *a4, float *a5);
int __cdecl sub_10004280(int a1, float *a2, float *a3, float *a4);
// int __usercall sub_100042D0@<eax>(double a1@<st0>, _DWORD *a2, float *a3, float *a4, float *a5);
unsigned int __cdecl sub_10004380(int a1, int a2);
int __cdecl sub_100043A0(int a1);
unsigned int __cdecl sub_100043B0(int a1, int a2, int a3, int a4);
unsigned int *__cdecl sub_10004400(unsigned int *a1, unsigned int *a2);
unsigned int __cdecl sub_10004420(unsigned int *a1, int a2, int a3, int a4, unsigned int a5, unsigned int a6, unsigned int a7, int a8, unsigned int a9);
int __cdecl sub_100045B0(int a1, unsigned int a2, int a3, unsigned int a4, unsigned int a5, _BYTE *a6, unsigned int a7);
unsigned int __cdecl sub_10004740(unsigned int a1, unsigned int a2, unsigned int *a3, unsigned int *a4);
unsigned int __cdecl sub_100047B0(unsigned int *a1, int a2, int a3, int a4, unsigned int a5, unsigned int a6, unsigned int a7, int a8, unsigned int a9, unsigned int *a10);
int __cdecl sub_100052D0(int a1, int a2, __int16 *a3, int a4, int a5, int a6, int a7, unsigned int a8, unsigned int *a9);
int __cdecl sub_10005750(__int16 *a1, int a2, int a3, int a4, int *a5);
int __cdecl sub_10005880(__int16 *a1, int a2, int a3, int a4, int *a5);
int __cdecl sub_10005910(int a1, unsigned int a2, unsigned int a3, int a4, unsigned int a5, unsigned int a6, int a7, unsigned int a8, unsigned int a9, unsigned int a10);
int __cdecl sub_100060B0(int a1, int *a2, int *a3, int a4, unsigned int a5, unsigned int a6, int a7, unsigned int a8, unsigned int *a9);
unsigned int __cdecl sub_10006210(_WORD *a1, int a2, int a3, int a4, unsigned int a5, _DWORD *a6, unsigned int *a7);
int __cdecl sub_100062C0(_WORD *a1, int a2, int a3, int a4, int a5, _DWORD *a6, _DWORD *a7, _DWORD *a8);
int __cdecl sub_10006310(int a1, __int16 *a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10006380(int a1, _WORD *a2, int a3, int a4, unsigned int a5, int a6, unsigned int a7);
// char *__usercall sub_10006470@<eax>(int a1@<ebx>, __int16 *a2, int a3, int a4, int a5, int a6, char *a7);
_DWORD *__cdecl sub_100064E0(int a1, unsigned int a2, unsigned int a3, unsigned int a4, double *a5, _DWORD *a6);
void __cdecl sub_100065E0(_DWORD *a1);
int __cdecl sub_10006650(_DWORD *a1, char *a2, unsigned int a3, unsigned int a4, _BYTE *a5, int a6);
unsigned int __cdecl sub_100069A0(int *a1, _BYTE *a2, unsigned int a3);
// int __usercall sub_10006A30@<eax>(int a1@<ebp>, int *a2, int *a3, char *a4, int a5, unsigned int a6, int a7, int a8);
// int __usercall sub_10006DF0@<eax>(int a1@<ebp>, char *a2, int a3, unsigned int a4, int a5, __int16 a6);
unsigned int __cdecl sub_10006E50(int *a1, int *a2, char *a3, int a4, unsigned int a5, int a6, int a7);
unsigned int __cdecl sub_10007540(_DWORD *a1, int *a2, int *a3, int a4, int a5, unsigned int a6, int a7);
__int16 *__cdecl sub_100075F0(int a1, int a2, int a3, int a4, unsigned int a5, int a6, int a7, int a8);
int __cdecl sub_10007820(_WORD *a1, int a2, __int16 *a3, int a4, int a5, int a6, int a7, unsigned int a8);
int __cdecl sub_10007B00(int a1, int a2, int a3, int a4, unsigned int a5, int a6, int a7, int a8);
int __cdecl sub_10007BB0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8);
unsigned int __cdecl sub_10007C50(int a1, int a2, unsigned int a3, unsigned int a4, int a5);
unsigned int __cdecl sub_10007D70(int a1, int a2, int a3, int a4, unsigned int a5, unsigned int a6, int a7, int a8, int a9);
int __cdecl sub_10008950(int *a1, int a2, _DWORD *a3, int a4, unsigned int a5, int a6, unsigned int a7, unsigned int a8);
int __cdecl sub_100094C0(int a1, int a2, int a3, int a4, unsigned int a5, unsigned int a6, int a7, int a8, int a9);
int __cdecl sub_100095F0(_WORD *a1, int a2, char *a3, int a4, int a5, int a6, unsigned int a7, unsigned int a8);
unsigned int __cdecl sub_10009700(int a1, int a2, unsigned int a3, unsigned int a4, int a5, int a6);
int __cdecl sub_10009830(char *a1, char *a2, char *a3, char *a4, int a5, int a6, unsigned __int8 *a7, int a8, int a9, int a10);
// char *__usercall sub_100099F0@<eax>(int a1@<ebx>, char *a2, __int16 a3, unsigned int a4);
int __cdecl sub_10009A30(int *a1, __int16 *a2, __int16 *a3, __int16 *a4, __int16 *a5, int a6, int a7, int a8);
int *__cdecl sub_10009B60(char a1);
unsigned int __cdecl sub_10009B80(int a1, int a2, char a3, int a4);
int __cdecl sub_10009BF0(char a1);
int __cdecl sub_10009C00(int a1, int a2, char a3, int a4);
char __cdecl sub_10009C30(_DWORD *a1, _DWORD *a2);
int __cdecl sub_10009C80(int a1, int a2, int a3, unsigned __int8 *a4, char a5, int a6, unsigned int *a7);
unsigned int *__cdecl sub_10009E50(int *a1, int a2, char a3, int *a4, unsigned int *a5, int a6, unsigned int *a7);
_DWORD *__cdecl sub_1000A020(int a1, _DWORD *a2, int a3, _DWORD *a4);
int __cdecl sub_1000A030(int a1, _DWORD *a2, int a3, _DWORD *a4);
int __cdecl sub_1000A050(int a1, _DWORD *a2, int a3, _DWORD *a4);
int __cdecl sub_1000A070(int a1, _DWORD *a2, int a3, _DWORD *a4);
float *__cdecl sub_1000A0B0(float *a1, float *a2, float a3, float *a4);
float *__cdecl sub_1000A0F0(float *a1, float *a2, float a3, float *a4);
float *__cdecl sub_1000A140(float *a1, float *a2, float a3, float *a4);
float *__cdecl sub_1000A1F0(float *a1, float *a2, float a3, float *a4);
float *__cdecl sub_1000A2A0(float *a1, float *a2, float a3, float *a4);
float *__cdecl sub_1000A330(float *a1, float *a2, float a3, float *a4);
float *__cdecl sub_1000A3E0(float *a1, float *a2, float a3, float *a4);
float *__cdecl sub_1000A500(float *a1, float *a2, float a3, float *a4);
float *__cdecl sub_1000A640(float *a1, float *a2, float a3, float *a4);
float *__cdecl sub_1000A760(float *a1, float *a2, float a3, float *a4);
float *__cdecl sub_1000A8E0(float *a1, float *a2, float a3, float *a4);
float *__cdecl sub_1000AAD0(float *a1, float *a2, float a3, float *a4);
void __cdecl sub_1000AD10(unsigned int a1, unsigned int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1000ADC0(int a1, int a2, float a3); // idb
int __cdecl sub_1000AE30(int a1, int a2, float a3, int a4); // idb
char __cdecl sub_1000AEB0(int a1, _DWORD *a2, _DWORD *a3, int a4, int a5, _DWORD *a6, int a7, _DWORD *a8, _DWORD *a9);
int sub_1000B1B0();
int sub_1000B1D0();
int sub_1000B1F0();
int sub_1000B210();
int sub_1000B240();
int sub_1000B270();
char __thiscall sub_1000B290(float *this, float a2);
int __thiscall sub_1000B2C0(int this);
char __thiscall sub_1000B300(float *this, float a2);
char __thiscall sub_1000B310(int this, float a2, float a3, int a4);
int __thiscall sub_1000B6E0(float *this, int a2);
int __thiscall sub_1000B720(_DWORD *this, int a2);
float *__cdecl sub_1000B750(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float *a8, float *a9, float *a10, float *a11);
_DWORD *__thiscall sub_1000B860(_DWORD *this, int a2, int a3, int a4, char a5);
int __thiscall sub_1000B9A0(int *this);
int __thiscall sub_1000BA50(float *this);
int __thiscall sub_1000BAD0(float *this);
int __thiscall sub_1000BB60(float *this);
int __thiscall sub_1000BCA0(float *this);
int __thiscall sub_1000BED0(float *this);
int __thiscall sub_1000C1A0(float *this);
int __thiscall sub_1000C3E0(float *this, int a2);
int __thiscall sub_1000C450(char *this, int a2);
char __thiscall sub_1000C4C0(float *this, float a2);
int __thiscall sub_1000C750(unsigned int *this, int a2, int a3);
int __thiscall sub_1000C810(unsigned int *this, int a2);
long double __thiscall sub_1000C840(_DWORD *this, int a2, float a3, int a4);
int __thiscall sub_1000C890(_DWORD *this, int a2);
void __thiscall sub_1000C8B0(_DWORD *this);
int __thiscall sub_1000C8C0(_DWORD *this, int a2, int a3, int a4);
float *__thiscall sub_1000C8E0(float **this, float *a2, float a3);
double __cdecl sub_1000C910(_DWORD *a1, _DWORD *a2);
void __cdecl sub_1000C980(int a1, _DWORD *a2, int a3);
int __cdecl sub_1000CA00(int a1, int a2);
float *__cdecl sub_1000CB60(int a1, int a2, int a3);
int __cdecl sub_1000CC90(float a1, int a2, char a3, int a4, _DWORD *a5, int a6, float a7, int a8, int a9);
int __cdecl sub_1000CD70(int a1);
float *__cdecl sub_1000CDF0(float *a1, float a2, float a3, float a4, float a5, float a6);
float *__cdecl sub_1000CE20(float *a1, float a2, float a3, float a4);
int __cdecl sub_1000CEC0(float *a1);
int __cdecl sub_1000CEF0(float *a1, int a2, int a3);
int __cdecl sub_1000CFE0(float *a1, int a2, int a3);
int __cdecl sub_1000D2F0(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_1000D320(float *a1, float *a2);
int __cdecl sub_1000D350(_DWORD *a1, _DWORD *a2);
int __cdecl sub_1000D380(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_1000D3B0(float *a1, float *a2);
float *__cdecl sub_1000D3E0(float *a1, float *a2);
int __cdecl sub_1000D410(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_1000D440(float *a1, float a2, float a3, float *a4, float *a5);
float *__cdecl sub_1000D630(float *a1, float a2, float a3, float *a4, float *a5);
float *__cdecl sub_1000D800(float *a1, float a2, float a3, int a4, int a5, int a6, float *a7);
void __cdecl sub_1000D8B0(_DWORD *a1, float a2, float *a3, float *a4, int a5, float *a6);
double __cdecl sub_1000DA00(int a1, int a2);
int __cdecl sub_1000DA40(int, unsigned int, int, unsigned int);
int __cdecl sub_1000DA50(int a1, unsigned int a2, int a3, unsigned int a4);
int __cdecl sub_1000DD90(int a1, unsigned int a2, unsigned int a3);
int __cdecl sub_1000DDB0(int *, unsigned int, int, unsigned int);
int __cdecl sub_1000DDC0(int *a1, unsigned int a2, int a3, unsigned int a4);
unsigned int __cdecl sub_1000E020(int *a1, unsigned int a2);
unsigned int __cdecl sub_1000E070(int a1, int a2);
unsigned int __cdecl sub_1000E090(int a1);
unsigned int __cdecl sub_1000E0B0(int a1);
int __cdecl sub_1000E0C0(int a1, int a2, int a3, int a4);
int __cdecl sub_1000E130(_WORD *a1, unsigned int a2);
int __cdecl sub_1000E1C0(int a1, unsigned int a2, int a3);
int __cdecl sub_1000E250(int a1);
// int __usercall sub_1000E270@<eax>(int a1@<ebx>, int a2, int a3, int a4);
__int16 __cdecl sub_1000E320(int a1, unsigned int a2);
// unsigned int __usercall sub_1000E3E0@<eax>(int a1@<ebx>, int a2);
unsigned int __cdecl sub_1000E690(_WORD *a1, _WORD *a2);
// int __usercall sub_1000E6F0@<eax>(int a1@<ebx>, unsigned int a2, int a3);
__int16 __cdecl sub_1000E7F0(unsigned __int16 *a1, unsigned int a2, unsigned int *a3);
// unsigned int __usercall sub_1000EC30@<eax>(int a1@<ebx>, unsigned int a2);
int __cdecl sub_1000EE30(int a1, int a2, int a3);
double __cdecl sub_1000EE80(int a1, int a2, unsigned int a3);
int sub_1000EF40();
int sub_1000EF60();
int sub_1000EF80();
int sub_1000EFA0();
int sub_1000EFD0();
int sub_1000F000();
int __cdecl sub_1000F020(int a1);
_DWORD *__cdecl sub_1000F030(int a1, int a2);
void *sub_1000F0D0();
void __cdecl sub_1000F0F0(unsigned int a1);
char __cdecl sub_1000F150(int a1);
int __cdecl sub_1000F170(int a1, int a2);
double __cdecl sub_1000F180(int a1);
void __cdecl sub_1000F190(int a1, float a2);
int __cdecl sub_1000F360(int a1, float a2); // idb
BOOL __cdecl sub_1000F370(int a1);
char __cdecl sub_1000F3A0(int a1);
char __cdecl sub_1000F3D0(int a1);
double __cdecl sub_1000F410(int a1);
double __cdecl sub_1000F420(int a1);
double __cdecl sub_1000F540(float a1, float a2, float a3, float *a4);
double __cdecl sub_1000F5C0(int a1);
int __cdecl sub_1000F5E0(int a1, float a2); // idb
int __cdecl sub_1000F5F0(int a1);
int __cdecl sub_1000F600(int a1, int a2);
bool __cdecl sub_1000F610(int a1, bool *a2, bool *a3);
int __cdecl sub_1000F650(int a1);
int __cdecl sub_1000F660(int a1, int a2);
double __cdecl sub_1000F670(int a1);
int __cdecl sub_1000F680(int a1, float a2); // idb
double __cdecl sub_1000F690(int a1);
double __cdecl sub_1000F6D0(float a1);
char __cdecl sub_1000F740(int a1);
char __cdecl sub_1000F750(int a1, char a2);
double __cdecl sub_1000F760(int a1);
double __cdecl sub_1000F790(int a1);
char __cdecl sub_1000F7A0(int a1, char a2);
int __cdecl sub_1000F7B0(int a1, float a2, int a3, int a4, int a5, int a6, int a7); // idb
char __cdecl sub_1000F7E0(int a1, char a2);
int __cdecl sub_1000F7F0(int a1, float a2, int a3, int a4, int a5, int a6, int a7); // idb
double __cdecl sub_1000F820(int a1);
int __cdecl sub_1000F830(int a1, float a2); // idb
double __cdecl sub_1000F840(int a1, float a2, char a3);
double __cdecl sub_1000F8C0(int a1, int a2);
int __cdecl sub_1000F920(int a1);
float *__cdecl sub_1000F930(float a1);
int __cdecl sub_1000F990(int a1, int a2, int a3, _DWORD *a4);
char __cdecl sub_1000F9E0(int a1, int a2);
void __cdecl sub_1000FEF0(char a1, char a2, int a3, int a4, int a5, int a6, int *a7, int a8);
void __cdecl sub_1000FFB0(int *a1, float a2, float *a3, float *a4, float *a5);
_DWORD *__cdecl sub_100100C0(float a1, int a2, int a3);
int __cdecl sub_10010120(float a1, int a2); // idb
_DWORD *__cdecl sub_100101C0(int *a1);
void __cdecl sub_10010280(int a1, int a2, int a3);
void __cdecl sub_100102D0(int a1, int a2, int a3, int a4);
void __cdecl sub_10010320(int a1, int a2, int a3);
void __cdecl sub_10010370(int a1, int a2, int a3);
void __cdecl sub_100103C0(int a1, int a2, char a3);
char __cdecl sub_10010430(int a1, _DWORD *a2);
void __cdecl sub_10010450(int *a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_10010500(int a1, int a2, int a3, int a4, int a5);
_DWORD *__cdecl sub_100105A0(_DWORD *a1);
unsigned int __cdecl sub_100105B0(int *a1, int a2, unsigned __int8 *a3);
int *__cdecl sub_100105F0(int *a1);
int __cdecl sub_10010600(int a1, int a2, char *a3);
// char *__usercall sub_10010650@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, char *a6);
int __cdecl sub_10010690(int a1, int a2);
// char *__usercall sub_100106C0@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, int a6, char *a7);
// void __usercall sub_10010740(double a1@<st0>, int a2, int *a3, char **a4, _DWORD *a5, char *a6);
// char *__usercall sub_10010970@<eax>(double a1@<st0>, int a2, char **a3);
int __cdecl sub_10010A80(int a1, int a2);
double __cdecl sub_10010AB0(int a1, char **a2);
// int __usercall sub_10010BF0@<eax>(double a1@<st0>, int a2, int a3, char **a4);
int __cdecl sub_10010D00(int a1);
int __cdecl sub_10010D20(int a1, int a2);
int __cdecl sub_10010D40(float a1, int a2); // idb
// char *__usercall sub_10010D60@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, char *a6);
// int __usercall sub_10010DA0@<eax>(double a1@<st0>, int a2, unsigned int a3, int *a4);
// int __usercall sub_10010DF0@<eax>(double a1@<st0>, int a2, unsigned int a3, int *a4);
// char *__usercall sub_10010E40@<eax>(double a1@<st0>, int a2, int a3, unsigned int a4, int *a5, char *a6);
int __cdecl sub_10010ED0(int a1, int a2);
char __cdecl sub_10010F00(int a1, int a2, int a3, int *a4, char *a5);
void *__cdecl sub_10011270(int a1, void *a2);
// char *__usercall sub_10011290@<eax>(double a1@<st0>, int a2, unsigned int a3, int *a4, int a5);
char __cdecl sub_10011310(unsigned int *a1, int a2);
char __cdecl sub_100114D0(unsigned int *a1, unsigned int *a2);
int __cdecl sub_10011510(int a1, int a2, int a3);
int __cdecl sub_10011650(int a1);
int __cdecl sub_10011690(int a1, int a2);
int __cdecl sub_100116A0(int a1, unsigned int a2, int a3);
int __cdecl sub_100116C0(int a1, int a2, unsigned int a3);
int __cdecl sub_10011740(int a1, unsigned int a2, int a3);
char __cdecl sub_10011760(int a1, _DWORD *a2);
_DWORD *__cdecl sub_10011950(int a1, int *a2);
char __cdecl sub_10011A90(int a1, _DWORD *a2);
_DWORD *__cdecl sub_10011AB0(int *a1, unsigned __int8 *a2);
_DWORD *__cdecl sub_10011B70(int *a1, int *a2, unsigned __int8 *a3);
unsigned int __cdecl sub_10011C40(int a1, _DWORD *a2, unsigned int *a3, int *a4);
int __cdecl sub_10011CD0(int a1, int a2, unsigned int *a3, int *a4);
int __cdecl sub_10012050(int *a1, int a2, int *a3, int a4, int a5, unsigned __int8 *a6);
char __cdecl sub_100121A0(int a1, int a2, const CHAR *a3, int a4);
char __cdecl sub_10012250(_DWORD *a1, _DWORD *a2, int a3, _DWORD *a4);
int __cdecl sub_100123B0(const void *a1);
int __cdecl sub_100123E0(int a1, const void *a2);
int __cdecl sub_10012410(int a1, __int16 a2);
int __cdecl sub_10012520(int a1, int a2, int a3);
char __cdecl sub_100127B0(int a1, int a2, char a3, int a4, unsigned int *a5);
int __cdecl sub_10012800(int a1, int a2, int a3);
bool __cdecl sub_10012A30(LPCSTR lpFileName);
int __cdecl sub_10012BB0(int a1, int a2, char *a3);
int __cdecl sub_10012CF0(LPCSTR lpFileName);
int __cdecl sub_10012E40(int a1, int a2);
int __cdecl sub_10012E90(int a1);
// int __usercall sub_10012F90@<eax>(int a1@<ebx>, int a2);
void __cdecl sub_100130A0(_DWORD *a1, int a2);
int __cdecl sub_10013110(_DWORD *a1);
int __cdecl sub_10013140(_DWORD *a1);
int __cdecl sub_10013190(int a1);
int __cdecl sub_100131D0(int a1);
// _DWORD *__usercall sub_10013200@<eax>(int a1@<ebx>, int a2, int a3, _BYTE *a4, _BYTE *a5);
// void __usercall sub_10013340(int a1@<ebx>, int a2);
_DWORD *__cdecl sub_100133A0(_DWORD *a1);
bool __cdecl sub_100133B0(int a1);
int __cdecl sub_10013440(char a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10013480(int a1);
int __cdecl sub_10013510(int a1);
int __cdecl sub_10013590(char a1, int a2, int a3, int a4);
char __cdecl sub_100135C0(int a1, LPCSTR lpFileName);
char __cdecl sub_10013610(int a1, HANDLE *a2);
char __cdecl sub_10013660(int a1, HANDLE *NumberOfBytesWritten);
int __cdecl sub_10013A10(int a1, int *a2);
char __cdecl sub_10013A50(int a1, int a2, int a3, unsigned __int8 *a4);
int __cdecl sub_10013B70(int a1);
void __cdecl sub_10013BB0(int a1, int a2, int a3, int a4);
int *__cdecl sub_10013C10(int *a1, int a2, int a3, int a4, DWORD a5, unsigned __int8 *a6);
int __cdecl sub_10013CE0(int a1);
DWORD __cdecl sub_10013D10(int a1, int a2, int a3, DWORD nNumberOfBytesToWrite, unsigned __int8 *lpBuffer);
char __cdecl sub_10013D70(int a1, int a2, int a3);
_DWORD *__cdecl sub_10013E00(_DWORD *a1, int a2, _DWORD *a3, int a4);
_DWORD *__cdecl sub_10013E30(_DWORD *a1, unsigned int *a2, int a3, unsigned int *a4);
_DWORD *__cdecl sub_10013F50(int a1, _DWORD *a2, _DWORD *a3);
void __cdecl sub_10013F70(_DWORD *a1, unsigned int *a2, unsigned int *a3, int a4);
_DWORD *__cdecl sub_10014080(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_100140C0(int a1);
char __cdecl sub_100140D0(int a1, int a2, _BYTE *a3, int a4, int a5, int a6, _BYTE *a7);
// _DWORD *__usercall sub_100141D0@<eax>(int a1@<ebx>, int a2, int a3, int a4, int a5);
bool __cdecl sub_100142B0(_DWORD *a1, unsigned int a2, LPCSTR lpFileName, int a4, unsigned __int8 *a5);
char __cdecl sub_100143D0(_DWORD *a1, DWORD *lpBuffer);
char __cdecl sub_10014460(int a1, unsigned int *a2, _BYTE *a3);
int __cdecl sub_100144F0(int a1);
int __cdecl sub_10014500(int a1, int a2, int a3, unsigned int *a4);
_DWORD *__cdecl sub_10014530(_DWORD *a1, _DWORD *a2, int a3, int a4);
int __cdecl sub_10014580(int a1, int *a2, int a3, int a4);
int __cdecl sub_100145D0(int a1, _DWORD *a2);
// unsigned int __usercall sub_100145F0@<eax>(double a1@<st0>, int a2);
bool __cdecl sub_10014660(DWORD NumberOfBytesWritten, LPCSTR lpFileName, int a3, unsigned __int8 *lpBuffer, _DWORD *a5);
int __cdecl sub_10014700(LPCSTR lpFileName); // idb
BOOL __cdecl sub_10014710(LPCSTR lpFileName);
_DWORD *__cdecl sub_10014720(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_10014780(int a1);
int (__cdecl *GrannyGetDefaultFileReaderOpenCallback())(int, int, LPCSTR lpFileName);
int (__cdecl *__cdecl sub_100147B0(int (__cdecl *a1)(int, int, LPCSTR lpFileName)))(int, int, LPCSTR lpFileName);
_DWORD *__cdecl sub_100147C0(int a1, int a2, LPCSTR lpFileName);
int __cdecl sub_10014A90(HANDLE *NumberOfBytesWritten);
int __cdecl sub_10014AF0(int a1);
int __cdecl sub_10014B00(LPCSTR lpFileName, char a2); // idb
void __cdecl sub_10014B80(HANDLE *a1);
DWORD __cdecl sub_10014BC0(HANDLE *a1);
DWORD __cdecl sub_10014BE0(HANDLE *a1, LONG lDistanceToMove);
DWORD __cdecl sub_10014C00(HANDLE *a1, LONG lDistanceToMove);
DWORD __cdecl sub_10014C20(HANDLE *a1, LONG lDistanceToMove);
char __cdecl sub_10014C40(DWORD NumberOfBytesWritten, DWORD nNumberOfBytesToWrite, unsigned __int8 *lpBuffer);
_DWORD *__cdecl sub_10014CB0(int a1);
char __cdecl sub_10014CD0(int a1);
int __cdecl sub_10014CE0(int a1);
_DWORD *__cdecl sub_10014D00(int *a1);
_DWORD *__cdecl sub_10014D90(_DWORD *a1);
_DWORD *__cdecl sub_10014E30(_DWORD *a1, _DWORD *a2);
void __cdecl sub_10014E60(_DWORD *a1, unsigned int a2);
_DWORD *__cdecl sub_10014EB0(_DWORD *a1, unsigned int a2);
_DWORD *__cdecl sub_10014EF0(int a1, _DWORD *a2, int a3);
int __cdecl sub_10014F20(int a1);
int __cdecl sub_10014F30(int a1);
int __cdecl sub_10014F60(int a1, int a2, float *a3, int a4, int a5, int a6);
int __cdecl sub_100150C0(int a1, int a2, float *a3, int a4, int a5);
float *__cdecl sub_10015200(int a1, int a2, float *a3, int a4, int a5, int a6);
float *__cdecl sub_10015440(int a1, int a2, float *a3, int a4, int a5);
float *__cdecl sub_10015670(int a1, int a2, float *a3, int a4, int a5, int a6);
float *__cdecl sub_10015A60(int a1, int a2, float *a3, int a4, int a5);
float *__cdecl sub_10015E40(int a1, float *a2, float *a3, _DWORD *a4, int a5, int a6);
float *__cdecl sub_10015F80(int a1, float *a2, float *a3, float *a4, int a5);
int sub_10016080();
double sub_10016130();
int GrannyGetGrannyHeadBezierCount();
char *__cdecl sub_10016150(int a1);
// unsigned int __usercall sub_10016170@<eax>(double a1@<st0>, int a2);
unsigned int *__cdecl sub_100161E0(int a1, int a2, unsigned int *a3);
int __cdecl sub_10016220(int a1, int a2, float *a3, int a4, int a5, float *a6, int *a7, int *a8);
void __cdecl sub_10016540(float a1, unsigned int a2, unsigned int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __cdecl sub_100165B0(int a1, int a2);
double __cdecl sub_100165C0(float a1);
double __cdecl sub_100165F0(float a1);
int *__cdecl sub_100166C0(float a1, int a2, int a3, unsigned int a4, unsigned int a5);
int __cdecl sub_100167B0(int a1, unsigned int a2, int *a3, int *a4, int *a5, double (__cdecl *a6)(_DWORD), float a7);
int __cdecl sub_10016C50(int a1);
int __cdecl sub_10016CA0(_DWORD *a1, int a2, int a3, int a4, int a5, int (__cdecl *a6)(int, _DWORD));
int __cdecl sub_10016FB0(float *a1, float a2, float *a3, float *a4, float *a5);
BOOL __cdecl sub_10017020();
BOOL __cdecl sub_10017090(float *a1, float a2, float *a3, float *a4, float *a5, float *a6);
BOOL __cdecl sub_10017140(float *a1, float *a2, int a3, float *a4, float *a5);
void __cdecl sub_10017270(float *a1, float a2, float *a3, float *a4, float *a5, float *a6);
BOOL __cdecl sub_10017300(int a1, float *a2, int a3, float *a4, float *a5, int a6);
void __cdecl sub_10017470(float *a1, float a2, float *a3, float *a4, _DWORD *a5, _DWORD *a6, float *a7, float *a8);
int __cdecl sub_10017510(float *a1, float *a2, float *a3, float *a4, float *a5, int a6);
// int __usercall sub_10017720@<eax>(int a1@<ebx>, int a2);
int __cdecl sub_10017750(int a1);
int __cdecl sub_10017770(int a1);
int __cdecl sub_10017790(int a1, int *a2);
// int __usercall sub_100177C0@<eax>(int a1@<ebx>, int a2, int a3);
int __cdecl sub_10017830(int *a1, int a2);
int __cdecl sub_10017870(int a1);
int __cdecl sub_10017880(int a1, int a2, float a3, float *a4);
void __cdecl sub_10017AA0(int *a1, int a2, int a3, int a4, int a5);
double __cdecl sub_10017CE0(int a1);
int __cdecl sub_10017CF0(int a1, float a2); // idb
void __cdecl sub_10017D00(int a1, int a2, int *a3, float *a4, int a5);
int __cdecl sub_10017EF0(int a1, int *a2, int *a3, float *a4, int a5);
char __cdecl sub_10017F30(CHAR *lpFileName, char a2);
__int64 GrannyGetLogCallback();
__int64 *__cdecl sub_10017FA0(__int64 *a1);
BOOL GrannyLogging();
void sub_10017FE0(int a1, int a2, char *a3, ...);
int (__cdecl *__cdecl sub_100180C0(int a1, int a2, DWORD nNumberOfBytesToWrite, unsigned __int8 *lpBuffer))(_DWORD, _DWORD, _DWORD, _DWORD);
bool __cdecl sub_10018150(int a1, char a2);
// __int16 __usercall sub_10018170@<ax>(int a1@<edx>, char a2);
int GrannyGetMostSeriousMessageType();
char *GrannyGetMostSeriousMessage();
int GrannyClearMostSeriousMessage();
void __cdecl sub_100181D0(float *a1, float *a2);
int __cdecl sub_100182E0(int a1, float *a2);
float *__cdecl sub_10018450(float *a1, float *a2, float *a3);
float *__cdecl sub_10018540(float *a1, float *a2, float *a3);
int __cdecl sub_10018630(int a1, float *a2, float *a3);
float *__cdecl sub_10018780(float *a1, float *a2, float *a3);
float *__cdecl sub_100189A0(float *a1, float *a2);
int __cdecl sub_10018A70(float *a1, float *a2);
int __cdecl sub_10018B10(int a1, int a2, int a3);
float *__cdecl sub_10018BC0(float *a1, float *a2, float *a3);
float *__cdecl sub_10018C80(float *a1, float *a2);
int __cdecl sub_10018D90(int a1, float *a2);
char __cdecl sub_10018E60(int a1, float a2, int a3, int a4);
float *__cdecl sub_100191A0(float *a1, float *a2, float *a3);
int __cdecl sub_10019210(float *a1, float *a2, float *a3);
float *__cdecl sub_100192E0(float *a1, float *a2, float *a3);
float *__cdecl sub_10019310(float *a1, float *a2, float *a3, float *a4, float *a5, float *a6);
int __cdecl sub_10019350(float *a1, float *a2, float *a3, float *a4);
int __cdecl sub_10019420(int a1, int a2, _DWORD *a3);
int __cdecl sub_10019460(_DWORD *a1);
int __cdecl sub_10019560(int a1, _DWORD *a2, int a3, int a4, _DWORD *a5);
BOOL __cdecl sub_100195B0(_DWORD *a1);
int __cdecl sub_100195E0(int *a1);
int __cdecl sub_10019620(int a1, _DWORD *a2);
int __cdecl sub_10019680(int a1, _DWORD *a2);
int __cdecl sub_10019710(int a1, _DWORD *a2);
int __cdecl sub_10019770(const char *a1, int a2, unsigned int a3, int a4);
int __cdecl sub_10019830(int a1);
void __cdecl sub_10019840(const char *a1, int a2, int a3);
BOOL __cdecl sub_100198B0(_DWORD *a1);
void *GrannyAllocationsBegin();
int __cdecl sub_100198E0(int a1);
void *GrannyAllocationsEnd();
int __cdecl sub_10019900(_DWORD *a1, int *a2);
int __cdecl sub_10019940(int a1);
int GrannyBeginAllocationCheck();
int __cdecl sub_10019970(int);
bool __cdecl sub_10019980(int a1);
int sub_10019A40();
int __cdecl sub_10019A50(int a1);
int __cdecl sub_10019A60(_DWORD *a1, int a2);
int __cdecl sub_10019A80(_DWORD *a1, int a2);
int __cdecl sub_10019AE0(int a1);
int __cdecl sub_10019B10(int a1, int a2);
int __cdecl sub_10019B30(int a1, int a2);
int __cdecl sub_10019B90(int a1, int a2, int a3);
int __cdecl sub_10019BC0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10019C00(int a1, int a2, int a3, int a4);
int __cdecl sub_10019C60(int a1, int a2);
void __cdecl sub_10019CA0(int a1);
int sub_10019D30();
int __cdecl sub_10019D50(int a1, int a2, int a3);
int sub_10019D70();
// void __usercall sub_10019D80(int a1@<ebx>, unsigned int a2, char a3, char *a4);
int __cdecl sub_10019DC0(unsigned int a1, int a2, void *a3);
int __cdecl sub_10019DE0(int a1, float a2, float *a3);
_BYTE *__cdecl sub_10019E10(int a1, _BYTE *a2, int a3);
_DWORD *__cdecl sub_10019E30(int a1, _DWORD *a2, int a3);
char __cdecl sub_10019E50(int a1, char *a2, int a3);
int __cdecl sub_10019E80(int a1, unsigned int *a2);
int __cdecl sub_10019EE0(int a1, int *a2);
int __cdecl sub_10019F20(int a1);
int (__cdecl *__cdecl sub_10019F40(_DWORD *a1, _DWORD *a2))(int, int, int);
int (__cdecl *__cdecl sub_10019F60(int (__cdecl *a1)(int, int, int, int), int (__cdecl *a2)(int, int, int)))(int, int, int, int);
LPVOID __cdecl sub_10019F80(SIZE_T dwBytes);
BOOL __cdecl sub_10019FA0(LPVOID lpMem);
_DWORD *GrannyNewMemoryArena();
int __cdecl sub_10019FE0(_DWORD **a1);
int __cdecl sub_1001A000(_DWORD *a1);
int __cdecl sub_1001A030(_DWORD *a1, int a2);
_DWORD *__cdecl sub_1001A090(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1001A0F0(int a1, int a2, int a3);
int sub_1001A110(); // weak
int __cdecl sub_1001A160(int a1);
int __cdecl sub_1001A170(int a1);
int __cdecl sub_1001A190(int a1);
int __cdecl sub_1001A1A0(int a1);
// void __usercall sub_1001A1C0(double a1@<st0>, const char **a2, _DWORD *a3, char *a4);
int __cdecl sub_1001A220(int a1);
BOOL __cdecl sub_1001A240(int a1);
int __cdecl sub_1001A250(int a1);
int __cdecl sub_1001A270(int a1);
int __cdecl sub_1001A290(int a1);
void __cdecl sub_1001A2B0(const char **a1, unsigned int a2, int *a3);
int __cdecl sub_1001A310(float *a1, float *a2, int a3, float *a4);
int __cdecl sub_1001A4B0(int a1, int a2, int a3);
int __cdecl sub_1001A4F0(int a1);
int __cdecl sub_1001A510(int a1, int a2, int a3);
int __cdecl sub_1001A540(int a1, int a2, int a3, int *a4);
int __cdecl sub_1001A590(int a1, int a2, int a3, int a4);
bool __cdecl sub_1001A6A0(int a1);
int __cdecl sub_1001A6C0(int a1, int a2);
void __cdecl sub_1001A6D0(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5);
int __cdecl sub_1001A7A0(int a1);
int __cdecl sub_1001A7B0(int a1);
int __cdecl sub_1001A7C0(int a1);
int __cdecl sub_1001A7D0(int a1, int a2, unsigned int a3, int a4, int a5);
int __cdecl sub_1001AAD0(int a1);
int __cdecl sub_1001AB10(int a1);
char *__cdecl sub_1001AB40(_DWORD *a1);
BOOL __cdecl sub_1001ABD0(int a1, int *a2, int *a3);
int __cdecl sub_1001AC60(int a1);
int __cdecl sub_1001AC90(int a1, int *a2);
int __cdecl sub_1001ACE0(_DWORD *a1);
int __cdecl sub_1001AD10(_DWORD *a1, int *a2);
int __cdecl sub_1001ADA0(int a1);
int __cdecl sub_1001ADB0(int a1);
int __cdecl sub_1001ADC0(int a1);
void __cdecl sub_1001ADD0(int a1, int a2, int *a3, int a4, int *a5);
int __cdecl sub_1001AF70(int a1, int a2, int *a3, int *a4);
int __cdecl sub_1001B0E0(int a1, int a2);
int __cdecl sub_1001B100(int a1, int a2, int a3, int a4);
int __cdecl sub_1001B1B0(int *a1, int *a2);
int __cdecl sub_1001B1D0(int a1, int a2, int a3, int a4);
int __cdecl sub_1001B290(int a1, int a2, _DWORD *a3);
float *__cdecl sub_1001B2E0(float *a1, float a2);
int __cdecl sub_1001B2F0(int a1, float a2); // idb
int __cdecl sub_1001B300(int a1, float a2); // idb
int __cdecl sub_1001B310(int a1, int a2, float a3); // idb
_DWORD *__cdecl sub_1001B330(_DWORD *a1, int a2, int a3, int a4);
float *__cdecl sub_1001B360(int a1, int a2, float a3);
// int __usercall sub_1001B380@<eax>(int a1@<ebx>, double a2@<st0>, int *a3);
void __cdecl sub_1001B410(int *a1);
int __cdecl sub_1001B530(int a1, int a2, int a3);
_DWORD *__cdecl sub_1001B550(int a1, int a2, int a3, int a4, int a5);
_DWORD *__cdecl sub_1001B580(int a1, int a2, int a3, int a4, int a5);
_DWORD *__cdecl sub_1001B5B0(int a1, int a2, int a3, int a4, int a5);
_DWORD *__cdecl sub_1001B5E0(int a1, int a2, int a3, int a4, int a5);
_DWORD *__cdecl sub_1001B610(int a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_1001B660(int a1, int a2);
// int __usercall sub_1001B670@<eax>(double a1@<st0>, _DWORD *a2);
// int __usercall sub_1001B6F0@<eax>(double a1@<st0>, int a2, int a3, int a4);
// BOOL __usercall sub_1001B810@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5);
BOOL __cdecl sub_1001B930(float a1, int a2, float *a3, int a4);
void *__cdecl sub_1001B980(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl sub_1001B9E0(int a1);
int __cdecl sub_1001BA00(int a1, int a2, int a3, int a4, int a5, int a6);
unsigned int __cdecl sub_1001BAE0(int a1, int a2, unsigned int a3);
unsigned int __cdecl sub_1001BB90(int a1, int a2, unsigned int a3);
int __cdecl sub_1001BBC0(int a1, int a2, int a3, int a4, unsigned int a5);
_DWORD *__cdecl sub_1001BDE0(int *a1, _DWORD *a2);
int __cdecl sub_1001BED0(int a1, int a2, unsigned int *a3, unsigned int a4);
unsigned int __cdecl sub_1001C380(int a1, unsigned int a2);
unsigned int __cdecl sub_1001C3B0(_DWORD *a1, unsigned int *a2, unsigned int a3, double a4, unsigned int *a5, int *a6);
unsigned int *__cdecl sub_1001C4E0(_DWORD *a1, unsigned int *a2, int a3, _BYTE *a4, unsigned int a5, unsigned int a6, unsigned int *a7, unsigned int *a8, int *a9, double *a10);
unsigned int __cdecl sub_1001C6D0(unsigned int a1, unsigned int a2);
unsigned int __cdecl sub_1001C6F0(_DWORD *a1, unsigned int *a2, unsigned int a3);
_DWORD **__cdecl sub_1001C9C0(_DWORD **a1, int a2, int a3);
unsigned int __cdecl sub_1001CA20(int a1, int a2, unsigned int a3);
int *__cdecl sub_1001CA70(int *a1, _DWORD *a2);
// int __usercall sub_1001CBE0@<eax>(int a1@<ebx>, unsigned int *a2, int *a3, _BYTE *a4);
_BYTE *__cdecl sub_1001CD30(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_1001CD80(int *a1, int a2, int a3);
// int __usercall sub_1001CE00@<eax>(int a1@<ebx>, _DWORD *a2, int a3);
int sub_1001CE50();
_DWORD *__cdecl sub_1001CE60(_DWORD *a1, unsigned int a2, unsigned int *a3);
unsigned int __cdecl sub_1001CED0(int a1, _DWORD *a2);
int __cdecl sub_1001D060(int a1, _DWORD *a2, int a3, int a4, int a5, _BYTE *a6);
// void __usercall sub_1001D220(int a1@<ebx>, char *a2);
void __cdecl sub_1001D240(float *a1, float *a2, float *a3, float *a4, float a5, int a6);
float *__cdecl sub_1001D5E0(float *a1, float *a2, float *a3);
double __cdecl sub_1001D620(float *a1);
float *__cdecl sub_1001D650(float *a1, float a2, float *a3);
float *__cdecl sub_1001D6D0(float *a1, float a2, float *a3);
float *__cdecl sub_1001D700(float *a1, float a2, float *a3, float *a4);
unsigned int *__cdecl sub_1001D790(int a1);
int __cdecl sub_1001D810(int a1);
void __cdecl sub_1001D830(unsigned int *a1, unsigned int a2, int a3);
_DWORD *__cdecl sub_1001D870(unsigned int *a1, unsigned int a2);
bool __cdecl sub_1001D8F0(unsigned int *a1, unsigned int a2, int a3);
char __cdecl sub_1001D940(unsigned int *a1, unsigned int a2, _DWORD *a3);
void *__cdecl sub_1001D970(int a1);
char *__cdecl sub_1001D990(int a1);
int __cdecl sub_1001D9B0(_WORD *a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5);
int __cdecl sub_1001DA40(int a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5);
int __cdecl sub_1001DAD0(_WORD *a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5);
int __cdecl sub_1001DE70(int a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5);
int __cdecl sub_1001DF20(_WORD *a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5, _DWORD *a6);
unsigned int __cdecl sub_1001E4B0(_DWORD *a1, unsigned __int16 *a2, unsigned int a3, unsigned int a4);
unsigned int __cdecl sub_1001E800(int *a1, int *a2, unsigned int a3, unsigned int a4);
unsigned int __cdecl sub_1001EC40(int *a1, unsigned __int8 *a2, unsigned int a3, unsigned int a4);
int sub_1001F1F0();
unsigned int __cdecl sub_1001F310(_WORD *a1, int a2, int a3);
unsigned int __cdecl sub_1001FC50(int a1, _DWORD *a2, unsigned int a3, _DWORD *a4, int a5);
unsigned int __cdecl sub_1001FE30(int a1, int a2, int a3);
unsigned int __cdecl sub_10020670(int a1, int a2, int a3);
_BYTE *__cdecl sub_10020F50(int a1, int a2, int a3, int a4, int a5, void *a6);
void __cdecl sub_10020FE0(int a1, char *a2, int a3, _DWORD *a4, int a5, int a6, char *a7);
char __cdecl sub_10021080(int a1, char *a2, int *a3);
int __cdecl sub_100210E0(int a1);
_DWORD *__cdecl sub_10021160(int a1, int a2);
int __cdecl sub_100211A0(int a1);
int __cdecl sub_100211C0(int a1, int *a2);
_DWORD *__cdecl sub_100211F0(int a1, int a2, int a3);
void __cdecl sub_10021280(int a1, int a2, _DWORD *a3, int a4, int a5);
void __cdecl sub_100213B0(_DWORD *a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7);
void __cdecl sub_10021430(int *a1, int a2, int a3);
_DWORD *__cdecl sub_100214A0(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl sub_100214C0(int a1);
BOOL __cdecl sub_100214E0(_DWORD *a1, _DWORD *a2);
_DWORD *__cdecl sub_10021540(_DWORD *a1);
int __cdecl sub_100215A0(_DWORD *a1, int a2);
_DWORD *__cdecl sub_100215D0(int a1, int a2);
char sub_10021620();
int nullsub_2(void); // weak
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);
char __cdecl sub_100216B0(HMODULE hModule);
int GrannyGetCounterCount();
char *__cdecl sub_100217B0(int a1);
double sub_100217C0();
_DWORD *__cdecl sub_100218A0(int a1);
void GrannyResetCounters();
// _DWORD *__usercall GrannyResetCounterPeaks@<eax>(_DWORD *result@<eax>);
void __cdecl sub_10021960(int a1, int a2);
int __cdecl sub_10021A00(_BYTE *a1);
BOOL __cdecl sub_10021A20(_BYTE *a1, _BYTE *a2);
BOOL __cdecl sub_10021A60(char *a1, char *a2);
BOOL __cdecl sub_10021AC0(char *a1, char *a2);
void __cdecl sub_10021B20(_BYTE *a1, int a2, _BYTE *a3);
int __cdecl sub_10021B90(_BYTE *a1, _BYTE *a2);
// int __usercall sub_10021BC0@<eax>(double a1@<st0>, char *a2);
int __cdecl sub_10021BF0(char *a1);
void __cdecl sub_10021C20(char *, char);
double __cdecl sub_10021C40(char *a1, char a2);
BOOL __cdecl sub_10021D60(char a1);
char __cdecl sub_10021D80(char a1);
char __cdecl sub_10021DA0(char a1);
int sub_10021DC0();
int sub_10021DE0();
int sub_10021E00();
int sub_10021E20();
int sub_10021E50();
int sub_10021E80();
int __cdecl sub_10021EA0(unsigned int a1, _BYTE *a2, char a3);
int __cdecl sub_10021EC0(unsigned int a1, _BYTE *a2, int a3, unsigned int a4, char *a5);
int __cdecl sub_10021F10(unsigned int a1, char *a2, unsigned int a3, unsigned int a4, char *a5);
// int __usercall sub_10021FA0@<eax>(char a1@<dil>, int a2, _BYTE *a3, double a4, double a5, int a6, char *a7);
unsigned int __cdecl sub_100222E0(unsigned int a1, int a2, char *a3, char **a4);
int __cdecl sub_10022670(int a1, int a2, int a3, char a4);
int __cdecl sub_100226A0(_DWORD *a1, int a2);
// int __usercall sub_100226C0@<eax>(int a1@<ebx>, int a2, int a3);
int __cdecl sub_10022770(int *a1);
int __cdecl sub_100227A0(int a1);
int __cdecl sub_100227D0(int a1, int *a2);
int __cdecl sub_10022820(int *a1, int a2);
char *__cdecl sub_100228D0(int a1, int a2);
int __cdecl sub_100228F0(int *a1, _BYTE *a2);
int __cdecl sub_10022990(int *a1, _BYTE *a2);
LARGE_INTEGER *__cdecl sub_10022A60(LARGE_INTEGER *a1);
double __cdecl sub_10022AA0(_QWORD *a1, _QWORD *a2);
void __cdecl sub_10022B20(float a1);
char *__cdecl sub_10022B50(int a1);
char *__cdecl sub_10022B70(int a1);
int __cdecl sub_10022B90(int a1, int a2, int a3, int a4);
int __cdecl sub_10022BA0(int a1, int a2, int a3);
char __cdecl sub_10022C00(_DWORD *a1, void *a2);
char __cdecl sub_10022C50(int *a1, int a2, int a3, unsigned int *a4, int a5, int a6, int a7, unsigned int *a8);
BOOL __cdecl sub_10022ED0(int a1);
_DWORD *__cdecl sub_10022EE0(int a1, int a2, const void *a3, int a4);
_DWORD *__cdecl sub_10022F20(int a1, int a2, int a3);
_DWORD *__cdecl sub_10022F70(int a1, int a2, int a3);
_DWORD *__cdecl sub_10022FC0(int a1, int a2);
_DWORD *__cdecl sub_10022FE0(int a1, int a2, int a3, char a4);
_DWORD *__cdecl sub_10023030(int *a1);
int __cdecl sub_10023060(int *a1);
int __cdecl sub_10023090(int *a1, int *a2, _DWORD *a3, _DWORD *a4);
_DWORD *__cdecl sub_100230E0(int *a1, int a2);
void __cdecl sub_10023270(int a1, int a2, int a3);
int __cdecl sub_100232B0(int a1, int a2, int a3, int a4, int a5, int a6);
BOOL __cdecl sub_100235C0(int a1);
void *__cdecl sub_100235D0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __cdecl sub_10023650(_DWORD *a1);
void __cdecl sub_10023720(_DWORD *a1);
int __cdecl sub_10023770(_DWORD *a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_10023810(int a1, int a2);
int *__cdecl sub_10023840(int *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, unsigned int a10, int a11, int a12, int *a13, int a14, unsigned int *a15);
signed int *__cdecl sub_100238A0(signed int *a1, int a2, signed int a3, int a4, int a5, int a6, int a7, int a8, int a9, signed int a10, unsigned int a11, unsigned int a12, int a13, signed int a14, _WORD *a15);
_DWORD *__cdecl sub_100239F0(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, unsigned __int8 *a13, int a14, unsigned int *a15);
_DWORD *__cdecl sub_10023A40(int a1, _DWORD *a2);
float *__cdecl sub_10023A50(float *a1, int a2, float *a3);
int __cdecl sub_10023A80(int a1, int a2, int a3);
float *__cdecl sub_10023AE0(int a1, int a2, int a3);
BOOL __cdecl sub_10023B90(_DWORD *a1, int *a2);
float *__cdecl sub_10023BD0(int a1);
float *__cdecl sub_10023C50(float *a1, float *a2, int a3, int a4, float *a5);
int __cdecl sub_10023C80(int a1, float *a2, float *a3, int a4, float *a5);
float *__cdecl sub_10023CC0(int a1, float *a2, float *a3, int a4, float *a5);
void __cdecl sub_10023CF0(int a1, float *a2, float *a3, float *a4);
char __cdecl sub_10023F10(int a1, int a2, int a3, int a4, int a5, int a6, float a7, _DWORD *a8, _DWORD *a9);
BOOL __cdecl sub_10024000(int a1);
// int __usercall sub_10024040@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6);
_DWORD *__cdecl sub_10024140(int *a1);
int __cdecl sub_10024170(int *a1);
int __cdecl sub_100241B0(int *a1, int *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5);
_DWORD *__cdecl sub_10024240(int *a1, int a2);
int __cdecl sub_10024420(int a1, _DWORD *a2, int *a3, int *a4);
void *__cdecl sub_100244C0(int a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6);
void *__cdecl sub_10024530(void *a1, int a2, int a3, int a4, _DWORD *a5, int a6, _DWORD *a7);
int __cdecl sub_10024590(int a1, int a2, _DWORD *a3);
int __cdecl sub_100245E0(int a1, int a2, _DWORD *a3);
int __cdecl sub_10024630(int a1, int a2);
void *__cdecl sub_10024650(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5);
void *__cdecl sub_100246B0(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5);
void *__cdecl sub_10024720(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5);
int __cdecl sub_10024780(int a1);
int __cdecl sub_10024790(int a1, int a2);
_DWORD *__cdecl sub_100247B0(int a1, int a2, int a3);
int __cdecl sub_10024820(int a1);
_DWORD *__cdecl sub_10024830(int a1, int a2);
int __cdecl sub_100248D0(int a1);
int __cdecl sub_100248F0(int a1, int a2);
int __cdecl sub_10024910(int a1, int a2);
int __cdecl sub_10024930(int a1, int a2);
_DWORD *__cdecl sub_10024950(int a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5);
int __cdecl sub_100249C0(int a1);
int __cdecl sub_100249D0(float a1, int a2); // idb
double __cdecl sub_10024A30(_DWORD *a1, int a2);
void __cdecl sub_10024A50(int a1, int a2, float a3);
int __cdecl sub_10024A90(int a1);
int __cdecl sub_10024AB0(int a1);
int __cdecl sub_10024B10(int a1);
int __cdecl sub_10024B40(_DWORD *a1);
int __cdecl sub_10024BC0(unsigned int *a1);
void __cdecl sub_10024BF0(int *a1, int a2, int a3);
void __cdecl sub_10024C50(int a1, unsigned int a2, _DWORD *a3, unsigned int a4, int *a5);
int __cdecl sub_10024D70(int a1);
_DWORD *__cdecl sub_10024D90(int a1);
BOOL __cdecl sub_10024DD0(int a1, _DWORD *a2, int a3);
int __cdecl sub_10024E60(int a1);
BOOL __cdecl sub_10024E70(int a1, int a2, _DWORD *a3, int a4, int *a5);
int sub_10024F60(int **a1, _BYTE *a2, ...);
int __cdecl sub_10024FC0(_DWORD *a1, int *a2, _BYTE *a3);
int sub_10025070(int **a1, _BYTE *a2, ...);
int __cdecl sub_100250D0(int **a1, _BYTE *a2, int a3, _BYTE *a4);
int __cdecl sub_10025140(int **a1, char *a2, _BYTE *a3);
int sub_100251B0(int **a1, _BYTE *a2, int a3, ...);
char *GrannyGetVersionString();
_DWORD *__cdecl sub_10025220(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
char __cdecl sub_10025250(int a1, int a2, int a3, int a4);
// int __usercall sub_100252A0@<eax>(double a1@<st0>, int a2, _DWORD *a3, int a4, _DWORD *a5, char *a6);
void __cdecl sub_10025300(_DWORD *a1, int a2);
// int __usercall sub_100255A0@<eax>(double a1@<st0>, int a2, _DWORD *a3, char *a4);
// int __usercall sub_10025690@<eax>(double a1@<st0>, int a2, _DWORD *a3, char *a4, float *a5, float *a6, float *a7);
int __cdecl sub_100258E0(int a1, int a2);
int __cdecl sub_10025900(int a1, int a2);
int __cdecl sub_10025920(int a1, int a2);
BOOL __cdecl sub_10025940(_BYTE *a1);
int __cdecl sub_100259D0(int a1);
int __cdecl sub_10025A20(_DWORD *a1);
// void __usercall sub_10025A50(double a1@<st0>, int *a2, int a3, _DWORD *a4, char *a5);
int __cdecl sub_10025B10(int a1);
int __cdecl sub_10025B40(int a1);
int __cdecl sub_10025B60(int a1);
int __cdecl sub_10025B80(int a1, int *a2);
int __cdecl sub_10025BC0(int a1, int a2);
int __cdecl sub_10025C40(_DWORD *a1, int a2);
int __cdecl sub_10025C60(_DWORD *a1, int a2);
int __cdecl sub_10025C80(int a1, int a2, int a3, int *a4, float *a5, int *a6);
HLOCAL __cdecl sub_10025F20(char a1, const char *a2, int a3, const char *a4);
DWORD __cdecl sub_10025FA0(HANDLE hFile, LONG lDistanceToMove, DWORD dwMoveMethod);
_DWORD *__stdcall GrannySetTransform(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
BOOL __stdcall GrannySetTransformWithIdentityCheck(int *a1, char *a2, char *a3, char *a4);
_DWORD *__stdcall GrannyMakeIdentity(_DWORD *a1);
_DWORD *__stdcall GrannyZeroTransform(_DWORD *a1);
void __stdcall GrannyGetTransformDeterminant(float *a1);
float *__stdcall GrannyTransformVectorInPlace(float *a1, int a2);
float *__stdcall GrannyTransformVectorInPlaceTransposed(float *a1, float *a2);
float *__stdcall GrannyTransformVector(float *a1, float *a2, float *a3);
float *__stdcall GrannyTransformPointInPlace(float *a1, float *a2);
float *__stdcall GrannyTransformPoint(float *a1, float *a2, float *a3);
int __stdcall GrannyPreMultiplyBy(void *a1, int a2);
int __stdcall GrannyPostMultiplyBy(void *a1, int a2);
int __stdcall GrannyMultiply(int a1, int a2, int a3);
BOOL __stdcall GrannyBuildInverse(int *a1, float *a2);
float *__stdcall GrannySimilarityTransform(float *a1, float *a2, float *a3, float *a4);
float *__stdcall GrannyBuildCompositeTransform(int a1, int a2, float *a3);
_DWORD *__stdcall GrannyBuildCompositeTransform4x4(int a1, _DWORD *a2);
int __stdcall GrannyGetMemberUnitSize(_DWORD *a1);
int __stdcall GrannyGetMemberTypeSize(int a1);
int __stdcall GrannyGetTotalObjectSize(_DWORD *a1);
int __stdcall GrannyGetTotalTypeSize(int *a1);
char *__stdcall GrannyGetMemberTypeName(int a1);
int __stdcall GrannyGetMemberCTypeName(int a1);
char __stdcall GrannyMemberHasPointers(int *a1);
char __stdcall GrannyTypeHasPointers(_DWORD *a1);
int __stdcall GrannyGetMemberMarshalling(int a1);
int __stdcall GrannyGetObjectMarshalling(_DWORD *a1);
BOOL __stdcall GrannyIsMixedMarshalling(int a1);
// int __userpurge GrannyMakeEmptyDataTypeMember@<eax>(int a1@<ebx>, int a2, char *a3);
int __stdcall GrannyMakeEmptyDataTypeObject(_DWORD *a1, int a2);
int __stdcall GrannyGetMemberArrayWidth(int a1);
int __stdcall GrannyGetTypeTableFor(_DWORD *a1);
int __stdcall GrannyGetTypeTableCount(_DWORD *a1);
int __stdcall GrannyReverseTypeArray(_DWORD *a1, int a2, unsigned int *a3);
_DWORD *__stdcall GrannyGetModelInitialPlacement4x4(int a1, _DWORD *a2);
int __stdcall GrannyGetMaterialTextureByType(int a1, char *a2);
int __stdcall GrannyModelControlsBegin(int a1);
int __stdcall GrannyModelControlsNext(int a1);
int __stdcall GrannyModelControlsEnd(int a1);
int __stdcall GrannyControlModelsBegin(int a1);
int __stdcall GrannyControlModelsEnd(int a1);
_DWORD *__stdcall GrannyInstantiateModel(int a1);
void __stdcall GrannyFreeModelInstance(unsigned int a1);
int __stdcall GrannyGetSourceSkeleton(int a1);
void __stdcall GrannySetModelClock(int a1, float a2);
char __stdcall GrannyFreeCompletedModelControls(int a1);
char __stdcall GrannyAccumulateModelAnimations(int a1, int a2, int a3, int a4);
int __stdcall GrannySampleModelAnimations(int a1, int a2, int a3, int *a4);
int __stdcall GrannyUpdateModelMatrix(int a1, int a2, float *a3, float *a4);
int __stdcall GrannyGetModelUserDataArray(int a1);
BOOL __stdcall GrannyCurveIsUncompressed(int a1);
BOOL __stdcall GrannyPixelLayoutsAreEqual(_DWORD *a1, _DWORD *a2);
BOOL __stdcall GrannyPixelLayoutHasAlpha(int a1);
int __stdcall GrannySetStockSpecification(int *a1, int a2, int a3);
int __stdcall GrannySetStockRGBASpecification(int *a1, int a2, int a3, int a4, int a5);
int __stdcall GrannySetStockBGRASpecification(int *a1, int a2, int a3, int a4, int a5);
int __stdcall GrannySwapRGBAToBGRA(_DWORD *a1);
unsigned int *__stdcall GrannyConvertPixelFormat(unsigned int a1, int a2, _DWORD *a3, int a4, int *a5, unsigned int *a6, int a7, unsigned int *a8);
char __stdcall GrannyFindTrackGroupForModel(int a1, char *a2, int *a3);
void __stdcall GrannyComputeBasisConversion(int a1, float a2, float *a3, float *a4, float *a5, float *a6, float *a7, float *a8, float *a9);
// int __userpurge GrannyTransformMesh@<eax>(double a1@<st0>, int a2, float *a3, float *a4, float *a5);
int __stdcall GrannyTransformSkeleton(int a1, float *a2, float *a3, float *a4);
// int __userpurge GrannyTransformModel@<eax>(double a1@<st0>, _DWORD *a2, float *a3, float *a4, float *a5);
int __stdcall GrannyTransformAnimation(int a1, float *a2, float *a3, float *a4);
// int __userpurge GrannyTransformFile@<eax>(double a1@<st0>, _DWORD *a2, float *a3, float *a4, float *a5);
_DWORD *__stdcall GrannySampleBSpline0x1(int a1, _DWORD *a2, int a3, _DWORD *a4);
int __stdcall GrannySampleBSpline0x3(int a1, _DWORD *a2, int a3, _DWORD *a4);
int __stdcall GrannySampleBSpline0x4(int a1, _DWORD *a2, int a3, _DWORD *a4);
int __stdcall GrannySampleBSpline0x9(int a1, _DWORD *a2, int a3, _DWORD *a4);
float *__stdcall GrannySampleBSpline1x1(float *a1, float *a2, float a3, float *a4);
float *__stdcall GrannySampleBSpline1x3(float *a1, float *a2, float a3, float *a4);
float *__stdcall GrannySampleBSpline1x4n(float *a1, float *a2, float a3, float *a4);
float *__stdcall GrannySampleBSpline1x9(float *a1, float *a2, float a3, float *a4);
float *__stdcall GrannySampleBSpline2x1(float *a1, float *a2, float a3, float *a4);
float *__stdcall GrannySampleBSpline2x3(float *a1, float *a2, float a3, float *a4);
float *__stdcall GrannySampleBSpline2x4n(float *a1, float *a2, float a3, float *a4);
float *__stdcall GrannySampleBSpline2x9(float *a1, float *a2, float a3, float *a4);
float *__stdcall GrannySampleBSpline3x1(float *a1, float *a2, float a3, float *a4);
float *__stdcall GrannySampleBSpline3x3(float *a1, float *a2, float a3, float *a4);
float *__stdcall GrannySampleBSpline3x4n(float *a1, float *a2, float a3, float *a4);
float *__stdcall GrannySampleBSpline3x9(float *a1, float *a2, float a3, float *a4);
void __stdcall GrannySampleBSpline(unsigned int a1, unsigned int a2, int a3, int a4, int a5, int a6);
int __stdcall GrannyFindKnot(int a1, int a2, float a3); // idb
int __stdcall GrannyFindCloseKnot(int a1, int a2, float a3, int a4); // idb
char __stdcall GrannyConstructBSplineBuffers(int a1, _DWORD *a2, _DWORD *a3, int a4, int a5, _DWORD *a6, int a7, _DWORD *a8, _DWORD *a9);
int __stdcall GrannyFitBSplineToSamples(float a1, int a2, char a3, int a4, _DWORD *a5, int a6, float a7, int a8, int a9);
int __stdcall GrannyInitializeDefaultCamera(int a1);
float *__stdcall GrannySetCameraAspectRatios(float *a1, float a2, float a3, float a4, float a5, float a6);
float *__stdcall GrannyMoveCameraRelative(float *a1, float a2, float a3, float a4);
int __stdcall GrannyBuildCameraMatrices(float *a1);
int __stdcall GrannyGetCameraLocation(_DWORD *a1, _DWORD *a2);
float *__stdcall GrannyGetCameraLeft(float *a1, float *a2);
int __stdcall GrannyGetCameraRight(_DWORD *a1, _DWORD *a2);
int __stdcall GrannyGetCameraUp(_DWORD *a1, _DWORD *a2);
float *__stdcall GrannyGetCameraDown(float *a1, float *a2);
float *__stdcall GrannyGetCameraForward(float *a1, float *a2);
int __stdcall GrannyGetCameraBack(_DWORD *a1, _DWORD *a2);
float *__stdcall GrannyWindowSpaceToWorldSpace(float *a1, float a2, float a3, float *a4, float *a5);
float *__stdcall GrannyWorldSpaceToWindowSpace(float *a1, float a2, float a3, float *a4, float *a5);
float *__stdcall GrannyGetPickingRay(float *a1, float a2, float a3, int a4, int a5, int a6, float *a7);
void __stdcall GrannyGetCameraRelativePlanarBases(_DWORD *a1, float a2, float *a3, float *a4, int a5, float *a6);
void __stdcall GrannyGetMostLikelyPhysicalAspectRatio(int a1, int a2);
void __stdcall GrannyFreeControl(unsigned int a1);
char __stdcall GrannyFreeControlOnceUnused(int a1);
int __stdcall GrannyCompleteControlAt(int a1, int a2);
void __stdcall GrannyGetControlClock(int a1);
void __stdcall GrannySetControlClock(int a1, float a2);
int __stdcall GrannySetControlClockOnly(int a1, float a2); // idb
BOOL __stdcall GrannyControlIsComplete(int a1);
char __stdcall GrannyFreeControlIfComplete(int a1);
void __stdcall GrannyGetControlWeight(int a1);
int __stdcall GrannySetControlWeight(int a1, float a2); // idb
int __stdcall GrannyGetControlLoopCount(int a1);
int __stdcall GrannySetControlLoopCount(int a1, int a2);
bool __stdcall GrannyGetControlLoopState(int a1, bool *a2, bool *a3);
int __stdcall GrannyGetControlLoopIndex(int a1);
int __stdcall GrannySetControlLoopIndex(int a1, int a2);
void __stdcall GrannyGetControlSpeed(int a1);
int __stdcall GrannySetControlSpeed(int a1, float a2); // idb
void __stdcall GrannyGetControlDuration(int a1);
void __stdcall GrannyGetControlDurationLeft(float a1);
char __stdcall GrannyControlIsActive(int a1);
char __stdcall GrannySetControlActive(int a1, char a2);
void __stdcall GrannyGetControlClampedLocalClock(int a1);
void __stdcall GrannyGetControlLocalDuration(int a1);
void __stdcall GrannyGetControlEaseCurveMultiplier(int a1);
void __stdcall GrannyGetControlEffectiveWeight(int a1);
char __stdcall GrannySetControlEaseIn(int a1, char a2);
int __stdcall GrannySetControlEaseInCurve(int a1, float a2, int a3, int a4, int a5, int a6, int a7); // idb
char __stdcall GrannySetControlEaseOut(int a1, char a2);
int __stdcall GrannySetControlEaseOutCurve(int a1, float a2, int a3, int a4, int a5, int a6, int a7); // idb
void __stdcall GrannyGetControlRawLocalClock(int a1);
int __stdcall GrannySetControlRawLocalClock(int a1, float a2); // idb
void __stdcall GrannyEaseControlIn(int a1, float a2, char a3);
void __stdcall GrannyEaseControlOut(int a1, int a2);
int __stdcall GrannyGetControlUserDataArray(int a1);
float *__stdcall GrannyRecenterAllControlClocks(float a1);
_DWORD *__stdcall GrannyPlayControlledAnimation(float a1, int a2, int a3);
int __stdcall GrannyBeginControlledAnimation(float a1, int a2); // idb
_DWORD *__stdcall GrannyEndControlledAnimation(int *a1);
void __stdcall GrannySetTrackGroupTarget(int a1, int a2, int a3);
void __stdcall GrannySetTrackGroupBasisTransform(int a1, int a2, int a3, int a4);
void __stdcall GrannySetTrackGroupTrackMask(int a1, int a2, int a3);
void __stdcall GrannySetTrackGroupModelMask(int a1, int a2, int a3);
void __stdcall GrannySetTrackGroupAccumulation(int a1, int a2, char a3);
_DWORD *__stdcall GrannyPlayControlledPose(int a1, int a2, int a3, int a4, int a5);
_DWORD *__stdcall GrannyBeginCRC32(_DWORD *a1);
unsigned int __stdcall GrannyAddToCRC32(int *a1, int a2, unsigned __int8 *a3);
int *__stdcall GrannyEndCRC32(int *a1);
int __stdcall GrannyFindMatchingMember(int a1, int a2, char *a3);
// char *__userpurge GrannyConvertSingleObject@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, char *a6);
// char *__userpurge GrannyMergeSingleObject@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, char *a6);
// int __userpurge GrannyConvertTree@<eax>(double a1@<st0>, int a2, unsigned int a3, int *a4);
// int __userpurge GrannyGetConvertedTreeSize@<eax>(double a1@<st0>, int a2, unsigned int a3, int *a4);
// char *__userpurge GrannyConvertTreeInPlace@<eax>(double a1@<st0>, int a2, unsigned int a3, int *a4, int a5);
int __stdcall GrannyBeginFileDataTreeWriting(int a1, int a2, int a3);
int __stdcall GrannyEndFileDataTreeWriting(int a1);
int __stdcall GrannySetFileDataTreeFlags(int a1, int a2);
int __stdcall GrannySetFileSectionForObjectsOfType(int a1, unsigned int a2, int a3);
int __stdcall GrannySetFileSectionForObject(int a1, unsigned int a2, int a3);
char __stdcall GrannyWriteDataTreeToFileBuilder(int a1, _DWORD *a2);
char __stdcall GrannyWriteDataTreeToFile(int a1, int a2, const CHAR *a3, int a4);
int __stdcall GrannyClipTransformDOFs(int a1, __int16 a2);
bool __stdcall GrannyFileCRCIsValid(const CHAR *a1);
int __stdcall GrannyReadEntireFile(const CHAR *a1);
int __stdcall GrannyReadEntireFileFromMemory(int a1, int a2);
int __stdcall GrannyReadEntireFileFromReader(int a1);
// int __userpurge GrannyReadPartialFileFromReader@<eax>(int a1@<ebx>, int a2);
void __stdcall GrannyFreeFileSection(_DWORD *a1, int a2);
int __stdcall GrannyFreeAllFileSections(_DWORD *a1);
int __stdcall GrannyReadFileSection(int a1, int a2, int a3);
int __stdcall GrannyFixupFileSection(int a1, int a2, int a3);
int __stdcall GrannyFreeFile(_DWORD *a1);
int __stdcall GrannyGetDataTreeFromFile(int a1);
int __stdcall GrannyGetFileTypeTag(int a1);
// _DWORD *__userpurge GrannyBeginFile@<eax>(int a1@<ebx>, int a2, int a3, _BYTE *a4, _BYTE *a5);
char __stdcall GrannyEndFile(int a1, const CHAR *a2);
char __stdcall GrannyEndFileToWriter(int a1, HANDLE *a2);
int __stdcall GrannyAbortFile(int a1);
void __stdcall GrannySetFileSectionFormat(int a1, int a2, int a3, int a4);
int *__stdcall GrannyWriteFileChunk(int *a1, int a2, int a3, int a4, DWORD a5, unsigned __int8 *a6);
_DWORD *__stdcall GrannyOffsetFileLocation(_DWORD *a1, int a2, _DWORD *a3, int a4);
_DWORD *__stdcall GrannyMarkFileFixup(_DWORD *a1, unsigned int *a2, int a3, unsigned int *a4);
_DWORD *__stdcall GrannyAdjustFileFixup(int a1, _DWORD *a2, _DWORD *a3);
void __stdcall GrannyMarkMarshallingFixup(_DWORD *a1, unsigned int *a2, unsigned int *a3, int a4);
_DWORD *__stdcall GrannyMarkFileRootObject(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __stdcall GrannyGetCompressedBytesPaddingSize(int a1);
char __stdcall GrannyDecompressData(int a1, int a2, _BYTE *a3, int a4, int a5, int a6, _BYTE *a7);
// _DWORD *__userpurge GrannyBeginFileCompression@<eax>(int a1@<ebx>, int a2, int a3, int a4, int a5);
bool __stdcall GrannyCompressContentsOfFile(_DWORD *a1, unsigned int a2, const CHAR *a3, int a4, unsigned __int8 *a5);
char __stdcall GrannyEndFileCompression(_DWORD *a1, DWORD *a2);
char __stdcall GrannyIsGrannyFile(int a1, unsigned int *a2, _BYTE *a3);
int __stdcall GrannyGetGRNSectionArray(int a1);
int __stdcall GrannyReverseSection(int a1, int a2, int a3, unsigned int *a4);
_DWORD *__stdcall GrannyGRNFixUp(_DWORD *a1, _DWORD *a2, int a3, int a4);
int __stdcall GrannyGRNMarshall(int a1, int *a2, int a3, int a4);
int __stdcall GrannyDecodeGRNReference(int a1, _DWORD *a2);
// unsigned int __userpurge GrannyGetFileInfo@<eax>(double a1@<st0>, int a2);
_DWORD *__stdcall GrannyInitializeFileReader(int a1, int a2, int a3, int a4, _DWORD *a5);
int __stdcall GrannyUnlinkFileReader(int a1);
_DWORD *__stdcall GrannyCreatePlatformFileReader(int a1, int a2, LPCSTR lpFileName);
int (__cdecl *__stdcall GrannySetDefaultFileReaderOpenCallback(int (__cdecl *a1)(int, int, LPCSTR lpFileName)))(int, int, LPCSTR lpFileName);
int __stdcall GrannyNewFileWriter(LPCSTR lpFileName, char a2); // idb
void __stdcall GrannyDeleteFileWriter(HANDLE *a1);
DWORD __stdcall GrannyGetWriterPosition(HANDLE *a1);
DWORD __stdcall GrannySeekWriterFromStart(HANDLE *a1, LONG a2);
DWORD __stdcall GrannySeekWriterFromEnd(HANDLE *a1, LONG a2);
DWORD __stdcall GrannySeekWriterFromCurrentPosition(HANDLE *a1, LONG a2);
char __stdcall GrannyWrite(DWORD NumberOfBytesWritten, DWORD nNumberOfBytesToWrite, unsigned __int8 *lpBuffer);
_DWORD *__stdcall GrannyBeginWriterCRC(int a1);
char __stdcall GrannyWriterIsCRCing(int a1);
int __stdcall GrannyEndWriterCRC(int a1);
int __stdcall GrannyAlignWriter(HANDLE *a1);
int __stdcall GrannyPredictWriterAlignment(int a1);
void __stdcall GrannyGetGrannyHeadWidthOverHeight();
char *__stdcall GrannyGetGrannyHeadBezier(int a1);
// unsigned int __userpurge GrannyGetIGCInfo@<eax>(double a1@<st0>, int a2);
unsigned int *__stdcall GrannyDecompressIGCTexture(int a1, int a2, unsigned int *a3);
int __stdcall GrannyIKUpdate(int a1, int a2, float *a3, int a4, int a5, float *a6, int *a7, int *a8);
void __stdcall GrannyScaleImage(float a1, unsigned int a2, unsigned int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __stdcall GrannyRayIntersectsPlaneAt(float *a1, float a2, float *a3, float *a4, float *a5);
BOOL __stdcall GrannyRayIntersectsSphere(int a1, float a2, int a3, int a4);
BOOL __stdcall GrannyRayIntersectsSphereAt(float *a1, float a2, float *a3, float *a4, float *a5, float *a6);
BOOL __stdcall GrannyRayIntersectsBox(float *a1, float *a2, int a3, float *a4, float *a5);
BOOL __stdcall GrannyRayIntersectsBoxAt(int a1, float *a2, int a3, float *a4, float *a5, int a6);
int __stdcall GrannyRayIntersectsTriangleAt(float *a1, float *a2, float *a3, float *a4, float *a5, int a6);
// int __userpurge GrannyNewLocalPose@<eax>(int a1@<ebx>, int a2);
int __stdcall GrannyFreeLocalPose(int a1);
int __stdcall GrannyGetResultingLocalPoseSize(int a1);
// int __userpurge GrannyNewLocalPoseInPlace@<eax>(int a1@<ebx>, int a2, int a3);
int __stdcall GrannyGetLocalPoseTransform(int *a1, int a2);
int __stdcall GrannyBeginLocalPoseAccumulation(int a1, int a2, int a3);
int __stdcall GrannyAccumulateLocalTransform(int a1, int a2, float a3, float *a4);
void __stdcall GrannyEndLocalPoseAccumulation(int *a1, int a2, int a3, int a4, int a5);
void __stdcall GrannyGetLocalPoseFillThreshold(int a1);
void __stdcall GrannyGetWorldMatrixFromLocalPose(int a1, int a2, int *a3, float *a4, int a5);
int __stdcall GrannyGetAttachmentOffset(int a1, int *a2, int *a3, float *a4, int a5);
char __stdcall GrannySetLogFileName(CHAR *lpFileName, char a2);
__int64 *__stdcall GrannySetLogCallback(__int64 *a1);
bool __stdcall GrannyFilterMessage(int a1, char a2);
__int16 __fastcall GrannyFilterAllMessages(int a1, int a2, char a3);
int __stdcall GrannyEnsureQuaternionContinuity(int a1, float *a2);
char __stdcall GrannyPolarDecompose(int a1, float a2, int a3, int a4);
int __stdcall GrannyColumnMatrixMultiply4x3(int a1, float *a2, float *a3);
float *__stdcall GrannyColumnMatrixMultiply4x4(float *a1, float *a2, float *a3);
float *__stdcall GrannyMatrixEqualsQuaternion3x3(float *a1, float *a2);
int __stdcall GrannyQuaternionEqualsMatrix3x3(float *a1, float *a2);
float *__stdcall GrannyInPlaceSimilarityTransformPosition(float *a1, float *a2, float *a3);
int __stdcall GrannyInPlaceSimilarityTransformOrientation(float *a1, float *a2, float *a3);
float *__stdcall GrannyInPlaceSimilarityTransformScaleShear(float *a1, float *a2, float *a3);
float *__stdcall GrannyInPlaceSimilarityTransform(float *a1, float *a2, float *a3, float *a4, float *a5, float *a6);
int __stdcall GrannyInPlaceSimilarityTransform4x3(float *a1, float *a2, float *a3, float *a4);
int __stdcall GrannyNextAllocation(int a1);
int __stdcall GrannyGetAllocationInformation(_DWORD *a1, int *a2);
int __stdcall GrannyCheckedAllocationsEnd(int a1);
bool __stdcall GrannyEndAllocationCheck(int a1);
int (__cdecl *__stdcall GrannyGetAllocator(_DWORD *a1, _DWORD *a2))(int, int, int);
int (__cdecl *__stdcall GrannySetAllocator(int (__cdecl *a1)(int, int, int, int), int (__cdecl *a2)(int, int, int)))(int, int, int, int);
int __stdcall GrannyFreeBuilderResult(int a1);
int __stdcall GrannyClearArena(_DWORD **a1);
int __stdcall GrannyFreeMemoryArena(_DWORD *a1);
int __stdcall GrannyMemoryArenaPush(_DWORD *a1, int a2);
_DWORD *__stdcall GrannyCreateMemoryFileReader(int a1, int a2, int a3, int a4, int a5);
int __stdcall GrannyGetMeshTriangleGroupCount(int a1);
int __stdcall GrannyGetMeshTriangleGroups(int a1);
int __stdcall GrannyGetMeshVertexType(int a1);
int __stdcall GrannyGetMeshVertexCount(int a1);
// void __userpurge GrannyCopyMeshVertices(double a1@<st0>, const char **a2, _DWORD *a3, char *a4);
int __stdcall GrannyGetMeshVertices(int a1);
BOOL __stdcall GrannyMeshIsRigid(int a1);
int __stdcall GrannyGetMeshIndexCount(int a1);
int __stdcall GrannyGetMeshBytesPerIndex(int a1);
int __stdcall GrannyGetMeshIndices(int a1);
void __stdcall GrannyCopyMeshIndices(const char **a1, unsigned int a2, int *a3);
int __stdcall GrannyTransformBoundingBox(float *a1, float *a2, int a3, float *a4);
int __stdcall GrannyNewMeshBinding(int a1, int a2, int a3);
int __stdcall GrannyFreeMeshBinding(int a1);
int __stdcall GrannyGetResultingMeshBindingSize(int a1, int a2, int a3);
int __stdcall GrannyNewMeshBindingInPlace(int a1, int a2, int a3, int a4);
bool __stdcall GrannyMeshBindingIsTransferred(int a1);
int __stdcall GrannyGetMeshBinding4x4ArraySize(int a1, int a2);
void __stdcall GrannyBuildMeshBinding4x4Array(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5);
int __stdcall GrannyGetWorldPose4x4Array(int a1);
int __stdcall GrannyGetModelInstanceFromBinding(int a1);
int __stdcall GrannyBeginMesh(int a1, int a2, unsigned int a3, int a4, int a5);
BOOL __stdcall GrannyEndMesh(int a1, int *a2, int *a3);
int __stdcall GrannyGetResultingVertexCount(int a1);
int __stdcall GrannyGetResultingCoincidentVertexMap(int a1);
int __stdcall GrannyGetResultingVertexToTriangleMap(int a1);
int __stdcall GrannyGetResultingVertexDataSize(int a1);
int __stdcall GrannyGetResultingTopologySize(_DWORD *a1);
void __stdcall GrannyEndMeshInPlace(int a1, int a2, int *a3, int a4, int *a5);
float *__stdcall GrannySetNormalTolerance(float *a1, float a2);
int __stdcall GrannySetTangentTolerance(int a1, float a2); // idb
int __stdcall GrannySetLocalPoseFillThreshold(int a1, float a2); // idb
int __stdcall GrannySetTangentBinormalCrossTolerance(int a1, float a2); // idb
int __stdcall GrannySetChannelTolerance(int a1, int a2, float a3); // idb
_DWORD *__stdcall GrannySetPosition(_DWORD *a1, int a2, int a3, int a4);
float *__stdcall GrannyAddWeight(int a1, int a2, float a3);
// int __userpurge GrannyPushVertex@<eax>(int a1@<ebx>, double a2@<st0>, int *a3);
int __stdcall GrannySetVertexIndex(int a1, int a2, int a3);
_DWORD *__stdcall GrannySetNormal(int a1, int a2, int a3, int a4, int a5);
_DWORD *__stdcall GrannySetTangent(int a1, int a2, int a3, int a4, int a5);
_DWORD *__stdcall GrannySetBinormal(int a1, int a2, int a3, int a4, int a5);
_DWORD *__stdcall GrannySetTangentBinormalCross(int a1, int a2, int a3, int a4, int a5);
_DWORD *__stdcall GrannySetChannel(int a1, int a2, int a3, _DWORD *a4);
int __stdcall GrannySetMaterial(int a1, int a2);
// int __userpurge GrannyPushTriangle@<eax>(double a1@<st0>, _DWORD *a2);
void *__stdcall GrannyNewMeshDeformer(_DWORD *a1, _DWORD *a2, int a3);
int __stdcall GrannyFreeMeshDeformer(int a1);
int __stdcall GrannyDeformVertices(int a1, int a2, int a3, int a4, int a5, int a6);
// void __userpurge GrannyZeroPeriodicLoop(int a1@<ebx>, char *a2);
void __stdcall GrannyFitPeriodicLoop(float *a1, float *a2, float *a3, float *a4, float a5, int a6);
float *__stdcall GrannyComputePeriodicLoopVector(float *a1, float a2, float *a3);
float *__stdcall GrannyComputePeriodicLoopLog(float *a1, float a2, float *a3);
float *__stdcall GrannyStepPeriodicLoop(float *a1, float a2, float *a3, float *a4);
void *__stdcall GrannyGetS3TCPixelLayout(int a1);
char *__stdcall GrannyGetS3TCTextureFormatName(int a1);
_BYTE *__stdcall GrannyBuildSkeletonRelativeTransform(int a1, int a2, int a3, int a4, int a5, void *a6);
void __stdcall GrannyBuildSkeletonRelativeTransforms(int a1, char *a2, int a3, _DWORD *a4, int a5, int a6, char *a7);
char __stdcall GrannyFindBoneByName(int a1, char *a2, int *a3);
int __stdcall GrannyBeginSkeleton(int a1);
_DWORD *__stdcall GrannyEndSkeleton(int a1, int a2);
int __stdcall GrannyGetResultingSkeletonSize(int a1);
_DWORD *__stdcall GrannyEndSkeletonInPlace(int a1, int a2, int a3);
void __stdcall GrannyAddBone(_DWORD *a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7);
void __stdcall GrannySetBoneParent(int *a1, int a2, int a3);
void __stdcall GrannyGetCounterResults(int a1, int a2);
// int __userpurge GrannyBeginStringTable@<eax>(int a1@<ebx>, int a2, int a3);
int __stdcall GrannyEndStringTable(int *a1);
int __stdcall GrannyGetResultingStringTableSize(int a1);
int __stdcall GrannyEndStringTableInPlace(int *a1, int a2);
char *__stdcall GrannyGetMappedString(int a1, int a2);
int __stdcall GrannyMapString(int *a1, _BYTE *a2);
DWORD *__stdcall GrannyGetSystemSeconds(DWORD *a1);
void __stdcall GrannyGetSecondsElapsed(_QWORD *a1, _QWORD *a2);
void __stdcall GrannySleepForSeconds(float a1);
char *__stdcall GrannyGetTextureTypeName(int a1);
char *__stdcall GrannyGetTextureEncodingName(int a1);
int __stdcall GrannyGetRawImageSize(int a1, int a2, int a3, int a4);
int __stdcall GrannyGetS3TCImageSize(int a1, int a2, int a3);
char __stdcall GrannyGetRecommendedPixelLayout(_DWORD *a1, void *a2);
char __stdcall GrannyCopyTextureImage(int *a1, int a2, int a3, unsigned int *a4, int a5, int a6, int a7, unsigned int *a8);
BOOL __stdcall GrannyTextureHasAlpha(int a1);
_DWORD *__stdcall GrannyBeginRawTexture(int a1, int a2, const void *a3, int a4);
_DWORD *__stdcall GrannyBeginS3TCTexture(int a1, int a2, int a3);
_DWORD *__stdcall GrannyBeginBestMatchS3TCTexture(int a1, int a2);
_DWORD *__stdcall GrannyBeginBinkTexture(int a1, int a2, int a3, char a4);
_DWORD *__stdcall GrannyEndTexture(int *a1);
int __stdcall GrannyGetResultingTextureSize(int *a1);
_DWORD *__stdcall GrannyEndTextureInPlace(int *a1, int a2);
void __stdcall GrannySetImageScalingFilter(int a1, int a2, int a3);
int __stdcall GrannyEncodeImage(int a1, int a2, int a3, int a4, int a5, int a6);
_DWORD *__stdcall GrannyGetTrackGroupInitialPlacement4x4(int a1, _DWORD *a2);
float *__stdcall GrannyTransformCurve3(float *a1, int a2, float *a3);
int __stdcall GrannyTransformCurve4(int a1, int a2, int a3);
float *__stdcall GrannyTransformCurve3x3(int a1, int a2, int a3);
BOOL __stdcall GrannyGetTrackInitialTransform(_DWORD *a1, int *a2);
float *__stdcall GrannyRemoveTrackInitialTransform(int a1);
float *__stdcall GrannySimilarityTransformCurve3(float *a1, float *a2, int a3, int a4, float *a5);
int __stdcall GrannySimilarityTransformCurve4(int a1, float *a2, float *a3, int a4, float *a5);
float *__stdcall GrannySimilarityTransformCurve3x3(int a1, float *a2, float *a3, int a4, float *a5);
void __stdcall GrannySimilarityTransformTrackGroup(int a1, float *a2, float *a3, float *a4);
char __stdcall GrannyKnotsAreReducible(int a1, int a2, int a3, int a4, int a5, int a6, float a7, _DWORD *a8, _DWORD *a9);
BOOL __stdcall GrannyTransformTrackHasUncompressedCurves(int a1);
// int __userpurge GrannyBeginTrackGroup@<eax>(int a1@<ebx>, int a2, int a3, int a4, int a5);
_DWORD *__stdcall GrannyEndTrackGroup(int *a1);
int __stdcall GrannyGetResultingTrackGroupSize(int *a1);
_DWORD *__stdcall GrannyEndTrackGroupInPlace(int *a1, int a2);
void *__stdcall GrannyPushScalarTrack(int a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6);
int __stdcall GrannySetTransformTrackName(int a1, int a2);
void *__stdcall GrannySetTransformTrackPosition(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5);
void *__stdcall GrannySetTransformTrackOrientation(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5);
void *__stdcall GrannySetTransformTrackScaleShear(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5);
int __stdcall GrannyPushTransformTrack(int a1);
int __stdcall GrannySetTextTrackName(int a1, int a2);
_DWORD *__stdcall GrannyAddTextEntry(int a1, int a2, int a3);
int __stdcall GrannyPushTextTrack(int a1);
_DWORD *__stdcall GrannyBeginSampledAnimation(int a1, int a2);
int __stdcall GrannyEndSampledAnimation(int a1);
int __stdcall GrannyGetPositionSamples(int a1, int a2);
int __stdcall GrannyGetOrientationSamples(int a1, int a2);
int __stdcall GrannyGetScaleShearSamples(int a1, int a2);
_DWORD *__stdcall GrannySetTransformSample(int a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5);
int __stdcall GrannyPushSampledFrame(int a1);
int __stdcall GrannyNewTrackMask(float a1, int a2); // idb
void __stdcall GrannyGetTrackMaskBoneWeight(_DWORD *a1, int a2);
void __stdcall GrannySetTrackMaskBoneWeight(int a1, int a2, float a3);
int __stdcall GrannyFreeTrackMask(int a1);
int __stdcall GrannyCopyTrackMask(int a1);
int __stdcall GrannyInvertTrackMask(int a1);
int __stdcall GrannyInvertTriTopologyWinding(_DWORD *a1);
void __stdcall GrannyRemapTopologyMaterials(int *a1, int a2, int a3);
void __stdcall GrannyConvertIndices(int a1, unsigned int a2, _DWORD *a3, unsigned int a4, int *a5);
_DWORD *__stdcall GrannyBeginVariant(int a1);
BOOL __stdcall GrannyEndVariant(int a1, _DWORD *a2, int a3);
int __stdcall GrannyGetResultingVariantTypeSize(int a1);
int __stdcall GrannyGetWorldPoseComposite4x4Array(int a1);
BOOL __stdcall GrannyEndVariantInPlace(int a1, int a2, _DWORD *a3, int a4, int *a5);
int __stdcall GrannyAddScalarMember(int **a1, _BYTE *a2, int a3);
int __stdcall GrannyAddIntegerMember(int **a1, _BYTE *a2, int a3);
int __stdcall GrannyAddScalarArrayMember(int **a1, _BYTE *a2, int a3, _BYTE *a4);
int __stdcall GrannyAddStringMember(int **a1, char *a2, _BYTE *a3);
int __stdcall GrannyAddReferenceMember(int **a1, _BYTE *a2, int a3, int a4);
_DWORD *__stdcall GrannyGetVersion(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
char __stdcall GrannyVersionsMatch_(int a1, int a2, int a3, int a4);
// int __userpurge GrannyConvertVertexLayouts@<eax>(double a1@<st0>, int a2, _DWORD *a3, int a4, _DWORD *a5, char *a6);
void __stdcall GrannyEnsureExactOneNorm(_DWORD *a1, int a2);
// int __userpurge GrannyOneNormalizeWeights@<eax>(double a1@<st0>, int a2, _DWORD *a3, char *a4);
// int __userpurge GrannyTransformVertices@<eax>(double a1@<st0>, int a2, _DWORD *a3, char *a4, float *a5, float *a6, float *a7);
int __stdcall GrannyGetVertexTextureCoordinatesName(int a1, int a2);
int __stdcall GrannyGetVertexDiffuseColorName(int a1, int a2);
int __stdcall GrannyGetVertexSpecularColorName(int a1, int a2);
BOOL __stdcall GrannyIsSpatialVertexMember(_BYTE *a1);
int __stdcall GrannyGetVertexBoneCount(int a1);
int __stdcall GrannyGetVertexChannelCount(_DWORD *a1);
// void __userpurge GrannyGetSingleVertex(double a1@<st0>, int *a2, int a3, _DWORD *a4, char *a5);
int __stdcall GrannyNewWorldPose(int a1);
int __stdcall GrannyFreeWorldPose(int a1);
int __stdcall GrannyGetWorldPoseBoneCount(int a1);
int __stdcall GrannyGetResultingWorldPoseSize(int a1);
int __stdcall GrannyNewWorldPoseInPlace(int a1, int a2);
int __stdcall GrannyGetWorldPose4x4(_DWORD *a1, int a2);
int __stdcall GrannyGetWorldPoseComposite4x4(_DWORD *a1, int a2);
int __stdcall GrannyBuildWorldPose(int a1, int a2, int a3, int *a4, float *a5, int *a6);

//-------------------------------------------------------------------------
// Data declarations

char byte_100148D0[2] = { '\x8A', '\r' }; // weak
char byte_100149A0[2] = { '\x8A', '\r' }; // weak
// extern UINT (__stdcall *GetSystemDirectoryA)(LPSTR lpBuffer, UINT uSize);
// extern BOOL (__stdcall *DeleteFileA)(LPCSTR lpFileName);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern BOOL (__stdcall *DisableThreadLibraryCalls)(HMODULE hLibModule);
// extern UINT (__stdcall *GetWindowsDirectoryA)(LPSTR lpBuffer, UINT uSize);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern BOOL (__stdcall *QueryPerformanceFrequency)(LARGE_INTEGER *lpFrequency);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern DWORD (__stdcall *FormatMessageA)(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// extern DWORD (__stdcall *GetLastError)();
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
_UNKNOWN unk_1002A07C; // weak
int dword_1002A08C = 0; // weak
_UNKNOWN unk_1002A09C; // weak
_UNKNOWN unk_1002A0D0; // weak
float flt_1002A170 = 1.0; // weak
_UNKNOWN unk_1002A204; // weak
int dword_1002A228 = 4; // weak
_UNKNOWN unk_1002A270; // weak
_UNKNOWN unk_1002A294; // weak
_DWORD dword_1002A300[12] = { 4, 16, 8, 0, 24, 8, 8, 8, 8, 0, 0, 0 }; // weak
int dword_1002A3A8[6] = { 0, 1, 3, 7, 15, 31 }; // weak
char byte_1002A430[132] =
{
  '\0',
  '\x01',
  '\x02',
  '\x02',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\b',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_1002A4B4[16] =
{
  '\0',
  '\b',
  '\x04',
  '\f',
  '\x02',
  '\n',
  '\x06',
  '\x0E',
  '\x01',
  '\t',
  '\x05',
  '\r',
  '\x03',
  '\v',
  '\a',
  '\x0F'
}; // weak
char byte_1002A4C4[12] =
{
  '\0',
  '\x04',
  '\x02',
  '\x06',
  '\x01',
  '\x05',
  '\x03',
  '\a',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
_UNKNOWN unk_1002A50C; // weak
_UNKNOWN unk_1002A52C; // weak
float flt_1002A650[4] = { 0.0, 0.0, 0.0, 0.0 }; // weak
_UNKNOWN unk_1002A660; // weak
_UNKNOWN unk_1002A670; // weak
char *off_100301C0 = "EndMember"; // weak
int dword_100301C4[] = { 0 }; // weak
_UNKNOWN *off_100301C8 = &byte_100360A8; // weak
int dword_100301CC[] = { 0 }; // weak
char aSwitchabletype[52] = "SwitchableTypeMember comparison not yet implemented"; // weak
char aWPublicGrannyR_6[53] = "w:/public/granny/rt/granny_model_control_binding.cpp"; // weak
char a4[2] = "4"; // weak
char aSamplemodelani[22] = "SampleModelAnimations"; // weak
int dword_10030A78[] = { 0 }; // weak
char aWPublicGrannyR[61] = "w:/public/granny/rt/x86/x86_granny_accelerated_deformers.cpp"; // weak
char aMatrixbuffer4x[17] = "MatrixBuffer4x4 "; // weak
char aDestvertices[14] = "DestVertices "; // weak
char aSourcevertices[16] = "SourceVertices "; // weak
int dword_10030D68[4] = { 0, 0, 0, 0 }; // weak
char aWPublicGrannyR_7[48] = "w:/public/granny/rt/granny_basis_conversion.cpp"; // weak
unsigned int dword_10030E58[4] = { 128u, 256u, 512u, 1024u }; // weak
unsigned int dword_10030E68[4] = { 512u, 1024u, 2048u, 3072u }; // weak
char aWPublicGrannyR_0[36] = "w:/public/granny/rt/granny_bink.cpp"; // weak
int dword_10030EA0[] = { 0 }; // weak
char aWPublicGrannyR_8[39] = "w:/public/granny/rt/granny_bspline.cpp"; // weak
char aWPublicGrannyR_9[43] = "w:/public/granny/rt/granny_bspline_fit.cpp"; // weak
_DWORD dword_1003102C[7] = { 152, 0, 0, 0, 0, 0, 0 }; // weak
int (__cdecl *off_10031048)(int, int, int, int) = &sub_1000F990; // weak
char aWPublicGrannyR_10[52] = "w:/public/granny/rt/granny_controlled_animation.cpp"; // weak
_UNKNOWN *off_100311BC = &loc_10010410; // weak
char aWPublicGrannyR_11[47] = "w:/public/granny/rt/granny_controlled_pose.cpp"; // weak
int dword_10031200[256] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117
}; // weak
char aWPublicGrannyR_12[52] = "w:/public/granny/rt/granny_data_type_conversion.cpp"; // weak
char aWPublicGrannyR_15[44] = "w:/public/granny/rt/granny_data_type_io.cpp"; // weak
char aGrannyfilestri[23] = "_GrannyFileStringTable"; // weak
char asc_10031764[2] = "."; // weak
char aWritedatatreet[20] = "WriteDataTreeToFile"; // weak
char aWPublicGrannyR_36[41] = "w:/public/granny/rt/granny_deformers.cpp"; // weak
char aWPublicGrannyR_23[36] = "w:/public/granny/rt/granny_file.cpp"; // weak
char aReadfilesectio[16] = "ReadFileSection"; // weak
char aFixupfilesecti[17] = "FixupFileSection"; // weak
char aReadentirefile[15] = "ReadEntireFile"; // weak
char aReadentirefile_0[25] = "ReadEntireFileFromReader"; // weak
char aWPublicGrannyR_16[44] = "w:/public/granny/rt/granny_file_builder.cpp"; // weak
char aSSDDUtf[16] = "%s/%s_%d_%d.utf"; // weak
char aSSDCtf[13] = "%s/%s_%d.ctf"; // weak
char aWPublicGrannyR_19[47] = "w:/public/granny/rt/granny_file_compressor.cpp"; // weak
char aDecompressdata[15] = "DecompressData"; // weak
int dword_10031D48 = 2; // weak
char aWPublicGrannyR_26[41] = "w:/public/granny/rt/granny_file_info.cpp"; // weak
char aWPublicGrannyR_20[47] = "w:/public/granny/rt/granny_file_operations.cpp"; // weak
int (__cdecl *off_10032074)(int, int, LPCSTR lpFileName) = &sub_100147C0; // weak
char aCreatefile[11] = "CreateFile"; // weak
char aWPublicGrannyR_21[55] = "w:/public/granny/rt/win32/win32_granny_file_reader.cpp"; // weak
char aCreateplatform[25] = "CreatePlatformFileReader"; // weak
char aClosehandle[12] = "CloseHandle"; // weak
char aWPublicGrannyR_2[55] = "w:/public/granny/rt/win32/win32_granny_file_writer.cpp"; // weak
char aWritefile[10] = "WriteFile"; // weak
char aWPublicGrannyR_5[47] = "w:/public/granny/rt/granny_fixed_allocator.cpp"; // weak
_UNKNOWN unk_10032218; // weak
char aNormal[7] = "Normal"; // weak
char aPosition[9] = "Position"; // weak
int dword_100330E0 = 3; // weak
char aWPublicGrannyR_27[40] = "w:/public/granny/rt/granny_igc_info.cpp"; // weak
float flt_1003338C[3] = { 2.0, 1.0, 0.5 }; // weak
int off_10033398 = 268527152; // idb
char aWPublicGrannyR_29[48] = "w:/public/granny/rt/granny_image_operations.cpp"; // weak
char aWPublicGrannyR_1[42] = "w:/public/granny/rt/granny_local_pose.cpp"; // weak
char byte_10033588 = '\x01'; // weak
unsigned __int8 byte_1003358C[4] = { 10u, 0u, 0u, 0u }; // weak
char aWPublicGrannyR_13[47] = "w:/public/granny/rt/granny_member_iterator.cpp"; // weak
_UNKNOWN unk_100335FC; // weak
_UNKNOWN *off_10033614 = &unk_100335FC; // weak
int dword_1003361C = 4; // weak
int (__cdecl *off_10033620)(int, int, int, int) = &sub_10019770; // weak
int (__cdecl *off_10033624)(int, int, int) = &sub_10019840; // weak
char aWPublicGrannyR_3[38] = "w:/public/granny/rt/granny_memory.cpp"; // weak
char aWPublicGrannyR_30[44] = "w:/public/granny/rt/granny_memory_arena.cpp"; // weak
char aWPublicGrannyR_25[50] = "w:/public/granny/rt/granny_memory_file_reader.cpp"; // weak
char aWPublicGrannyR_31[36] = "w:/public/granny/rt/granny_mesh.cpp"; // weak
char aWPublicGrannyR_33[44] = "w:/public/granny/rt/granny_mesh_binding.cpp"; // weak
char asc_10033B70[2] = "\n"; // weak
int dword_10033C04[] = { 0 }; // weak
_DWORD dword_10033C10 = 10; // weak
char aTangentbinorma[21] = "TangentBinormalCross"; // weak
char aBinormal[9] = "Binormal"; // weak
char aTangent[8] = "Tangent"; // weak
char aWPublicGrannyR_34[44] = "w:/public/granny/rt/granny_mesh_builder.cpp"; // weak
char aBoneweights[12] = "BoneWeights"; // weak
char aWPublicGrannyR_37[45] = "w:/public/granny/rt/granny_mesh_deformer.cpp"; // weak
char aDeformmesh[11] = "DeformMesh"; // weak
int dword_10033CF8 = 128; // weak
int dword_10033CFC = 192; // weak
int dword_10033D00 = 256; // weak
int dword_10033D04 = 512; // weak
char aWPublicGrannyR_24[50] = "w:/public/granny/rt/granny_oodle0_compression.cpp"; // weak
char aWPublicGrannyR_14[44] = "w:/public/granny/rt/granny_pointer_hash.cpp"; // weak
char *off_10033EEC[4] =
{
  "S3TC RGB555 (DXT1)",
  "S3TC RGBA5551 (DXT1 with alpha)",
  "S3TC RGBA8888, mapped alpha (DXT2/3)",
  "S3TC RGBA8888, interpolated alpha (DXT4/5)"
}; // weak
char aUnknownS3tcTex[28] = "Unknown S3TC texture format"; // weak
_DWORD dword_10034020 = 8; // weak
char aWPublicGrannyR_38[48] = "w:/public/granny/rt/granny_skeleton_builder.cpp"; // weak
char aWPublicGrannyR_17[47] = "w:/public/granny/rt/granny_stack_allocator.cpp"; // weak
CHAR Caption[] = "Fatal Granny Installation Error"; // idb
char aSHasBeenIncorr[171] = "%s has been incorrectly installed as %s.  To avoid versioning problems, %s must always be installed in an application-specific directory, and never in a system directory."; // weak
_UNKNOWN *off_1003440C = &unk_100502D8; // weak
char byte_10034410[256] =
{
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x02',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '`',
  '`',
  '`',
  '`',
  '`',
  '`',
  '`',
  '`',
  '`',
  '`',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '(',
  '(',
  '(',
  '(',
  '(',
  '(',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char aWPublicGrannyR_22[38] = "w:/public/granny/rt/granny_string.cpp"; // weak
char aSnan[7] = "(snan)"; // weak
char aQnan[7] = "(qnan)"; // weak
char aInfinity[11] = "(infinity)"; // weak
int dword_100345B8 = 3; // weak
char aIllegalStringA[24] = "(illegal string access)"; // weak
char aWPublicGrannyR_18[52] = "w:/public/granny/rt/granny_string_table_builder.cpp"; // weak
char *off_100346F0[6] =
{
  "Color map",
  "Cube map",
  "User-defined texture format",
  "Raw texture format",
  "S3TC format",
  "Bink texture format"
}; // weak
char *off_100346F8[4] =
{
  "User-defined texture format",
  "Raw texture format",
  "S3TC format",
  "Bink texture format"
}; // weak
char aUnknownTexture[21] = "Unknown texture type"; // weak
char aUnknownTexture_0[23] = "Unknown texture format"; // weak
char aWPublicGrannyR_39[39] = "w:/public/granny/rt/granny_texture.cpp"; // weak
char aAutomaticResca[34] = "Automatic rescaling not supported"; // weak
char aWPublicGrannyR_40[47] = "w:/public/granny/rt/granny_texture_builder.cpp"; // weak
char aImageScalerDoe[90] = "Image scaler does not currently support different filters for upsampling and downsampling"; // weak
char aWPublicGrannyR_41[51] = "w:/public/granny/rt/granny_track_group_builder.cpp"; // weak
char aWPublicGrannyR_42[51] = "w:/public/granny/rt/granny_track_group_sampler.cpp"; // weak
char aWPublicGrannyR_43[42] = "w:/public/granny/rt/granny_track_mask.cpp"; // weak
char aWPublicGrannyR_32[44] = "w:/public/granny/rt/granny_tri_topology.cpp"; // weak
char aWPublicGrannyR_44[47] = "w:/public/granny/rt/granny_variant_builder.cpp"; // weak
char a2105[8] = "2.1.0.5"; // weak
char aWPublicGrannyR_45[48] = "w:/public/granny/rt/granny_version_checking.cpp"; // weak
_UNKNOWN unk_10035668; // weak
_UNKNOWN unk_100356A8; // weak
_UNKNOWN unk_10035708; // weak
_UNKNOWN unk_100357C8; // weak
_UNKNOWN unk_10035848; // weak
_UNKNOWN unk_100358C8; // weak
_UNKNOWN unk_10035968; // weak
_UNKNOWN unk_10035A08; // weak
_UNKNOWN unk_10035AC8; // weak
_UNKNOWN unk_10035B68; // weak
_UNKNOWN unk_10035C28; // weak
char aBoneindices[12] = "BoneIndices"; // weak
char aWPublicGrannyR_35[43] = "w:/public/granny/rt/granny_vertex_data.cpp"; // weak
char aSD[5] = "%s%d"; // weak
char aTexturecoordin[19] = "TextureCoordinates"; // weak
char aDiffusecolor[13] = "DiffuseColor"; // weak
char aSpecularcolor[14] = "SpecularColor"; // weak
char aWPublicGrannyR_28[42] = "w:/public/granny/rt/granny_world_pose.cpp"; // weak
char aBuildworldtran[21] = "BuildWorldTransforms"; // weak
char aWPublicGrannyR_4[51] = "w:/public/granny/rt/win32/win32_granny_windows.cpp"; // weak
char aUnknownWin32Er[20] = "unknown win32 error"; // weak
char aSetfilepointer[15] = "SetFilePointer"; // weak
_BYTE byte_100360A8[4] = { 0, 0, 0, 0 }; // weak
_UNKNOWN unk_100360AC; // weak
char byte_100360CC = '\0'; // weak
int dword_100360D0 = 0; // weak
char byte_100360D4 = '\0'; // weak
char byte_100360D5 = '\0'; // weak
char byte_100360D6 = '\0'; // weak
char byte_100360D7 = '\0'; // weak
char byte_100360D8 = '\0'; // weak
char byte_100360D9 = '\0'; // weak
char byte_100360DA = '\0'; // weak
char byte_100360DB = '\0'; // weak
int dword_100360E0 = 0; // weak
int dword_100360E4 = 0; // weak
int dword_100360E8 = 0; // weak
int dword_100360EC = 0; // weak
int dword_100360F0 = 0; // weak
int dword_100360F4 = 0; // weak
int dword_100360F8 = 0; // weak
int dword_100360FC = 0; // weak
int dword_10036100 = 0; // weak
int dword_10036108 = 0; // weak
int dword_1003610C = 0; // weak
float flt_10036110 = 0.0; // weak
int dword_10036114 = 0; // weak
int dword_10036118 = 0; // weak
int dword_1003611C = 0; // weak
int dword_10036120 = 0; // weak
int dword_10036124 = 0; // weak
int dword_10036128 = 0; // weak
_UNKNOWN unk_10036130; // weak
int dword_100361C0 = 0; // weak
int dword_100361C4 = 0; // weak
_DWORD dword_100361C8[6] = { 0, 0, 0, 0, 0, 0 }; // weak
float flt_100361E0[54] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,  }; // weak
_UNKNOWN unk_100362C0; // weak
_UNKNOWN unk_100362D0; // weak
_UNKNOWN unk_100362DC; // weak
int dword_100368D0; // weak
int dword_100368D4; // weak
char byte_100368D8; // weak
char byte_100368D9; // weak
char byte_100368DA; // weak
char byte_100368DB; // weak
int dword_100368DC; // weak
int dword_100368E0; // weak
int dword_100368E4; // weak
_UNKNOWN unk_100368E8; // weak
char byte_10036904; // weak
int dword_10036908; // weak
_UNKNOWN unk_10036A14; // weak
int dword_10036A24; // weak
int dword_10036A28; // weak
char byte_10036A2C; // weak
int dword_10036A3C; // weak
char byte_10036A40[32768]; // weak
int (__cdecl *qword_1003EA40)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
unsigned __int8 byte_1003EA48[32768]; // weak
char byte_10046A48[44]; // weak
int dword_10046A74[5]; // weak
int dword_10046A88[42]; // weak
int dword_10046B30; // weak
CHAR FileName[512]; // weak
_UNKNOWN unk_10046D38; // weak
_UNKNOWN unk_10046D3C; // weak
int dword_10046D44[445]; // weak
int dword_10047438; // weak
int dword_1004743C; // weak
int dword_10047440; // weak
char byte_10047444; // weak
int dword_10047448; // weak
int dword_10047450[16]; // weak
int dword_10047490[32]; // weak
int dword_10047510[16]; // weak
int dword_10047550[64]; // weak
int dword_10047650[512]; // weak
int dword_10047E50[256]; // weak
int dword_10048250[32]; // weak
int dword_100482D0; // weak
CHAR Text[32768]; // idb
_UNKNOWN unk_10050308; // weak
_UNKNOWN unk_10050328; // weak
int dword_10056308; // weak
double dbl_10056310; // weak
double dbl_10056318; // weak
int dword_10056320; // weak
int dword_10056324; // weak
double dbl_10056328; // weak
double dbl_10056330; // weak
int dword_10056338; // weak
double dbl_10056340; // weak
int dword_10056354; // weak
char byte_10056358; // weak


//----- (10001000) --------------------------------------------------------
_DWORD *__cdecl sub_10001000(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 7;
  a1[1] = *a2;
  a1[2] = a2[1];
  a1[3] = a2[2];
  a1[4] = *a3;
  a1[5] = a3[1];
  a1[6] = a3[2];
  a1[7] = a3[3];
  a1[8] = *a4;
  a1[9] = a4[1];
  a1[10] = a4[2];
  a1[11] = a4[3];
  a1[12] = a4[4];
  a1[13] = a4[5];
  a1[14] = a4[6];
  a1[15] = a4[7];
  a1[16] = a4[8];
  return result;
}

//----- (10001080) --------------------------------------------------------
BOOL __cdecl sub_10001080(int *a1, char *a2, char *a3, char *a4)
{
  long double v5; // st7
  float *v6; // eax
  int v7; // edx
  double v8; // st6
  long double v9; // st7
  int *v10; // eax
  int v11; // edx
  double v12; // st6
  bool v13; // bl
  long double v14; // st7
  float *v15; // eax
  int v16; // edx
  double v17; // st6
  BOOL result; // eax
  bool v19; // [esp+20h] [ebp+10h]

  sub_10001000(a1, a2, a3, a4);
  v5 = 0.0;
  v6 = (float *)&unk_1002A07C;
  v7 = 3;
  do
  {
    v8 = *(float *)((char *)v6++ + a2 - (char *)&unk_1002A07C);
    --v7;
    v5 = v5 + fabs(v8 - *(v6 - 1));
  }
  while ( v7 );
  v19 = v5 < 0.001;
  v9 = 0.0;
  v10 = &dword_1002A08C;
  v11 = 4;
  do
  {
    v12 = *(float *)((char *)v10++ + a3 - (char *)&dword_1002A08C);
    --v11;
    v9 = v9 + fabs(v12 - *((float *)v10 - 1));
  }
  while ( v11 );
  v13 = v9 < 0.000099999997;
  v14 = 0.0;
  v15 = (float *)&unk_1002A09C;
  v16 = 9;
  do
  {
    v17 = *(float *)((char *)v15++ + a4 - (char *)&unk_1002A09C);
    --v16;
    v14 = v14 + fabs(v17 - *(v15 - 1));
  }
  while ( v16 );
  result = !v19;
  *a1 = result | (v13 ? 0 : 2) | (v14 < 0.001 ? 0 : 4);
  return result;
}
// 1002A08C: using guessed type int dword_1002A08C;

//----- (10001190) --------------------------------------------------------
_DWORD *__cdecl sub_10001190(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  a1[3] = 0;
  a1[2] = 0;
  a1[1] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 1065353216;
  a1[8] = 1065353216;
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = 0;
  a1[12] = 1065353216;
  a1[13] = 0;
  a1[14] = 0;
  a1[15] = 0;
  a1[16] = 1065353216;
  return result;
}

//----- (100011F0) --------------------------------------------------------
_DWORD *__cdecl sub_100011F0(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  a1[3] = 0;
  a1[2] = 0;
  a1[1] = 0;
  a1[7] = 0;
  a1[6] = 0;
  a1[5] = 0;
  a1[4] = 0;
  a1[8] = 0;
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = 0;
  a1[12] = 0;
  a1[13] = 0;
  a1[14] = 0;
  a1[15] = 0;
  a1[16] = 0;
  return result;
}

//----- (10001230) --------------------------------------------------------
double __cdecl sub_10001230(float *a1)
{
  return (a1[12] * a1[16] - a1[13] * a1[15]) * a1[8]
       - (a1[16] * a1[11] - a1[13] * a1[14]) * a1[9]
       + (a1[15] * a1[11] - a1[12] * a1[14]) * a1[10];
}

//----- (10001270) --------------------------------------------------------
float *__cdecl sub_10001270(float *a1, int a2)
{
  double v2; // st7
  double v3; // st6
  double v4; // st5
  float *v6; // [esp+8h] [ebp+8h]

  v2 = *a1;
  v3 = a1[1];
  v4 = a1[2];
  v6 = (float *)(a2 + 16);
  *a1 = v4 * v6[6] + v3 * v6[5] + v2 * v6[4];
  a1[1] = v4 * v6[9] + v3 * v6[8] + v2 * v6[7];
  a1[2] = v4 * v6[12] + v3 * v6[11] + v2 * v6[10];
  return sub_10018C80(a1, v6);
}

//----- (100012D0) --------------------------------------------------------
float *__cdecl sub_100012D0(float *a1, float *a2)
{
  float v2; // eax
  double v3; // st7
  float *result; // eax
  double v5; // st7
  double v6; // st6
  double v7; // st5
  float v8[4]; // [esp+8h] [ebp-10h] BYREF

  v2 = a2[7];
  v8[0] = -a2[4];
  v8[1] = -a2[5];
  v3 = a2[6];
  v8[3] = v2;
  v8[2] = -v3;
  result = sub_10018C80(a1, v8);
  v5 = *a1;
  v6 = a1[1];
  v7 = a1[2];
  *a1 = v7 * a2[14] + v6 * a2[11] + v5 * a2[8];
  a1[1] = v7 * a2[15] + v6 * a2[12] + v5 * a2[9];
  a1[2] = v7 * a2[16] + v6 * a2[13] + v5 * a2[10];
  return result;
}

//----- (10001360) --------------------------------------------------------
float *__cdecl sub_10001360(float *a1, float *a2, float *a3)
{
  *a1 = a2[9] * a3[1] + a2[10] * a3[2] + a2[8] * *a3;
  a1[1] = a2[12] * a3[1] + a2[11] * *a3 + a2[13] * a3[2];
  a1[2] = a2[15] * a3[1] + a2[14] * *a3 + a2[16] * a3[2];
  return sub_10018C80(a1, a2 + 4);
}

//----- (100013D0) --------------------------------------------------------
float *__cdecl sub_100013D0(float *a1, float *a2)
{
  double v2; // st7
  double v3; // st6
  double v4; // st5
  float *result; // eax

  v2 = *a1;
  v3 = a1[1];
  v4 = a1[2];
  *a1 = v4 * a2[10] + v3 * a2[9] + v2 * a2[8];
  a1[1] = v4 * a2[13] + v3 * a2[12] + v2 * a2[11];
  a1[2] = v4 * a2[16] + v3 * a2[15] + v2 * a2[14];
  result = sub_10018C80(a1, a2 + 4);
  *a1 = a2[1] + *a1;
  a1[1] = a2[2] + a1[1];
  a1[2] = a2[3] + a1[2];
  return result;
}

//----- (10001450) --------------------------------------------------------
float *__cdecl sub_10001450(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a1 = a2[9] * a3[1] + a2[10] * a3[2] + a2[8] * *a3;
  a1[1] = a2[12] * a3[1] + a2[11] * *a3 + a2[13] * a3[2];
  a1[2] = a2[15] * a3[1] + a2[14] * *a3 + a2[16] * a3[2];
  result = sub_10018C80(a1, a2 + 4);
  *a1 = a2[1] + *a1;
  a1[1] = a2[2] + a1[1];
  a1[2] = a2[3] + a1[2];
  return result;
}

//----- (100014D0) --------------------------------------------------------
int __cdecl sub_100014D0(void *a1, int a2)
{
  int result; // eax
  _BYTE v3[68]; // [esp+8h] [ebp-44h] BYREF

  result = sub_10001530((int)v3, a2, (int)a1);
  qmemcpy(a1, v3, 0x44u);
  return result;
}

//----- (10001500) --------------------------------------------------------
int __cdecl sub_10001500(void *a1, int a2)
{
  int result; // eax
  _BYTE v3[68]; // [esp+8h] [ebp-44h] BYREF

  result = sub_10001530((int)v3, (int)a1, a2);
  qmemcpy(a1, v3, 0x44u);
  return result;
}

//----- (10001530) --------------------------------------------------------
int __cdecl sub_10001530(int a1, int a2, int a3)
{
  double v3; // st7
  double v4; // st6
  double v5; // st5
  int result; // eax
  float v7[9]; // [esp+10h] [ebp-6Ch] BYREF
  float v8[9]; // [esp+34h] [ebp-48h] BYREF
  float v9[9]; // [esp+58h] [ebp-24h] BYREF

  sub_100189A0(v7, (float *)(a2 + 16));
  sub_100189A0(v8, (float *)(a3 + 16));
  sub_10018450((float *)(a1 + 32), v8, (float *)(a3 + 32));
  sub_10018450(v9, (float *)(a2 + 32), (float *)(a1 + 32));
  sub_10018540((float *)(a1 + 32), v8, v9);
  *(float *)(a1 + 4) = *(float *)(a2 + 36) * *(float *)(a3 + 8)
                     + *(float *)(a2 + 40) * *(float *)(a3 + 12)
                     + *(float *)(a3 + 4) * *(float *)(a2 + 32);
  *(float *)(a1 + 8) = *(float *)(a2 + 44) * *(float *)(a3 + 4)
                     + *(float *)(a2 + 48) * *(float *)(a3 + 8)
                     + *(float *)(a2 + 52) * *(float *)(a3 + 12);
  *(float *)(a1 + 12) = *(float *)(a2 + 56) * *(float *)(a3 + 4)
                      + *(float *)(a2 + 60) * *(float *)(a3 + 8)
                      + *(float *)(a2 + 64) * *(float *)(a3 + 12);
  v3 = *(float *)(a1 + 4);
  v4 = *(float *)(a1 + 8);
  v5 = *(float *)(a1 + 12);
  *(float *)(a1 + 4) = v7[2] * v5 + v7[1] * v4 + v7[0] * v3;
  *(float *)(a1 + 8) = v7[5] * v5 + v7[4] * v4 + v7[3] * v3;
  *(float *)(a1 + 12) = v7[8] * v5 + v7[7] * v4 + v7[6] * v3;
  *(float *)(a1 + 4) = *(float *)(a1 + 4) + *(float *)(a2 + 4);
  *(float *)(a1 + 8) = *(float *)(a2 + 8) + *(float *)(a1 + 8);
  *(float *)(a1 + 12) = *(float *)(a2 + 12) + *(float *)(a1 + 12);
  sub_10018BC0((float *)(a1 + 16), (float *)(a2 + 16), (float *)(a3 + 16));
  result = *(_DWORD *)a3 | *(_DWORD *)a2;
  *(_DWORD *)a1 = result;
  return result;
}

//----- (10001690) --------------------------------------------------------
BOOL __cdecl sub_10001690(int *a1, float *a2)
{
  float v2; // eax
  double v3; // st7
  double v4; // st6
  double v5; // st7
  double v6; // st6
  double v7; // st5
  float v9[2]; // [esp+4h] [ebp-90h] BYREF
  float v10; // [esp+Ch] [ebp-88h]
  float v11; // [esp+10h] [ebp-84h]
  float v12; // [esp+14h] [ebp-80h]
  float v13[4]; // [esp+18h] [ebp-7Ch] BYREF
  float v14[9]; // [esp+28h] [ebp-6Ch] BYREF
  float v15[9]; // [esp+4Ch] [ebp-48h] BYREF
  float v16[9]; // [esp+70h] [ebp-24h] BYREF

  v2 = a2[7];
  v13[0] = -a2[4];
  v13[1] = -a2[5];
  v13[3] = v2;
  v13[2] = -a2[6];
  sub_100189A0(v15, v13);
  sub_100181D0(v14, a2 + 8);
  sub_10018450(v16, v14, v15);
  sub_10018540(v14, v15, v16);
  v3 = -a2[1];
  v4 = -a2[2];
  v10 = -a2[3];
  v11 = v3;
  v12 = v4;
  v9[0] = v14[2] * v10 + v14[1] * v4 + v14[0] * v3;
  v5 = v14[3] * v11 + v14[5] * v10 + v14[4] * v4;
  v6 = v14[7] * v12 + v14[6] * v11 + v14[8] * v10;
  v7 = v9[0];
  v9[0] = v15[2] * v6 + v15[1] * v5 + v15[0] * v9[0];
  v9[1] = v15[3] * v7 + v15[5] * v6 + v15[4] * v5;
  v10 = v15[7] * v5 + v15[6] * v7 + v15[8] * v6;
  return sub_10001080(a1, (char *)v9, (char *)v13, (char *)v14);
}

//----- (10001820) --------------------------------------------------------
float *__cdecl sub_10001820(float *a1, float *a2, float *a3, float *a4)
{
  return sub_10019310(a2, a3, a4, a1 + 1, a1 + 4, a1 + 8);
}

//----- (10001850) --------------------------------------------------------
float *__cdecl sub_10001850(int a1, int a2, float *a3)
{
  float v3; // ecx
  float v4; // edx
  float *v5; // eax
  float v6; // edx
  float *result; // eax
  float v8; // ecx
  float v9[9]; // [esp+4h] [ebp-48h] BYREF
  float v10[9]; // [esp+28h] [ebp-24h] BYREF

  sub_100189A0(v10, (float *)(a1 + 16));
  sub_10018450(v9, v10, (float *)(a1 + 32));
  v3 = v9[3];
  *a3 = v9[0];
  v4 = v9[6];
  a3[1] = v3;
  a3[2] = v4;
  v5 = &a3[a2];
  *v5 = v9[1];
  v5[1] = v9[4];
  v5[2] = v9[7];
  v6 = v9[5];
  result = &v5[a2];
  *result = v9[2];
  v8 = v9[8];
  result[1] = v6;
  result[2] = v8;
  return result;
}

//----- (100018D0) --------------------------------------------------------
_DWORD *__cdecl sub_100018D0(int a1, _DWORD *a2)
{
  float *v2; // ecx
  int v3; // edi
  int v4; // edi
  int v5; // edi
  int v6; // ecx
  _DWORD *result; // eax
  float v8[9]; // [esp+8h] [ebp-48h] BYREF
  float v9[9]; // [esp+2Ch] [ebp-24h] BYREF

  sub_100189A0(v8, (float *)(a1 + 16));
  if ( (*(_BYTE *)a1 & 4) != 0 )
  {
    sub_10018450(v9, v8, (float *)(a1 + 32));
    v2 = v9;
  }
  else
  {
    v2 = v8;
  }
  v3 = *((_DWORD *)v2 + 1);
  *a2 = *(_DWORD *)v2;
  a2[1] = *((_DWORD *)v2 + 3);
  a2[2] = *((_DWORD *)v2 + 6);
  a2[3] = 0;
  a2[4] = v3;
  a2[5] = *((_DWORD *)v2 + 4);
  a2[6] = *((_DWORD *)v2 + 7);
  v4 = *((_DWORD *)v2 + 2);
  a2[7] = 0;
  a2[8] = v4;
  v5 = *((_DWORD *)v2 + 5);
  v6 = *((_DWORD *)v2 + 8);
  a2[9] = v5;
  a2[10] = v6;
  a2[11] = 0;
  result = a2 + 12;
  a2[12] = *(_DWORD *)(a1 + 4);
  a2[13] = *(_DWORD *)(a1 + 8);
  a2[14] = *(_DWORD *)(a1 + 12);
  a2[15] = 1065353216;
  return result;
}

//----- (10001980) --------------------------------------------------------
int __cdecl sub_10001980(_DWORD *a1)
{
  return dword_100301C4[4 * *a1];
}
// 100301C4: using guessed type int dword_100301C4[];

//----- (10001990) --------------------------------------------------------
int __cdecl sub_10001990(int a1)
{
  if ( *(_DWORD *)a1 == 1 )
    return sub_100019C0(*(_DWORD **)(a1 + 8));
  else
    return dword_100301C4[4 * *(_DWORD *)a1] * sub_10001B90(a1);
}
// 100301C4: using guessed type int dword_100301C4[];

//----- (100019C0) --------------------------------------------------------
int __cdecl sub_100019C0(_DWORD *a1)
{
  _DWORD *v1; // esi
  int i; // edi

  v1 = a1;
  for ( i = 0; v1; v1 += 8 )
  {
    if ( !*v1 )
      break;
    i += sub_10001990(v1);
  }
  return i;
}
// 10001990: using guessed type _DWORD __cdecl sub_10001990(_DWORD);

//----- (100019F0) --------------------------------------------------------
int __cdecl sub_100019F0(int *a1)
{
  int *v1; // ecx
  int result; // eax
  int v3; // edx

  v1 = a1;
  result = 0;
  if ( a1 )
  {
    do
    {
      v3 = *v1;
      result += 32;
      v1 += 8;
    }
    while ( v3 );
  }
  return result;
}

//----- (10001A10) --------------------------------------------------------
char *__cdecl sub_10001A10(int a1)
{
  return (&off_100301C0)[4 * a1];
}
// 100301C0: using guessed type char *off_100301C0;

//----- (10001A20) --------------------------------------------------------
int __cdecl sub_10001A20(int a1)
{
  return (int)*(&off_100301C8 + 4 * a1);
}
// 100301C8: using guessed type _UNKNOWN *off_100301C8;

//----- (10001A30) --------------------------------------------------------
char __cdecl sub_10001A30(int *a1)
{
  int v1; // eax

  v1 = *a1;
  if ( *a1 == 1 )
    return sub_10001A70((_DWORD *)a1[2]);
  return v1 == 5 || v1 == 7 || v1 == 8 || a1[2];
}

//----- (10001A70) --------------------------------------------------------
char __cdecl sub_10001A70(_DWORD *a1)
{
  _DWORD *v1; // esi

  v1 = a1;
  if ( a1 )
  {
    while ( *v1 )
    {
      if ( (unsigned __int8)sub_10001A30(v1) )
        return 1;
      v1 += 8;
      if ( !v1 )
        return 0;
    }
  }
  return 0;
}
// 10001A30: using guessed type _DWORD __cdecl sub_10001A30(_DWORD);

//----- (10001AA0) --------------------------------------------------------
int __cdecl sub_10001AA0(int a1)
{
  if ( *(_DWORD *)a1 == 1 )
    return sub_10001AD0(*(_DWORD **)(a1 + 8));
  else
    return dword_100301CC[4 * *(_DWORD *)a1];
}
// 100301CC: using guessed type int dword_100301CC[];

//----- (10001AD0) --------------------------------------------------------
int __cdecl sub_10001AD0(_DWORD *a1)
{
  _DWORD *v1; // esi
  int i; // edi

  v1 = a1;
  for ( i = 0; v1; v1 += 8 )
  {
    if ( !*v1 )
      break;
    i |= sub_10001AA0(v1);
  }
  return i;
}
// 10001AA0: using guessed type _DWORD __cdecl sub_10001AA0(_DWORD);

//----- (10001B00) --------------------------------------------------------
BOOL __cdecl sub_10001B00(int a1)
{
  return (a1 & (a1 - 1)) != 0;
}

//----- (10001B10) --------------------------------------------------------
int __usercall sub_10001B10@<eax>(int a1@<ebx>, int a2, char *a3)
{
  unsigned int v3; // esi

  if ( *(_DWORD *)a2 == 1 )
    return sub_10001B60(*(_DWORD **)(a2 + 8), (int)a3);
  if ( *(_DWORD *)a2 == 9 )
  {
    sub_10001190(a3);
    return 68;
  }
  else
  {
    v3 = sub_10001990(a2);
    sub_10019D80(a1, v3, 0, a3);
    return v3;
  }
}

//----- (10001B60) --------------------------------------------------------
int __cdecl sub_10001B60(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  int i; // edi

  v2 = a1;
  for ( i = a2; v2; v2 += 8 )
  {
    if ( !*v2 )
      break;
    i += sub_10001B10(v2, i);
  }
  return i - a2;
}
// 10001B10: using guessed type _DWORD __cdecl sub_10001B10(_DWORD, _DWORD);

//----- (10001B90) --------------------------------------------------------
int __cdecl sub_10001B90(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 12);
  if ( !result )
    return 1;
  return result;
}

//----- (10001BB0) --------------------------------------------------------
int __cdecl sub_10001BB0(_DWORD *a1)
{
  int result; // eax

  result = 0;
  if ( *a1 == 6 )
    return a1[2];
  return result;
}

//----- (10001BD0) --------------------------------------------------------
int __cdecl sub_10001BD0(_DWORD *a1)
{
  _DWORD *v1; // ecx
  int result; // eax
  int v3; // edx

  v1 = a1;
  result = 0;
  if ( a1 && *a1 )
  {
    do
    {
      v3 = v1[1];
      ++v1;
      ++result;
    }
    while ( v3 );
  }
  return result;
}

//----- (10001BF0) --------------------------------------------------------
bool __cdecl sub_10001BF0(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  _DWORD *v3; // edi
  int v4; // eax
  _DWORD *v6; // [esp+Ch] [ebp-4h]
  char v7; // [esp+14h] [ebp+4h]

  v2 = a1;
  v3 = (_DWORD *)a2;
  if ( !a1 || !a2 )
    return a1 == (_DWORD *)a2;
  if ( a1[7] == a2 || *(_DWORD **)(a2 + 28) == a1 )
    return 1;
  a1[7] = a2;
  *(_DWORD *)(a2 + 28) = a1;
  v4 = *a1;
  v6 = v3;
  v7 = 1;
  if ( *v2 )
  {
    while ( *v3 )
    {
      if ( v4 != *v3 || v2[3] != v3[3] )
      {
LABEL_14:
        v7 = 0;
        break;
      }
      if ( v4 == 6 )
      {
        sub_10017FE0(2, 0, aSwitchabletype);
      }
      else if ( !(unsigned __int8)sub_10001BF0(v2[2], v3[2]) )
      {
        goto LABEL_14;
      }
      v4 = v2[8];
      v2 += 8;
      v3 += 8;
      if ( !v4 )
        break;
    }
  }
  a1[7] = 0;
  v6[7] = 0;
  if ( *v2 == *v3 )
    return v7;
  else
    return 0;
}

//----- (10001CD0) --------------------------------------------------------
_DWORD *__cdecl sub_10001CD0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // esi
  _DWORD *v3; // edi
  int i; // eax

  v2 = a1;
  if ( !a1 )
    return 0;
  v3 = a2;
  if ( !a2 )
    return 0;
  for ( i = *a1; i; v3 += 8 )
  {
    if ( !*v3 )
      break;
    if ( i != *v3 || v2[3] != v3[3] )
      return 0;
    if ( i == 6 )
    {
      sub_10017FE0(2, 0, aSwitchabletype);
    }
    else if ( !sub_10001BF0((_DWORD *)v2[2], v3[2]) )
    {
      return 0;
    }
    i = v2[8];
    v2 += 8;
  }
  return *v3 != 0 ? 0 : v2;
}

//----- (10001D50) --------------------------------------------------------
int __cdecl sub_10001D50(_DWORD *a1, int a2, unsigned int *a3)
{
  int result; // eax
  _DWORD *v5; // esi
  int v6; // edi
  int v7; // eax
  int v8; // [esp+10h] [ebp+Ch]

  result = a2;
  if ( a2 )
  {
    v8 = a2;
    do
    {
      v5 = a1;
      if ( *a1 )
      {
        do
        {
          v6 = sub_10001990((int)v5);
          if ( *v5 == 1 )
          {
            sub_10001D50(v5[2], 1, a3);
          }
          else
          {
            v7 = sub_10001AA0((int)v5) - 2;
            if ( v7 )
            {
              if ( v7 == 2 )
                sub_10019E80(v6, a3);
            }
            else
            {
              sub_10019EE0(v6, (int *)a3);
            }
          }
          result = v5[8];
          v5 += 8;
          a3 = (unsigned int *)((char *)a3 + v6);
        }
        while ( result );
      }
      --v8;
    }
    while ( v8 );
  }
  return result;
}

//----- (10001DD0) --------------------------------------------------------
_DWORD *__cdecl sub_10001DD0(int a1, _DWORD *a2)
{
  return sub_100018D0(a1 + 8, a2);
}

//----- (10001DE0) --------------------------------------------------------
int __cdecl sub_10001DE0(int a1, char *a2)
{
  int v2; // ebp
  int v3; // ebx

  if ( !a1 )
    return 0;
  v2 = 0;
  if ( *(int *)(a1 + 4) <= 0 )
    return 0;
  while ( 1 )
  {
    v3 = sub_10001E80(*(_DWORD **)(*(_DWORD *)(a1 + 8) + 8 * v2 + 4));
    if ( v3 )
    {
      if ( sub_10001E40((char **)(8 * v2 + *(_DWORD *)(a1 + 8)), a2) )
        break;
    }
    if ( ++v2 >= *(_DWORD *)(a1 + 4) )
      return 0;
  }
  return v3;
}

//----- (10001E40) --------------------------------------------------------
char __cdecl sub_10001E40(char **a1, char *a2)
{
  char **v2; // esi

  v2 = (char **)&unk_1002A0D0;
  while ( !sub_10021AC0(v2[1], *a1) || *v2 != a2 )
  {
    v2 += 2;
    if ( (int)v2 >= (int)&flt_1002A170 )
      return 0;
  }
  return 1;
}
// 1002A170: using guessed type float flt_1002A170;

//----- (10001E80) --------------------------------------------------------
int __cdecl sub_10001E80(_DWORD *a1)
{
  int result; // eax
  int v2; // ebx
  int i; // esi

  result = 0;
  if ( a1 )
  {
    if ( a1[3] )
    {
      return a1[3];
    }
    else
    {
      v2 = a1[1];
      for ( i = 0; i < v2; result = sub_10001E80(*(_DWORD *)(a1[2] + 8 * i++ + 4)) )
      {
        if ( result )
          break;
      }
    }
  }
  return result;
}

//----- (10001EC0) --------------------------------------------------------
_DWORD *__cdecl sub_10001EC0(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  a1[1] = a1;
  a1[2] = a1;
  a1[3] = 0;
  a1[4] = a1;
  a1[5] = a1;
  a1[6] = 0;
  a1[7] = 0;
  return result;
}

//----- (10001EE0) --------------------------------------------------------
int *__cdecl sub_10001EE0(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // eax
  void (__cdecl *v6)(int *, int); // esi
  int *result; // eax
  int *v8; // [esp+10h] [ebp-4h] BYREF

  sub_10019A60(&v8, 32);
  if ( *(_DWORD *)a1 )
    (*(void (__cdecl **)(int *, int, int, int))a1)(v8, a2, a3, a4);
  if ( sub_10019C60((int)aWPublicGrannyR_6, 67) )
  {
    v8[6] = a1;
    v4 = sub_1000F020(a2);
    *v8 = a2;
    v8[1] = v4;
    v8[2] = *(_DWORD *)(v4 + 8);
    *(_DWORD *)(v8[1] + 8) = v8;
    *(_DWORD *)(v8[2] + 4) = v8;
    v5 = sub_100021E0(a3);
    v8[3] = a3;
    v8[4] = v5;
    v8[5] = *(_DWORD *)(v5 + 20);
    *(_DWORD *)(v8[4] + 20) = v8;
    *(_DWORD *)(v8[5] + 16) = v8;
    v6 = *(void (__cdecl **)(int *, int))(a1 + 4);
    result = v8;
    if ( !v6 )
      return result;
    v6(v8, a4);
  }
  return v8;
}

//----- (10001FC0) --------------------------------------------------------
int __cdecl sub_10001FC0(int *a1)
{
  void (__cdecl *v1)(int *); // eax

  if ( a1 )
  {
    *(_DWORD *)(a1[1] + 8) = a1[2];
    *(_DWORD *)(a1[2] + 4) = a1[1];
    *(_DWORD *)(a1[4] + 20) = a1[5];
    *(_DWORD *)(a1[5] + 16) = a1[4];
    v1 = *(void (__cdecl **)(int *))(a1[6] + 16);
    if ( v1 )
      v1(a1);
    sub_1000F3D0(*a1);
  }
  return off_10033624((int)aWPublicGrannyR_6, 115, (int)a1);
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10002020) --------------------------------------------------------
char __cdecl sub_10002020(int *a1, int a2, int a3, int a4)
{
  int (__cdecl *v4)(int *, int, int, int); // eax

  LOBYTE(v4) = sub_1000F740(*a1);
  if ( (_BYTE)v4 )
  {
    v4 = *(int (__cdecl **)(int *, int, int, int))(a1[6] + 8);
    if ( v4 )
      LOBYTE(v4) = v4(a1, a2, a3, a4);
  }
  return (char)v4;
}

//----- (10002060) --------------------------------------------------------
char __cdecl sub_10002060(int *a1, int a2, int a3, int a4, int a5)
{
  int (__cdecl *v5)(int *, int, int, int, int); // eax

  LOBYTE(v5) = sub_1000F740(*a1);
  if ( (_BYTE)v5 )
  {
    v5 = *(int (__cdecl **)(int *, int, int, int, int))(a1[6] + 12);
    if ( v5 )
      LOBYTE(v5) = v5(a1, a2, a3, a4, a5);
  }
  return (char)v5;
}

//----- (100020A0) --------------------------------------------------------
int __cdecl sub_100020A0(int a1)
{
  int result; // eax

  for ( result = *(_DWORD *)(a1 + 8); result != a1; result = *(_DWORD *)(a1 + 8) )
    sub_10001FC0(result);
  return result;
}
// 10001FC0: using guessed type _DWORD __cdecl sub_10001FC0(_DWORD);

//----- (100020D0) --------------------------------------------------------
int *__cdecl sub_100020D0(int a1)
{
  int *result; // eax

  for ( result = *(int **)(a1 + 20); result != (int *)a1; result = *(int **)(a1 + 20) )
    sub_10001FC0(result);
  return result;
}

//----- (10002100) --------------------------------------------------------
int __cdecl sub_10002100(int a1)
{
  return *(_DWORD *)(sub_100021E0(a1) + 20);
}

//----- (10002130) --------------------------------------------------------
int __cdecl sub_10002130(int a1)
{
  return *(_DWORD *)(sub_1000F020(a1) + 8);
}

//----- (10002150) --------------------------------------------------------
int __cdecl sub_10002150(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (10002170) --------------------------------------------------------
_DWORD *__cdecl sub_10002170(int a1)
{
  _DWORD *v1; // esi

  v1 = sub_10014D00((int *)a4);
  if ( v1 )
  {
    *v1 = a1;
    sub_10001EC0(v1 + 1);
  }
  return v1;
}

//----- (100021A0) --------------------------------------------------------
void __cdecl sub_100021A0(unsigned int a1)
{
  int v1; // eax

  if ( a1 )
  {
    v1 = sub_100021E0(a1);
    sub_100020D0(v1);
  }
  sub_10014E60(a4, a1);
}

//----- (100021D0) --------------------------------------------------------
int __cdecl sub_100021D0(int a1)
{
  return *(_DWORD *)(*(_DWORD *)a1 + 4);
}

//----- (100021E0) --------------------------------------------------------
int __cdecl sub_100021E0(int a1)
{
  return a1 + 4;
}

//----- (100021F0) --------------------------------------------------------
void __cdecl sub_100021F0(int a1, float a2)
{
  int v2; // edi
  int *i; // esi

  v2 = sub_100021E0(a1);
  for ( i = *(int **)(v2 + 20); i != (int *)v2; i = (int *)i[5] )
    sub_1000F190(*i, a2);
}

//----- (10002230) --------------------------------------------------------
char __cdecl sub_10002230(int a1)
{
  int v1; // eax
  int *v2; // edi
  int *v3; // esi
  int v4; // eax

  v1 = sub_100021E0(a1);
  v2 = (int *)v1;
  v3 = *(int **)(v1 + 20);
  if ( v3 != (int *)v1 )
  {
    do
    {
      v4 = *v3;
      v3 = (int *)v3[5];
      LOBYTE(v1) = sub_1000F3A0(v4);
    }
    while ( v3 != v2 );
  }
  return v1;
}

//----- (10002260) --------------------------------------------------------
char __cdecl sub_10002260(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int *v5; // edi
  int *v6; // esi

  v4 = sub_100021E0(a1);
  v5 = (int *)v4;
  v6 = *(int **)(v4 + 20);
  if ( v6 != (int *)v4 )
  {
    do
    {
      LOBYTE(v4) = sub_10002020(v6, a2, a3, a4);
      v6 = (int *)v6[5];
    }
    while ( v6 != v5 );
  }
  return v4;
}

//----- (100022A0) --------------------------------------------------------
int __cdecl sub_100022A0(int a1, int a2, int a3, int *a4)
{
  void *v4; // esi
  int v5; // eax
  int v6; // eax
  unsigned __int64 v7; // rax
  __int64 v8; // rcx
  unsigned int v9; // kr00_4
  int v10; // edi
  int result; // eax
  unsigned int v12; // [esp+10h] [ebp-10h]
  unsigned __int64 v13; // [esp+18h] [ebp-8h]

  if ( (byte_100360CC & 1) == 0 )
  {
    byte_100360CC |= 1u;
    dword_100360D0 = (int)sub_100218A0((int)aSamplemodelani);
  }
  v4 = off_1003440C;
  off_1003440C = (_UNKNOWN *)dword_100360D0;
  v13 = __rdtsc();
  sub_10017870((int)a4);
  sub_10002260(a1, a2, a3, (int)a4);
  v5 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  if ( v5 )
    v6 = *(_DWORD *)(v5 + 8) + 8;
  else
    v6 = 0;
  sub_10017AA0(a4, a2, a3, 156, v6);
  v7 = __rdtsc();
  v12 = v7;
  LODWORD(v7) = off_1003440C;
  HIDWORD(v7) = (__PAIR64__(HIDWORD(v7), v12) - v13) >> 32;
  LODWORD(v8) = v12 - v13;
  HIDWORD(v8) = *((_DWORD *)off_1003440C + 3);
  v9 = *((_DWORD *)off_1003440C + 2);
  ++*((_DWORD *)off_1003440C + 1);
  *(_QWORD *)(v7 + 8) = v8 + __PAIR64__(HIDWORD(v7), v9);
  off_1003440C = v4;
  v10 = *((_DWORD *)v4 + 4);
  LODWORD(v7) = *((_DWORD *)v4 + 5);
  *((_DWORD *)v4 + 4) = v12 - v13 + v10;
  result = HIDWORD(v7) + __CFADD__(v12 - v13, v10) + (_DWORD)v7;
  *((_DWORD *)v4 + 5) = result;
  return result;
}
// 1003440C: using guessed type _UNKNOWN *off_1003440C;
// 100360CC: using guessed type char byte_100360CC;
// 100360D0: using guessed type int dword_100360D0;

//----- (10002390) --------------------------------------------------------
int __cdecl sub_10002390(int a1, int a2, float *a3, float *a4)
{
  int v4; // edi
  int *v5; // esi
  double v6; // st7
  long double v7; // st7
  double v8; // st6
  double v9; // st6
  double v10; // st5
  double v11; // st5
  double v12; // st5
  float *v13; // edi
  int result; // eax
  int v15; // eax
  int v16; // ecx
  int v17; // edx
  int v18; // eax
  int v19; // ecx
  int v20; // edx
  int v21; // eax
  int v22; // ecx
  int v23; // edx
  int v24; // eax
  int v25; // ecx
  int v26; // edx
  int v27; // ecx
  int v28; // edx
  float v29; // [esp+8h] [ebp-E4h] BYREF
  float v30; // [esp+Ch] [ebp-E0h]
  float v31; // [esp+10h] [ebp-DCh]
  float v32; // [esp+14h] [ebp-D8h]
  float v33; // [esp+18h] [ebp-D4h]
  float v34; // [esp+1Ch] [ebp-D0h]
  float v35; // [esp+20h] [ebp-CCh]
  float v36; // [esp+24h] [ebp-C8h] BYREF
  float v37; // [esp+28h] [ebp-C4h]
  float v38; // [esp+2Ch] [ebp-C0h]
  float v39; // [esp+30h] [ebp-BCh]
  float v40; // [esp+34h] [ebp-B8h] BYREF
  float v41; // [esp+38h] [ebp-B4h]
  float v42; // [esp+3Ch] [ebp-B0h]
  float v43; // [esp+40h] [ebp-ACh]
  float v44; // [esp+44h] [ebp-A8h]
  float v45; // [esp+48h] [ebp-A4h] BYREF
  float v46; // [esp+4Ch] [ebp-A0h]
  float v47; // [esp+50h] [ebp-9Ch]
  int v48; // [esp+54h] [ebp-98h]
  float v49; // [esp+58h] [ebp-94h]
  float v50; // [esp+5Ch] [ebp-90h]
  float v51; // [esp+60h] [ebp-8Ch]
  int v52; // [esp+64h] [ebp-88h]
  float v53; // [esp+68h] [ebp-84h]
  float v54; // [esp+6Ch] [ebp-80h]
  float v55; // [esp+70h] [ebp-7Ch]
  int v56; // [esp+74h] [ebp-78h]
  float v57; // [esp+78h] [ebp-74h]
  float v58; // [esp+7Ch] [ebp-70h]
  float v59; // [esp+80h] [ebp-6Ch]
  int v60; // [esp+84h] [ebp-68h]
  _DWORD v61[18]; // [esp+88h] [ebp-64h] BYREF
  float v62; // [esp+D0h] [ebp-1Ch]
  float v63; // [esp+D8h] [ebp-14h]
  float v64; // [esp+DCh] [ebp-10h]
  float v65; // [esp+E4h] [ebp-8h]
  float v66; // [esp+E8h] [ebp-4h]

  v40 = 0.0;
  v38 = 0.0;
  v37 = 0.0;
  v36 = 0.0;
  v31 = 0.0;
  v30 = 0.0;
  v29 = 0.0;
  v4 = sub_100021E0(a1);
  v5 = *(int **)(v4 + 20);
  if ( v5 != (int *)v4 )
  {
    do
    {
      sub_10002060(v5, a2, (int)&v40, (int)&v36, (int)&v29);
      v5 = (int *)v5[5];
    }
    while ( v5 != (int *)v4 );
    if ( v40 != 0.0 )
    {
      v6 = 1.0 / v40;
      v36 = v36 * v6;
      v37 = v37 * v6;
      v38 = v38 * v6;
      v29 = v29 * v6;
      v30 = v30 * v6;
      v31 = v31 * v6;
    }
  }
  v59 = v38;
  v56 = 0;
  v52 = 0;
  v48 = 0;
  v60 = 1065353216;
  v57 = v36;
  v58 = v37;
  v7 = sqrt(v30 * v30 + v31 * v31 + v29 * v29);
  if ( v7 <= 0.0 )
  {
    v55 = 1.0;
    v50 = 1.0;
    v45 = 1.0;
    v54 = 0.0;
    v53 = 0.0;
    v51 = 0.0;
    v49 = 0.0;
    v47 = 0.0;
    v46 = 0.0;
  }
  else
  {
    v29 = v29 * (1.0 / v7);
    v30 = v30 * (1.0 / v7);
    v31 = v31 * (1.0 / v7);
    v39 = sin(v7);
    v35 = cos(v7);
    v34 = v30 * v30;
    v43 = v31 * v31;
    v8 = 1.0 - v35;
    v32 = v8;
    v33 = v8 * v30 * v29;
    v44 = v31 * v39;
    v9 = v33 - v44;
    v10 = v32 * v31;
    v32 = v10;
    v41 = v10 * v29;
    v11 = v30 * v39;
    v42 = v11;
    v62 = v11 + v41;
    v12 = v44 + v33;
    v63 = (1.0 - v34) * v35 + v34;
    v33 = v32 * v30;
    v34 = v39 * v29;
    v64 = v33 - v34;
    v65 = v34 + v33;
    v66 = (1.0 - v43) * v35 + v43;
    v50 = v63;
    v45 = v29 * v29 + (1.0 - v29 * v29) * v35;
    v51 = v65;
    v46 = v12;
    v53 = v62;
    v54 = v64;
    v47 = v41 - v42;
    v55 = v66;
    v49 = v9;
  }
  v13 = a4;
  if ( a4 == a3 )
    v13 = (float *)v61;
  result = sub_10018630((int)v13, &v45, a3);
  if ( v13 == (float *)v61 )
  {
    v15 = v61[1];
    v16 = v61[2];
    *a3 = *(float *)v61;
    v17 = v61[3];
    *((_DWORD *)a3 + 1) = v15;
    v18 = v61[4];
    *((_DWORD *)a3 + 2) = v16;
    v19 = v61[5];
    *((_DWORD *)a3 + 3) = v17;
    v20 = v61[6];
    *((_DWORD *)a3 + 4) = v18;
    v21 = v61[7];
    *((_DWORD *)a3 + 5) = v19;
    v22 = v61[8];
    *((_DWORD *)a3 + 6) = v20;
    v23 = v61[9];
    *((_DWORD *)a3 + 7) = v21;
    v24 = v61[10];
    *((_DWORD *)a3 + 8) = v22;
    v25 = v61[11];
    *((_DWORD *)a3 + 9) = v23;
    v26 = v61[12];
    *((_DWORD *)a3 + 10) = v24;
    result = v61[13];
    *((_DWORD *)a3 + 11) = v25;
    v27 = v61[14];
    *((_DWORD *)a3 + 12) = v26;
    v28 = v61[15];
    *((_DWORD *)a3 + 13) = result;
    *((_DWORD *)a3 + 14) = v27;
    *((_DWORD *)a3 + 15) = v28;
  }
  return result;
}
// 1002A170: using guessed type float flt_1002A170;

//----- (10002790) --------------------------------------------------------
int __cdecl sub_10002790(int a1)
{
  return a1 + 36;
}

//----- (100027A0) --------------------------------------------------------
BOOL __cdecl sub_100027A0(int a1)
{
  return !*(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 12);
}

//----- (100027C0) --------------------------------------------------------
BOOL __cdecl sub_100027C0(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2
      && a1[1] == a2[1]
      && a1[2] == a2[2]
      && a1[3] == a2[3]
      && a1[4] == a2[4]
      && a1[5] == a2[5]
      && a1[6] == a2[6]
      && a1[7] == a2[7]
      && a1[8] == a2[8];
}

//----- (10002820) --------------------------------------------------------
BOOL __cdecl sub_10002820(int a1)
{
  return *(_DWORD *)(a1 + 32) != 0;
}

//----- (10002830) --------------------------------------------------------
int __cdecl sub_10002830(int *a1, int a2, int a3)
{
  int v3; // ecx
  unsigned int i; // edx
  int v5; // eax
  int v6; // ebp
  int result; // eax

  v3 = 0;
  for ( i = 0; i < 4; ++i )
  {
    v5 = *(_DWORD *)(a3 + 4 * i);
    v6 = *(_DWORD *)(a2 + 4 * v5);
    a1[v5 + 1] = v3;
    a1[v5 + 5] = v6;
    v3 += *(_DWORD *)(a2 + 4 * v5);
  }
  result = (int)((v3 + 7) & 0xFFFFFFF8) / 8;
  *a1 = result;
  return result;
}

//----- (10002880) --------------------------------------------------------
int __cdecl sub_10002880(int *a1, int a2, int a3, int a4, int a5)
{
  _DWORD v6[4]; // [esp+0h] [ebp-20h] BYREF
  _DWORD v7[4]; // [esp+10h] [ebp-10h] BYREF

  v7[0] = a2;
  v7[1] = a3;
  v7[2] = a4;
  v7[3] = a5;
  v6[0] = 0;
  v6[1] = 1;
  v6[2] = 2;
  v6[3] = 3;
  return sub_10002830(a1, (int)v7, (int)v6);
}

//----- (100028E0) --------------------------------------------------------
int __cdecl sub_100028E0(int *a1, int a2, int a3, int a4, int a5)
{
  _DWORD v6[4]; // [esp+0h] [ebp-20h] BYREF
  _DWORD v7[4]; // [esp+10h] [ebp-10h] BYREF

  v7[0] = a2;
  v7[1] = a3;
  v7[2] = a4;
  v7[3] = a5;
  v6[0] = 2;
  v6[1] = 1;
  v6[2] = 0;
  v6[3] = 3;
  return sub_10002830(a1, (int)v7, (int)v6);
}

//----- (10002940) --------------------------------------------------------
int __cdecl sub_10002940(_DWORD *a1)
{
  nullsub_1(a1[1], a1[3]);
  return nullsub_1(a1[5], a1[7]);
}
// 10002970: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD);

//----- (10002980) --------------------------------------------------------
unsigned int *__cdecl sub_10002980(
        unsigned int a1,
        int a2,
        _DWORD *a3,
        int a4,
        int *a5,
        unsigned int *a6,
        int a7,
        unsigned int *a8)
{
  unsigned int *v8; // ebx
  unsigned int *v9; // esi
  int v10; // ecx
  _DWORD *v11; // ebp
  int v12; // ecx
  int v13; // edx
  int v14; // edi
  int v15; // eax
  unsigned int *v16; // ecx
  int *v17; // eax
  unsigned int v18; // edi
  int v19; // ebp
  unsigned int *v20; // ecx
  unsigned int v21; // eax
  unsigned int *v22; // ecx
  unsigned int i; // edi
  unsigned int v24; // eax
  unsigned int *v25; // edx
  unsigned int v26; // ecx
  bool v27; // zf
  unsigned int *result; // eax
  unsigned int v29; // [esp-4h] [ebp-3Ch]
  unsigned int v30; // [esp-4h] [ebp-3Ch]
  int v31; // [esp+10h] [ebp-28h]
  int v32; // [esp+14h] [ebp-24h]
  _DWORD v33[4]; // [esp+18h] [ebp-20h] BYREF
  int v34[4]; // [esp+28h] [ebp-10h] BYREF

  v8 = a8;
  v9 = (unsigned int *)a5;
  a5 = (int *)(a6 + 1);
  v10 = (char *)a6 - (char *)a3;
  v11 = a3 + 5;
  v31 = (char *)a6 - (char *)a3;
  a8 = 0;
  while ( 1 )
  {
    v12 = *(_DWORD *)((char *)v11 + v10);
    v13 = *a5;
    v14 = *a5 + v12 - *v11 - *(v11 - 4);
    v32 = *a5 + v12 - *v11;
    v15 = 0;
    if ( v12 > 0 )
    {
      if ( v32 > v13 )
        v13 = *a5 + v12 - *v11;
      v15 = sub_10002B30(v13, *v11 + v32);
    }
    v16 = a8;
    *(_DWORD *)((char *)v33 + (_DWORD)a8) = v15;
    v17 = a5;
    *(int *)((char *)v34 + (_DWORD)v16) = v14;
    ++v11;
    a5 = v17 + 1;
    a8 = v16 + 1;
    if ( (int)(v16 + 1) >= 16 )
      break;
    v10 = v31;
  }
  v18 = a1;
  v19 = a4 - a1 * *a3;
  v20 = (unsigned int *)(a7 - a1 * *a6);
  a8 = v20;
  if ( a2 != 1 )
  {
    a5 = (int *)(a2 - 1);
    do
    {
      if ( v18 )
      {
        do
        {
          v29 = *v9;
          v9 = (unsigned int *)((char *)v9 + *a3);
          v21 = sub_10002B50(v34, v33, v29);
          v22 = a6;
          *v8 = v21;
          v8 = (unsigned int *)((char *)v8 + *v22);
          --v18;
        }
        while ( v18 );
        v18 = a1;
        v20 = a8;
      }
      v9 = (unsigned int *)((char *)v9 + v19);
      v8 = (unsigned int *)((char *)v8 + (_DWORD)v20);
      a5 = (int *)((char *)a5 - 1);
    }
    while ( a5 );
  }
  for ( i = v18 - 1; i; --i )
  {
    v30 = *v9;
    v9 = (unsigned int *)((char *)v9 + *a3);
    v24 = sub_10002B50(v34, v33, v30);
    v25 = a6;
    *v8 = v24;
    v8 = (unsigned int *)((char *)v8 + *v25);
  }
  v26 = *a3;
  v27 = *a3 == 0;
  a1 = 0;
  if ( !v27 )
    qmemcpy(&a1, v9, v26);
  a3 = (_DWORD *)sub_10002B50(v34, v33, a1);
  result = a6;
  if ( *a6 )
    qmemcpy(v8, &a3, *a6);
  return result;
}

//----- (10002B30) --------------------------------------------------------
int __cdecl sub_10002B30(int a1, int a2)
{
  int v2; // ecx
  int result; // eax

  v2 = a1;
  for ( result = 0; v2 < a2; ++v2 )
    result |= 1 << v2;
  return result;
}

//----- (10002B50) --------------------------------------------------------
unsigned int __cdecl sub_10002B50(int *a1, _DWORD *a2, unsigned int a3)
{
  unsigned int v3; // ebp
  unsigned int v4; // ebp
  unsigned int v5; // ebp

  v3 = a2[3] & sub_10002BB0(a3, a1[3]);
  v4 = (a2[2] & sub_10002BB0(a3, a1[2])) + v3;
  v5 = (a2[1] & sub_10002BB0(a3, a1[1])) + v4;
  return v5 + (*a2 & sub_10002BB0(a3, *a1));
}

//----- (10002BB0) --------------------------------------------------------
unsigned int __cdecl sub_10002BB0(unsigned int a1, int a2)
{
  if ( a2 <= 0 )
    return a1 >> -(char)a2;
  else
    return a1 << a2;
}

//----- (10002BD0) --------------------------------------------------------
int __usercall sub_10002BD0@<eax>(__m128 a1@<xmm6>, __m128 a2@<xmm7>, int a3, unsigned int *a4, float *a5, __m128 *a6)
{
  __m128 v7; // xmm5
  __m128 *v8; // ecx
  __m128 *v9; // edx
  __m128 v10; // xmm6
  __m128 v11; // xmm7
  __m128 v12; // xmm1
  __m128 *v13; // ecx
  __m128 *v14; // edx
  int result; // eax
  __m128 v16; // xmm0
  __m128 v17; // xmm1
  __m128 v18; // xmm0

  do
  {
    v7 = _mm_loadl_ps((const double *)a4 + 4);
    v8 = (__m128 *)(a6[2].m128_i32[0] + (*((unsigned __int8 *)a4 + 16) << 6));
    v9 = (__m128 *)(a6[2].m128_i32[0] + (*((unsigned __int8 *)a4 + 17) << 6));
    a1.m128_f32[0] = (float)*((unsigned __int8 *)a4 + 12) * 0.0039215689;
    v10 = _mm_shuffle_ps(a1, a1, 0);
    a2.m128_f32[0] = (float)*((unsigned __int8 *)a4 + 13) * 0.0039215689;
    v11 = _mm_shuffle_ps(a2, a2, 0);
    v12 = _mm_add_ps(
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[5], (__m128)a4[5], 0), *v8),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[6], (__m128)a4[6], 0), v8[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[7], (__m128)a4[7], 0), v8[2])),
              v10),
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[5], (__m128)a4[5], 0), *v9),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[6], (__m128)a4[6], 0), v9[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[7], (__m128)a4[7], 0), v9[2])),
              v11));
    *a6 = _mm_add_ps(
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_add_ps(v8[3], _mm_mul_ps(_mm_shuffle_ps((__m128)*a4, (__m128)*a4, 0), *v8)),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[1], (__m128)a4[1], 0), v8[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[2], (__m128)a4[2], 0), v8[2])),
              v10),
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_add_ps(v9[3], _mm_mul_ps(_mm_shuffle_ps((__m128)*a4, (__m128)*a4, 0), *v9)),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[1], (__m128)a4[1], 0), v9[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[2], (__m128)a4[2], 0), v9[2])),
              v11));
    a6[1] = v12;
    v13 = (__m128 *)(a6[2].m128_i32[0] + (*((unsigned __int8 *)a4 + 18) << 6));
    v14 = (__m128 *)(a6[2].m128_i32[0] + (*((unsigned __int8 *)a4 + 19) << 6));
    v10.m128_f32[0] = (float)*((unsigned __int8 *)a4 + 14) * 0.0039215689;
    a1 = _mm_shuffle_ps(v10, v10, 0);
    result = *((unsigned __int8 *)a4 + 15);
    v11.m128_f32[0] = (float)result * 0.0039215689;
    a2 = _mm_shuffle_ps(v11, v11, 0);
    v16 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(
                _mm_add_ps(
                  _mm_add_ps(
                    _mm_add_ps(v13[3], _mm_mul_ps(_mm_shuffle_ps((__m128)*a4, (__m128)*a4, 0), *v13)),
                    _mm_mul_ps(_mm_shuffle_ps((__m128)a4[1], (__m128)a4[1], 0), v13[1])),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[2], (__m128)a4[2], 0), v13[2])),
                a1),
              _mm_mul_ps(
                _mm_add_ps(
                  _mm_add_ps(
                    _mm_add_ps(v14[3], _mm_mul_ps(_mm_shuffle_ps((__m128)*a4, (__m128)*a4, 0), *v14)),
                    _mm_mul_ps(_mm_shuffle_ps((__m128)a4[1], (__m128)a4[1], 0), v14[1])),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[2], (__m128)a4[2], 0), v14[2])),
                a2)),
            *a6);
    v17 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(
                _mm_add_ps(
                  _mm_add_ps(
                    _mm_mul_ps(_mm_shuffle_ps((__m128)a4[5], (__m128)a4[5], 0), *v13),
                    _mm_mul_ps(_mm_shuffle_ps((__m128)a4[6], (__m128)a4[6], 0), v13[1])),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[7], (__m128)a4[7], 0), v13[2])),
                a1),
              _mm_mul_ps(
                _mm_add_ps(
                  _mm_add_ps(
                    _mm_mul_ps(_mm_shuffle_ps((__m128)a4[5], (__m128)a4[5], 0), *v14),
                    _mm_mul_ps(_mm_shuffle_ps((__m128)a4[6], (__m128)a4[6], 0), v14[1])),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[7], (__m128)a4[7], 0), v14[2])),
                a2)),
            a6[1]);
    v18 = _mm_shuffle_ps(v16, v16, 36);
    v18.m128_f32[0] = v17.m128_f32[0];
    _mm_stream_ps(a5, _mm_shuffle_ps(v18, v18, 39));
    _mm_stream_ps(a5 + 4, _mm_movelh_ps(_mm_shuffle_ps(v17, v17, 9), v7));
    a5 += 8;
    a4 += 10;
    _mm_prefetch((const char *)a4 + 120, 0);
    --a3;
  }
  while ( a3 );
  _m_empty();
  return result;
}

//----- (10002E50) --------------------------------------------------------
int __usercall sub_10002E50@<eax>(__m128 a1@<xmm6>, __m128 a2@<xmm7>, int a3, unsigned int *a4, float *a5, int a6)
{
  __m128 *v7; // ecx
  __m128 *v8; // edx
  int result; // eax
  __m128 v10; // xmm0
  __m128 v11; // xmm1
  __m128 v12; // xmm0
  __m128 v13; // xmm1

  do
  {
    v7 = (__m128 *)(*(_DWORD *)(a6 + 32) + (*((unsigned __int8 *)a4 + 14) << 6));
    v8 = (__m128 *)(*(_DWORD *)(a6 + 32) + (*((unsigned __int8 *)a4 + 15) << 6));
    a1.m128_f32[0] = (float)*((unsigned __int8 *)a4 + 12) * 0.0039215689;
    a1 = _mm_shuffle_ps(a1, a1, 0);
    result = *((unsigned __int8 *)a4 + 13);
    a2.m128_f32[0] = (float)result * 0.0039215689;
    a2 = _mm_shuffle_ps(a2, a2, 0);
    v10 = _mm_add_ps(
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_add_ps(v7[3], _mm_mul_ps(_mm_shuffle_ps((__m128)*a4, (__m128)*a4, 0), *v7)),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[1], (__m128)a4[1], 0), v7[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[2], (__m128)a4[2], 0), v7[2])),
              a1),
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_add_ps(v8[3], _mm_mul_ps(_mm_shuffle_ps((__m128)*a4, (__m128)*a4, 0), *v8)),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[1], (__m128)a4[1], 0), v8[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[2], (__m128)a4[2], 0), v8[2])),
              a2));
    v11 = _mm_add_ps(
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[4], (__m128)a4[4], 0), *v7),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[5], (__m128)a4[5], 0), v7[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[6], (__m128)a4[6], 0), v7[2])),
              a1),
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[4], (__m128)a4[4], 0), *v8),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[5], (__m128)a4[5], 0), v8[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[6], (__m128)a4[6], 0), v8[2])),
              a2));
    v12 = _mm_shuffle_ps(v10, v10, 36);
    v12.m128_f32[0] = v11.m128_f32[0];
    v13 = _mm_movelh_ps(_mm_shuffle_ps(v11, v11, 9), _mm_loadl_ps((const double *)(a4 + 7)));
    _mm_stream_ps(a5, _mm_shuffle_ps(v12, v12, 39));
    _mm_stream_ps(a5 + 4, v13);
    a5 += 8;
    a4 += 9;
    _mm_prefetch((const char *)a4 + 108, 0);
    --a3;
  }
  while ( a3 );
  _m_empty();
  return result;
}

//----- (10002FB0) --------------------------------------------------------
void __cdecl sub_10002FB0(int a1, unsigned int *a2, float *a3, int a4)
{
  __m128 *v5; // ecx
  __m128 *v6; // edx
  __m128 v7; // xmm0
  __m128 v8; // xmm1
  __m128 v9; // xmm2
  __m128 v10; // xmm3
  __m128 v11; // xmm0
  __m128 v12; // xmm1
  __m128 v13; // xmm2
  __m128 v14; // xmm3

  do
  {
    v5 = (__m128 *)(*(_DWORD *)(a4 + 32) + (a2[3] << 6));
    v6 = (__m128 *)(*(_DWORD *)(a4 + 32) + (a2[12] << 6));
    v7 = _mm_add_ps(
           _mm_add_ps(
             _mm_add_ps(v5[3], _mm_mul_ps(_mm_shuffle_ps((__m128)*a2, (__m128)*a2, 0), *v5)),
             _mm_mul_ps(_mm_shuffle_ps((__m128)a2[1], (__m128)a2[1], 0), v5[1])),
           _mm_mul_ps(_mm_shuffle_ps((__m128)a2[2], (__m128)a2[2], 0), v5[2]));
    v8 = _mm_add_ps(
           _mm_add_ps(
             _mm_mul_ps(_mm_shuffle_ps((__m128)a2[4], (__m128)a2[4], 0), *v5),
             _mm_mul_ps(_mm_shuffle_ps((__m128)a2[5], (__m128)a2[5], 0), v5[1])),
           _mm_mul_ps(_mm_shuffle_ps((__m128)a2[6], (__m128)a2[6], 0), v5[2]));
    v9 = _mm_add_ps(
           _mm_add_ps(
             _mm_add_ps(v6[3], _mm_mul_ps(_mm_shuffle_ps((__m128)a2[9], (__m128)a2[9], 0), *v6)),
             _mm_mul_ps(_mm_shuffle_ps((__m128)a2[10], (__m128)a2[10], 0), v6[1])),
           _mm_mul_ps(_mm_shuffle_ps((__m128)a2[11], (__m128)a2[11], 0), v6[2]));
    v10 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[13], (__m128)a2[13], 0), *v6),
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[14], (__m128)a2[14], 0), v6[1])),
            _mm_mul_ps(_mm_shuffle_ps((__m128)a2[15], (__m128)a2[15], 0), v6[2]));
    v11 = _mm_shuffle_ps(v7, v7, 36);
    v11.m128_f32[0] = v8.m128_f32[0];
    v12 = _mm_movelh_ps(_mm_shuffle_ps(v8, v8, 9), _mm_loadl_ps((const double *)(a2 + 7)));
    v13 = _mm_shuffle_ps(v9, v9, 36);
    v13.m128_f32[0] = v10.m128_f32[0];
    v14 = _mm_movelh_ps(_mm_shuffle_ps(v10, v10, 9), _mm_loadl_ps((const double *)a2 + 8));
    _mm_stream_ps(a3, _mm_shuffle_ps(v11, v11, 39));
    _mm_stream_ps(a3 + 4, v12);
    _mm_stream_ps(a3 + 8, _mm_shuffle_ps(v13, v13, 39));
    _mm_stream_ps(a3 + 12, v14);
    a3 += 16;
    a2 += 18;
    _mm_prefetch((const char *)a2 + 108, 0);
    _mm_prefetch((const char *)a2 + 144, 0);
    --a1;
  }
  while ( a1 );
  _m_empty();
}

//----- (10003100) --------------------------------------------------------
int __usercall sub_10003100@<eax>(__m128 a1@<xmm6>, __m128 a2@<xmm7>, int a3, unsigned int *a4, float *a5, __m128 *a6)
{
  __m128 v7; // xmm5
  __int32 v8; // eax
  __m128 *v9; // ecx
  __m128 *v10; // edx
  __m128 v11; // xmm6
  __m128 v12; // xmm7
  __m128 v13; // xmm1
  __int32 v14; // eax
  __m128 *v15; // ecx
  __m128 *v16; // edx
  int result; // eax
  __m128 v18; // xmm0
  __m128 v19; // xmm1
  __m128 v20; // xmm0

  do
  {
    v7 = _mm_loadl_ps((const double *)a4 + 4);
    v8 = a6[2].m128_i32[1];
    v9 = (__m128 *)(a6[2].m128_i32[0] + (*(_DWORD *)(v8 + 4 * *((unsigned __int8 *)a4 + 16)) << 6));
    v10 = (__m128 *)(a6[2].m128_i32[0] + (*(_DWORD *)(v8 + 4 * *((unsigned __int8 *)a4 + 17)) << 6));
    a1.m128_f32[0] = (float)*((unsigned __int8 *)a4 + 12) * 0.0039215689;
    v11 = _mm_shuffle_ps(a1, a1, 0);
    a2.m128_f32[0] = (float)*((unsigned __int8 *)a4 + 13) * 0.0039215689;
    v12 = _mm_shuffle_ps(a2, a2, 0);
    v13 = _mm_add_ps(
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[5], (__m128)a4[5], 0), *v9),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[6], (__m128)a4[6], 0), v9[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[7], (__m128)a4[7], 0), v9[2])),
              v11),
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[5], (__m128)a4[5], 0), *v10),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[6], (__m128)a4[6], 0), v10[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[7], (__m128)a4[7], 0), v10[2])),
              v12));
    *a6 = _mm_add_ps(
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_add_ps(v9[3], _mm_mul_ps(_mm_shuffle_ps((__m128)*a4, (__m128)*a4, 0), *v9)),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[1], (__m128)a4[1], 0), v9[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[2], (__m128)a4[2], 0), v9[2])),
              v11),
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_add_ps(v10[3], _mm_mul_ps(_mm_shuffle_ps((__m128)*a4, (__m128)*a4, 0), *v10)),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[1], (__m128)a4[1], 0), v10[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[2], (__m128)a4[2], 0), v10[2])),
              v12));
    a6[1] = v13;
    v14 = a6[2].m128_i32[1];
    v15 = (__m128 *)(a6[2].m128_i32[0] + (*(_DWORD *)(v14 + 4 * *((unsigned __int8 *)a4 + 18)) << 6));
    v16 = (__m128 *)(a6[2].m128_i32[0] + (*(_DWORD *)(v14 + 4 * *((unsigned __int8 *)a4 + 19)) << 6));
    v11.m128_f32[0] = (float)*((unsigned __int8 *)a4 + 14) * 0.0039215689;
    a1 = _mm_shuffle_ps(v11, v11, 0);
    result = *((unsigned __int8 *)a4 + 15);
    v12.m128_f32[0] = (float)result * 0.0039215689;
    a2 = _mm_shuffle_ps(v12, v12, 0);
    v18 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(
                _mm_add_ps(
                  _mm_add_ps(
                    _mm_add_ps(v15[3], _mm_mul_ps(_mm_shuffle_ps((__m128)*a4, (__m128)*a4, 0), *v15)),
                    _mm_mul_ps(_mm_shuffle_ps((__m128)a4[1], (__m128)a4[1], 0), v15[1])),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[2], (__m128)a4[2], 0), v15[2])),
                a1),
              _mm_mul_ps(
                _mm_add_ps(
                  _mm_add_ps(
                    _mm_add_ps(v16[3], _mm_mul_ps(_mm_shuffle_ps((__m128)*a4, (__m128)*a4, 0), *v16)),
                    _mm_mul_ps(_mm_shuffle_ps((__m128)a4[1], (__m128)a4[1], 0), v16[1])),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[2], (__m128)a4[2], 0), v16[2])),
                a2)),
            *a6);
    v19 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(
                _mm_add_ps(
                  _mm_add_ps(
                    _mm_mul_ps(_mm_shuffle_ps((__m128)a4[5], (__m128)a4[5], 0), *v15),
                    _mm_mul_ps(_mm_shuffle_ps((__m128)a4[6], (__m128)a4[6], 0), v15[1])),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[7], (__m128)a4[7], 0), v15[2])),
                a1),
              _mm_mul_ps(
                _mm_add_ps(
                  _mm_add_ps(
                    _mm_mul_ps(_mm_shuffle_ps((__m128)a4[5], (__m128)a4[5], 0), *v16),
                    _mm_mul_ps(_mm_shuffle_ps((__m128)a4[6], (__m128)a4[6], 0), v16[1])),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[7], (__m128)a4[7], 0), v16[2])),
                a2)),
            a6[1]);
    v20 = _mm_shuffle_ps(v18, v18, 36);
    v20.m128_f32[0] = v19.m128_f32[0];
    _mm_stream_ps(a5, _mm_shuffle_ps(v20, v20, 39));
    _mm_stream_ps(a5 + 4, _mm_movelh_ps(_mm_shuffle_ps(v19, v19, 9), v7));
    a5 += 8;
    a4 += 10;
    _mm_prefetch((const char *)a4 + 120, 0);
    --a3;
  }
  while ( a3 );
  _m_empty();
  return result;
}

//----- (10003390) --------------------------------------------------------
int __usercall sub_10003390@<eax>(__m128 a1@<xmm6>, __m128 a2@<xmm7>, int a3, unsigned int *a4, float *a5, int a6)
{
  int v7; // eax
  __m128 *v8; // ecx
  __m128 *v9; // edx
  int result; // eax
  __m128 v11; // xmm0
  __m128 v12; // xmm1
  __m128 v13; // xmm0
  __m128 v14; // xmm1

  do
  {
    v7 = *(_DWORD *)(a6 + 36);
    v8 = (__m128 *)(*(_DWORD *)(a6 + 32) + (*(_DWORD *)(v7 + 4 * *((unsigned __int8 *)a4 + 14)) << 6));
    v9 = (__m128 *)(*(_DWORD *)(a6 + 32) + (*(_DWORD *)(v7 + 4 * *((unsigned __int8 *)a4 + 15)) << 6));
    a1.m128_f32[0] = (float)*((unsigned __int8 *)a4 + 12) * 0.0039215689;
    a1 = _mm_shuffle_ps(a1, a1, 0);
    result = *((unsigned __int8 *)a4 + 13);
    a2.m128_f32[0] = (float)result * 0.0039215689;
    a2 = _mm_shuffle_ps(a2, a2, 0);
    v11 = _mm_add_ps(
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_add_ps(v8[3], _mm_mul_ps(_mm_shuffle_ps((__m128)*a4, (__m128)*a4, 0), *v8)),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[1], (__m128)a4[1], 0), v8[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[2], (__m128)a4[2], 0), v8[2])),
              a1),
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_add_ps(v9[3], _mm_mul_ps(_mm_shuffle_ps((__m128)*a4, (__m128)*a4, 0), *v9)),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[1], (__m128)a4[1], 0), v9[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[2], (__m128)a4[2], 0), v9[2])),
              a2));
    v12 = _mm_add_ps(
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[4], (__m128)a4[4], 0), *v8),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[5], (__m128)a4[5], 0), v8[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[6], (__m128)a4[6], 0), v8[2])),
              a1),
            _mm_mul_ps(
              _mm_add_ps(
                _mm_add_ps(
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[4], (__m128)a4[4], 0), *v9),
                  _mm_mul_ps(_mm_shuffle_ps((__m128)a4[5], (__m128)a4[5], 0), v9[1])),
                _mm_mul_ps(_mm_shuffle_ps((__m128)a4[6], (__m128)a4[6], 0), v9[2])),
              a2));
    v13 = _mm_shuffle_ps(v11, v11, 36);
    v13.m128_f32[0] = v12.m128_f32[0];
    v14 = _mm_movelh_ps(_mm_shuffle_ps(v12, v12, 9), _mm_loadl_ps((const double *)(a4 + 7)));
    _mm_stream_ps(a5, _mm_shuffle_ps(v13, v13, 39));
    _mm_stream_ps(a5 + 4, v14);
    a5 += 8;
    a4 += 9;
    _mm_prefetch((const char *)a4 + 108, 0);
    --a3;
  }
  while ( a3 );
  _m_empty();
  return result;
}

//----- (10003500) --------------------------------------------------------
int __cdecl sub_10003500(int a1, unsigned int *a2, float *a3, int a4)
{
  int result; // eax
  __m128 *v6; // ecx
  __m128 *v7; // edx
  __m128 v8; // xmm0
  __m128 v9; // xmm1
  __m128 v10; // xmm2
  __m128 v11; // xmm3
  __m128 v12; // xmm0
  __m128 v13; // xmm1
  __m128 v14; // xmm2
  __m128 v15; // xmm3

  do
  {
    result = *(_DWORD *)(a4 + 36);
    v6 = (__m128 *)(*(_DWORD *)(a4 + 32) + (*(_DWORD *)(result + 4 * a2[3]) << 6));
    v7 = (__m128 *)(*(_DWORD *)(a4 + 32) + (*(_DWORD *)(result + 4 * a2[12]) << 6));
    v8 = _mm_add_ps(
           _mm_add_ps(
             _mm_add_ps(v6[3], _mm_mul_ps(_mm_shuffle_ps((__m128)*a2, (__m128)*a2, 0), *v6)),
             _mm_mul_ps(_mm_shuffle_ps((__m128)a2[1], (__m128)a2[1], 0), v6[1])),
           _mm_mul_ps(_mm_shuffle_ps((__m128)a2[2], (__m128)a2[2], 0), v6[2]));
    v9 = _mm_add_ps(
           _mm_add_ps(
             _mm_mul_ps(_mm_shuffle_ps((__m128)a2[4], (__m128)a2[4], 0), *v6),
             _mm_mul_ps(_mm_shuffle_ps((__m128)a2[5], (__m128)a2[5], 0), v6[1])),
           _mm_mul_ps(_mm_shuffle_ps((__m128)a2[6], (__m128)a2[6], 0), v6[2]));
    v10 = _mm_add_ps(
            _mm_add_ps(
              _mm_add_ps(v7[3], _mm_mul_ps(_mm_shuffle_ps((__m128)a2[9], (__m128)a2[9], 0), *v7)),
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[10], (__m128)a2[10], 0), v7[1])),
            _mm_mul_ps(_mm_shuffle_ps((__m128)a2[11], (__m128)a2[11], 0), v7[2]));
    v11 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[13], (__m128)a2[13], 0), *v7),
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[14], (__m128)a2[14], 0), v7[1])),
            _mm_mul_ps(_mm_shuffle_ps((__m128)a2[15], (__m128)a2[15], 0), v7[2]));
    v12 = _mm_shuffle_ps(v8, v8, 36);
    v12.m128_f32[0] = v9.m128_f32[0];
    v13 = _mm_movelh_ps(_mm_shuffle_ps(v9, v9, 9), _mm_loadl_ps((const double *)(a2 + 7)));
    v14 = _mm_shuffle_ps(v10, v10, 36);
    v14.m128_f32[0] = v11.m128_f32[0];
    v15 = _mm_movelh_ps(_mm_shuffle_ps(v11, v11, 9), _mm_loadl_ps((const double *)a2 + 8));
    _mm_stream_ps(a3, _mm_shuffle_ps(v12, v12, 39));
    _mm_stream_ps(a3 + 4, v13);
    _mm_stream_ps(a3 + 8, _mm_shuffle_ps(v14, v14, 39));
    _mm_stream_ps(a3 + 12, v15);
    a3 += 16;
    a2 += 18;
    _mm_prefetch((const char *)a2 + 108, 0);
    _mm_prefetch((const char *)a2 + 144, 0);
    --a1;
  }
  while ( a1 );
  _m_empty();
  return result;
}

//----- (10003650) --------------------------------------------------------
int __cdecl sub_10003650(int a1, unsigned int *a2, float *a3, int a4, int a5)
{
  float *v5; // eax
  int result; // eax
  const char *v7; // edx
  const char *v8; // eax
  _BYTE v9[32]; // [esp+10h] [ebp-30h] BYREF
  int v10; // [esp+30h] [ebp-10h]
  int v11; // [esp+34h] [ebp-Ch]

  v5 = a3;
  if ( (a5 & 0xF) != 0 || ((unsigned __int8)a3 & 0xF) != 0 )
  {
    if ( byte_100360D4 )
    {
      v7 = byte_100360A8;
      if ( ((unsigned __int8)a3 & 0xF) != 0 )
        v7 = aDestvertices;
      v8 = byte_100360A8;
      if ( (a5 & 0xF) != 0 )
        v8 = aMatrixbuffer4x;
      sub_10017FE0(
        3,
        41,
        "%s(%d): SSE routine bypassed because the following pointers were not aligned: %s%s%s  (this message will only appear once)",
        aWPublicGrannyR,
        126,
        v8,
        byte_100360A8,
        v7);
      v5 = a3;
      byte_100360D4 = 0;
    }
    return sub_10014F60(a1, (int)a2, v5, a4, a5, 2);
  }
  else
  {
    v10 = a5;
    v11 = a4;
    sub_10003500(a1 >> 1, a2, a3, (int)v9);
    result = a1;
    if ( (a1 & 1) != 0 )
      return sub_10014F60(1, (int)&a2[9 * a1 - 9], &a3[8 * a1 - 8], a4, a5, 2);
  }
  return result;
}
// 100360A8: using guessed type _BYTE byte_100360A8[4];
// 100360D4: using guessed type char byte_100360D4;

//----- (10003740) --------------------------------------------------------
int __cdecl sub_10003740(int a1, unsigned int *a2, float *a3, int a4)
{
  float *v4; // eax
  int result; // eax
  const char *v6; // edx
  const char *v7; // eax
  _BYTE v8[32]; // [esp+10h] [ebp-30h] BYREF
  int v9; // [esp+30h] [ebp-10h]

  v4 = a3;
  if ( (a4 & 0xF) != 0 || ((unsigned __int8)a3 & 0xF) != 0 )
  {
    if ( byte_100360D5 )
    {
      v6 = byte_100360A8;
      if ( ((unsigned __int8)a3 & 0xF) != 0 )
        v6 = aDestvertices;
      v7 = byte_100360A8;
      if ( (a4 & 0xF) != 0 )
        v7 = aMatrixbuffer4x;
      sub_10017FE0(
        3,
        41,
        "%s(%d): SSE routine bypassed because the following pointers were not aligned: %s%s%s  (this message will only appear once)",
        aWPublicGrannyR,
        164,
        v7,
        byte_100360A8,
        v6);
      v4 = a3;
      byte_100360D5 = 0;
    }
    return sub_100150C0(a1, (int)a2, v4, a4, 2);
  }
  else
  {
    v9 = a4;
    sub_10002FB0(a1 >> 1, a2, a3, (int)v8);
    result = a1;
    if ( (a1 & 1) != 0 )
      return sub_100150C0(1, (int)&a2[9 * a1 - 9], &a3[8 * a1 - 8], a4, 2);
  }
  return result;
}
// 100360A8: using guessed type _BYTE byte_100360A8[4];
// 100360D5: using guessed type char byte_100360D5;

//----- (10003820) --------------------------------------------------------
float *__usercall sub_10003820@<eax>(
        __m128 a1@<xmm6>,
        __m128 a2@<xmm7>,
        int a3,
        unsigned int *a4,
        float *a5,
        int a6,
        int a7)
{
  float *v7; // eax
  const char *v9; // edx
  const char *v10; // eax
  _BYTE v11[32]; // [esp+10h] [ebp-30h] BYREF
  int v12; // [esp+30h] [ebp-10h]
  int v13; // [esp+34h] [ebp-Ch]

  v7 = a5;
  if ( (a7 & 0xF) != 0 || ((unsigned __int8)a5 & 0xF) != 0 )
  {
    if ( byte_100360D6 )
    {
      v9 = byte_100360A8;
      if ( ((unsigned __int8)a5 & 0xF) != 0 )
        v9 = aDestvertices;
      v10 = byte_100360A8;
      if ( (a7 & 0xF) != 0 )
        v10 = aMatrixbuffer4x;
      sub_10017FE0(
        3,
        41,
        "%s(%d): SSE routine bypassed because the following pointers were not aligned: %s%s%s  (this message will only appear once)",
        aWPublicGrannyR,
        194,
        v10,
        byte_100360A8,
        v9);
      v7 = a5;
      byte_100360D6 = 0;
    }
    return sub_10015200(a3, (int)a4, v7, a6, a7, 2);
  }
  else
  {
    v13 = a6;
    v12 = a7;
    return (float *)sub_10003390(a1, a2, a3, a4, a5, (int)v11);
  }
}
// 100360A8: using guessed type _BYTE byte_100360A8[4];
// 100360D6: using guessed type char byte_100360D6;

//----- (100038D0) --------------------------------------------------------
float *__usercall sub_100038D0@<eax>(__m128 a1@<xmm6>, __m128 a2@<xmm7>, int a3, unsigned int *a4, float *a5, int a6)
{
  float *v6; // eax
  const char *v8; // edx
  const char *v9; // eax
  _BYTE v10[32]; // [esp+10h] [ebp-30h] BYREF
  int v11; // [esp+30h] [ebp-10h]

  v6 = a5;
  if ( (a6 & 0xF) != 0 || ((unsigned __int8)a5 & 0xF) != 0 )
  {
    if ( byte_100360D7 )
    {
      v8 = byte_100360A8;
      if ( ((unsigned __int8)a5 & 0xF) != 0 )
        v8 = aDestvertices;
      v9 = byte_100360A8;
      if ( (a6 & 0xF) != 0 )
        v9 = aMatrixbuffer4x;
      sub_10017FE0(
        3,
        41,
        "%s(%d): SSE routine bypassed because the following pointers were not aligned: %s%s%s  (this message will only appear once)",
        aWPublicGrannyR,
        224,
        v9,
        byte_100360A8,
        v8);
      v6 = a5;
      byte_100360D7 = 0;
    }
    return sub_10015440(a3, (int)a4, v6, a6, 2);
  }
  else
  {
    v11 = a6;
    return (float *)sub_10002E50(a1, a2, a3, a4, a5, (int)v10);
  }
}
// 100360A8: using guessed type _BYTE byte_100360A8[4];
// 100360D7: using guessed type char byte_100360D7;

//----- (10003980) --------------------------------------------------------
float *__usercall sub_10003980@<eax>(
        __m128 a1@<xmm6>,
        __m128 a2@<xmm7>,
        int a3,
        unsigned int *a4,
        float *a5,
        int a6,
        int a7)
{
  float *v7; // eax
  const char *v9; // edx
  const char *v10; // eax
  __m128 v11[2]; // [esp+10h] [ebp-30h] BYREF
  int v12; // [esp+30h] [ebp-10h]
  int v13; // [esp+34h] [ebp-Ch]

  v7 = a5;
  if ( (a7 & 0xF) != 0 || ((unsigned __int8)a5 & 0xF) != 0 )
  {
    if ( byte_100360D8 )
    {
      v9 = byte_100360A8;
      if ( ((unsigned __int8)a5 & 0xF) != 0 )
        v9 = aDestvertices;
      v10 = byte_100360A8;
      if ( (a7 & 0xF) != 0 )
        v10 = aMatrixbuffer4x;
      sub_10017FE0(
        3,
        41,
        "%s(%d): SSE routine bypassed because the following pointers were not aligned: %s%s%s  (this message will only appear once)",
        aWPublicGrannyR,
        254,
        v10,
        byte_100360A8,
        v9);
      v7 = a5;
      byte_100360D8 = 0;
    }
    return sub_10015670(a3, (int)a4, v7, a6, a7, 2);
  }
  else
  {
    v13 = a6;
    v12 = a7;
    return (float *)sub_10003100(a1, a2, a3, a4, a5, v11);
  }
}
// 100360A8: using guessed type _BYTE byte_100360A8[4];
// 100360D8: using guessed type char byte_100360D8;

//----- (10003A30) --------------------------------------------------------
float *__usercall sub_10003A30@<eax>(__m128 a1@<xmm6>, __m128 a2@<xmm7>, int a3, unsigned int *a4, float *a5, int a6)
{
  float *v6; // eax
  const char *v8; // edx
  const char *v9; // eax
  __m128 v10[2]; // [esp+10h] [ebp-30h] BYREF
  int v11; // [esp+30h] [ebp-10h]

  v6 = a5;
  if ( (a6 & 0xF) != 0 || ((unsigned __int8)a5 & 0xF) != 0 )
  {
    if ( byte_100360D9 )
    {
      v8 = byte_100360A8;
      if ( ((unsigned __int8)a5 & 0xF) != 0 )
        v8 = aDestvertices;
      v9 = byte_100360A8;
      if ( (a6 & 0xF) != 0 )
        v9 = aMatrixbuffer4x;
      sub_10017FE0(
        3,
        41,
        "%s(%d): SSE routine bypassed because the following pointers were not aligned: %s%s%s  (this message will only appear once)",
        aWPublicGrannyR,
        284,
        v9,
        byte_100360A8,
        v8);
      v6 = a5;
      byte_100360D9 = 0;
    }
    return sub_10015A60(a3, (int)a4, v6, a6, 2);
  }
  else
  {
    v11 = a6;
    return (float *)sub_10002BD0(a1, a2, a3, a4, a5, v10);
  }
}
// 100360A8: using guessed type _BYTE byte_100360A8[4];
// 100360D9: using guessed type char byte_100360D9;

//----- (10003AE0) --------------------------------------------------------
void __cdecl sub_10003AE0(int a1, int a2, float *a3, __m128 *a4)
{
  __m128 v5; // xmm4
  __m128 v9; // xmm1
  __m128 v10; // xmm2
  __m128 v11; // xmm7
  __m128 v12; // [esp-60h] [ebp-6Ch]
  __m128 v13; // [esp-50h] [ebp-5Ch]
  __m128 v14; // [esp-10h] [ebp-1Ch]

  v5 = _mm_shuffle_ps(*a4, *a4, 36);
  v12 = _mm_shuffle_ps(a4[1], a4[1], 36);
  v13 = _mm_shuffle_ps(a4[2], a4[2], 36);
  v14 = _mm_movelh_ps(a4[3], (__m128)a4[3].m128_u32[2]);
  do
  {
    _mm_prefetch((const char *)(a2 + 96), 0);
    _mm_prefetch((const char *)(a2 + 128), 0);
    v9 = _mm_loadh_ps((const double *)(a2 + 24));
    v10 = _mm_loadh_ps((const double *)(a2 + 56));
    v11 = _mm_add_ps(
            _mm_add_ps(
              _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(*(__m128 *)(a2 + 32), *(__m128 *)(a2 + 32), 192), v5), v14),
              _mm_mul_ps(_mm_shuffle_ps(*(__m128 *)(a2 + 36), *(__m128 *)(a2 + 36), 192), v12)),
            _mm_mul_ps(_mm_shuffle_ps(*(__m128 *)(a2 + 40), *(__m128 *)(a2 + 40), 192), v13));
    _mm_stream_ps(
      a3,
      _mm_add_ps(
        _mm_add_ps(
          _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(*(__m128 *)a2, *(__m128 *)a2, 192), v5), v14),
          _mm_mul_ps(_mm_shuffle_ps(*(__m128 *)(a2 + 4), *(__m128 *)(a2 + 4), 192), v12)),
        _mm_mul_ps(_mm_shuffle_ps(*(__m128 *)(a2 + 8), *(__m128 *)(a2 + 8), 192), v13)));
    _mm_stream_ps(a3 + 4, v9);
    _mm_stream_ps(a3 + 8, v11);
    _mm_stream_ps(a3 + 12, v10);
    a2 += 64;
    a3 += 16;
    --a1;
  }
  while ( a1 );
}
// 10003AE0: could not find valid save-restore pair for ebp

//----- (10003C20) --------------------------------------------------------
void __cdecl sub_10003C20(int a1, int a2, float *a3, _DWORD *a4, int a5)
{
  float *v5; // eax
  int v6; // eax
  const char *v7; // esi
  const char *v8; // ecx
  const char *v9; // eax

  v5 = (float *)a2;
  if ( (a5 & 0xF) != 0 || (a2 & 0xF) != 0 || ((unsigned __int8)a3 & 0xF) != 0 )
  {
    if ( byte_100360DA )
    {
      v7 = byte_100360A8;
      if ( ((unsigned __int8)a3 & 0xF) != 0 )
        v7 = aDestvertices;
      v8 = byte_100360A8;
      if ( (a2 & 0xF) != 0 )
        v8 = aSourcevertices;
      v9 = byte_100360A8;
      if ( (a5 & 0xF) != 0 )
        v9 = aMatrixbuffer4x;
      sub_10017FE0(
        3,
        41,
        "%s(%d): SSE routine bypassed because the following pointers were not aligned: %s%s%s  (this message will only appear once)",
        aWPublicGrannyR,
        452,
        v9,
        v8,
        v7);
      v5 = (float *)a2;
      byte_100360DA = 0;
    }
    sub_10015E40(a1, v5, a3, a4, a5, 2);
  }
  else
  {
    sub_10003AE0(a1 >> 1, a2, a3, (__m128 *)(a5 + (*a4 << 6)));
    if ( (v6 & 1) != 0 )
      sub_10015E40(1, (float *)(32 * v6 + a2 - 32), &a3[8 * v6 - 8], a4, a5, 2);
  }
}
// 10003C5E: variable 'v6' is possibly undefined
// 100360A8: using guessed type _BYTE byte_100360A8[4];
// 100360DA: using guessed type char byte_100360DA;

//----- (10003D10) --------------------------------------------------------
void __cdecl sub_10003D10(int a1, int a2, float *a3, __m128 *a4)
{
  float *v4; // eax
  int v5; // eax
  const char *v6; // edi
  const char *v7; // ecx
  const char *v8; // eax

  v4 = (float *)a2;
  if ( ((unsigned __int8)a4 & 0xF) != 0 || (a2 & 0xF) != 0 || ((unsigned __int8)a3 & 0xF) != 0 )
  {
    if ( byte_100360DB )
    {
      v6 = byte_100360A8;
      if ( ((unsigned __int8)a3 & 0xF) != 0 )
        v6 = aDestvertices;
      v7 = byte_100360A8;
      if ( (a2 & 0xF) != 0 )
        v7 = aSourcevertices;
      v8 = byte_100360A8;
      if ( ((unsigned __int8)a4 & 0xF) != 0 )
        v8 = aMatrixbuffer4x;
      sub_10017FE0(
        3,
        41,
        "%s(%d): SSE routine bypassed because the following pointers were not aligned: %s%s%s  (this message will only appear once)",
        aWPublicGrannyR,
        489,
        v8,
        v7,
        v6);
      v4 = (float *)a2;
      byte_100360DB = 0;
    }
    sub_10015F80(a1, v4, a3, a4->m128_f32, 2);
  }
  else
  {
    sub_10003AE0(a1 >> 1, a2, a3, a4);
    if ( (v5 & 1) != 0 )
      sub_10015F80(1, (float *)(32 * v5 + a2 - 32), &a3[8 * v5 - 8], a4->m128_f32, 2);
  }
}
// 10003D42: variable 'v5' is possibly undefined
// 100360A8: using guessed type _BYTE byte_100360A8[4];
// 100360DB: using guessed type char byte_100360DB;

//----- (10003DE0) --------------------------------------------------------
char sub_10003DE0()
{
  char result; // al
  _DWORD v1[24]; // [esp+0h] [ebp-60h] BYREF

  result = sub_10003EA0();
  if ( result )
  {
    v1[4] = &unk_100357C8;
    v1[10] = &unk_100357C8;
    v1[16] = &unk_100357C8;
    v1[21] = &unk_100357C8;
    v1[22] = &unk_100357C8;
    v1[0] = 2;
    v1[1] = sub_10003740;
    v1[2] = sub_10003650;
    v1[3] = &unk_100358C8;
    v1[5] = 0;
    v1[6] = 2;
    v1[7] = sub_100038D0;
    v1[8] = sub_10003820;
    v1[9] = &unk_10035A08;
    v1[11] = 0;
    v1[12] = 2;
    v1[13] = sub_10003A30;
    v1[14] = sub_10003980;
    v1[15] = &unk_10035B68;
    v1[17] = 0;
    v1[18] = 2;
    v1[19] = sub_10003D10;
    v1[20] = sub_10003C20;
    v1[23] = 0;
    return sub_100123E0(4, v1);
  }
  return result;
}

//----- (10003EA0) --------------------------------------------------------
bool sub_10003EA0()
{
  unsigned int v0; // kr00_4
  unsigned int v1; // kr04_4
  char v8; // [esp+7h] [ebp-1h]

  v8 = 0;
  v0 = __readeflags();
  __writeeflags(v0 ^ 0x200000);
  v1 = __readeflags();
  __writeeflags(v0);
  if ( v1 != v0 )
  {
    _EAX = 1;
    __asm { cpuid }
    return (_EDX & 0x2000000) != 0;
  }
  return v8;
}

//----- (10003EE0) --------------------------------------------------------
char __cdecl sub_10003EE0(int a1, char *a2, int *a3)
{
  int v3; // edx

  *a3 = 0;
  if ( *(int *)(a1 + 12) <= 0 )
    return 0;
  while ( !sub_10021AC0(**(char ***)(*(_DWORD *)(a1 + 16) + 4 * *a3), a2) )
  {
    v3 = *a3 + 1;
    *a3 = v3;
    if ( v3 >= *(_DWORD *)(a1 + 12) )
      return 0;
  }
  return 1;
}

//----- (10003F40) --------------------------------------------------------
void __cdecl sub_10003F40(
        int a1,
        float a2,
        float *a3,
        float *a4,
        float *a5,
        float *a6,
        float *a7,
        float *a8,
        float *a9)
{
  int v9; // edi
  float v10; // ecx
  float v11; // edx
  float v12; // edx
  float v13; // ecx
  float v14; // edx
  float v15; // ecx
  float v16; // eax
  double v17; // st7
  double v18; // st6
  float v19; // edx
  int v20; // ecx
  float v21; // eax
  double v22; // st7
  int v23; // [esp+4h] [ebp-48h] BYREF
  float v24; // [esp+8h] [ebp-44h]
  float v25; // [esp+Ch] [ebp-40h]
  float v26; // [esp+10h] [ebp-3Ch]
  int v27; // [esp+14h] [ebp-38h]
  float v28; // [esp+18h] [ebp-34h]
  float v29; // [esp+1Ch] [ebp-30h]
  float v30; // [esp+20h] [ebp-2Ch]
  int v31; // [esp+24h] [ebp-28h]
  float v32[9]; // [esp+28h] [ebp-24h] BYREF

  v9 = *(_DWORD *)(a1 + 4);
  if ( v9 )
  {
    v10 = *a4;
    v11 = a4[1];
    v32[6] = a4[2];
    v32[3] = v11;
    v12 = a5[1];
    v32[0] = v10;
    v13 = *a5;
    v32[7] = a5[2];
    v32[4] = v12;
    v14 = a6[1];
    v32[1] = v13;
    v15 = *a6;
    v16 = a6[2];
    v32[5] = v14;
    v32[2] = v15;
    v32[8] = v16;
    v23 = *(_DWORD *)(v9 + 28);
    v17 = *(float *)(v9 + 32);
    v26 = *(float *)(v9 + 32);
    v29 = *(float *)(v9 + 36);
    v18 = *(float *)(v9 + 40);
    v24 = *(float *)(v9 + 40);
    v27 = *(_DWORD *)(v9 + 44);
    v30 = *(float *)(v9 + 48);
    v25 = *(float *)(v9 + 52);
    v19 = v29;
    v28 = *(float *)(v9 + 56);
    v20 = *(_DWORD *)(v9 + 60);
    v24 = v17;
    v21 = v30;
    v26 = v18;
    v31 = v20;
    v29 = v25;
    v25 = v19;
    v30 = v28;
    v28 = v21;
    sub_10018450(a8, v32, (float *)&v23);
    v22 = a2 / *(float *)(v9 + 12);
    *a8 = v22 * *a8;
    a8[1] = v22 * a8[1];
    a8[2] = v22 * a8[2];
    a8[3] = v22 * a8[3];
    a8[4] = v22 * a8[4];
    a8[5] = v22 * a8[5];
    a8[6] = v22 * a8[6];
    a8[7] = v22 * a8[7];
    a8[8] = v22 * a8[8];
    sub_100181D0(a9, a8);
    *a7 = *a3 - *(float *)(v9 + 16);
    a7[1] = a3[1] - *(float *)(v9 + 20);
    a7[2] = a3[2] - *(float *)(v9 + 24);
  }
  else
  {
    sub_10017FE0(3, 38, "%s(%d): FileInfo.ArtToolInfo is not allowed to be 0", aWPublicGrannyR_7, 76);
  }
}

//----- (100040C0) --------------------------------------------------------
int __usercall sub_100040C0@<eax>(double a1@<st0>, int a2, float *a3, float *a4, float *a5)
{
  int v5; // eax
  int i; // edi
  int v7; // eax
  int result; // eax
  int v9; // edi
  int v10; // ebx

  v5 = *(_DWORD *)(a2 + 4);
  if ( v5 )
    sub_10025690(a1, *(_DWORD *)(v5 + 4), *(_DWORD **)v5, *(char **)(v5 + 8), a3, a4, a5);
  for ( i = 0; i < *(_DWORD *)(a2 + 8); ++i )
  {
    v7 = *(_DWORD *)(*(_DWORD *)(a2 + 12) + 8 * i + 4);
    if ( v7 )
      sub_10025690(a1, *(_DWORD *)(v7 + 4), *(_DWORD **)v7, *(char **)(v7 + 8), a3, a4, a5);
  }
  if ( *(_DWORD *)(a2 + 16)
    && (a4[4] * a4[8] - a4[7] * a4[5]) * *a4
     - (a4[8] * a4[3] - a4[6] * a4[5]) * a4[1]
     + (a4[7] * a4[3] - a4[6] * a4[4]) * a4[2] < 0.0 )
  {
    sub_10024B40(*(_DWORD **)(a2 + 16));
  }
  result = *(_DWORD *)(a2 + 28);
  v9 = 0;
  if ( result > 0 )
  {
    v10 = 0;
    do
    {
      sub_1001A310(a3, a4, v10 + *(_DWORD *)(a2 + 32) + 4, (float *)(v10 + *(_DWORD *)(a2 + 32) + 16));
      result = *(_DWORD *)(a2 + 28);
      ++v9;
      v10 += 36;
    }
    while ( v9 < result );
  }
  return result;
}

//----- (100041C0) --------------------------------------------------------
int __cdecl sub_100041C0(int a1, float *a2, float *a3, float *a4)
{
  int result; // eax
  int v5; // ebx
  int v6; // esi

  result = *(_DWORD *)(a1 + 4);
  v5 = 0;
  if ( result > 0 )
  {
    v6 = 0;
    do
    {
      sub_10001820((float *)(*(_DWORD *)(a1 + 8) + v6 + 8), a2, a3, a4);
      sub_10019350(a2, a3, a4, (float *)(*(_DWORD *)(a1 + 8) + v6 + 76));
      result = *(_DWORD *)(a1 + 4);
      ++v5;
      v6 += 156;
    }
    while ( v5 < result );
  }
  return result;
}

//----- (10004220) --------------------------------------------------------
int __usercall sub_10004220@<eax>(double a1@<st0>, _DWORD *a2, float *a3, float *a4, float *a5)
{
  int v5; // eax
  int result; // eax
  int i; // esi
  int v8; // eax

  v5 = a2[1];
  if ( v5 )
    sub_100041C0(v5, a3, a4, a5);
  result = a2[19];
  for ( i = 0; i < result; ++i )
  {
    v8 = *(_DWORD *)(a2[20] + 4 * i);
    if ( v8 )
      sub_100040C0(a1, v8, a3, a4, a5);
    result = a2[19];
  }
  return result;
}

//----- (10004280) --------------------------------------------------------
int __cdecl sub_10004280(int a1, float *a2, float *a3, float *a4)
{
  int result; // eax
  int i; // esi
  int v6; // eax

  result = *(_DWORD *)(a1 + 12);
  for ( i = 0; i < result; ++i )
  {
    v6 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * i);
    if ( v6 )
      sub_10023CF0(v6, a2, a3, a4);
    result = *(_DWORD *)(a1 + 12);
  }
  return result;
}

//----- (100042D0) --------------------------------------------------------
int __usercall sub_100042D0@<eax>(double a1@<st0>, _DWORD *a2, float *a3, float *a4, float *a5)
{
  int i; // edi
  int v6; // eax
  int j; // edi
  int v8; // eax
  int result; // eax
  int k; // edi
  int v11; // eax

  for ( i = 0; i < a2[8]; ++i )
  {
    v6 = *(_DWORD *)(a2[9] + 4 * i);
    if ( v6 )
      sub_100041C0(v6, a3, a4, a5);
  }
  for ( j = 0; j < a2[14]; ++j )
  {
    v8 = *(_DWORD *)(a2[15] + 4 * j);
    if ( v8 )
      sub_100040C0(a1, v8, a3, a4, a5);
  }
  result = a2[20];
  for ( k = 0; k < result; ++k )
  {
    v11 = *(_DWORD *)(a2[21] + 4 * k);
    if ( v11 )
      sub_10004280(v11, a3, a4, a5);
    result = a2[20];
  }
  return result;
}

//----- (10004380) --------------------------------------------------------
unsigned int __cdecl sub_10004380(int a1, int a2)
{
  return ((((unsigned int)(a2 * a1) >> 3) + 271) & 0xFFFFFFF0) + 2 * a2 * a1 + 69632;
}

//----- (100043A0) --------------------------------------------------------
int __cdecl sub_100043A0(int a1)
{
  return *(_DWORD *)a1;
}

//----- (100043B0) --------------------------------------------------------
unsigned int __cdecl sub_100043B0(int a1, int a2, int a3, int a4)
{
  unsigned int result; // eax

  result = 3 * (a4 + 72 * a3);
  if ( result > 4 * a3 * a2 * a1 )
    result = 4 * a3 * a2 * a1;
  if ( result < (3 * a3 * ((unsigned int)(a2 * a1) >> 8)) >> 1 )
    result = (3 * a3 * ((unsigned int)(a2 * a1) >> 8)) >> 1;
  if ( result < 0x4000 )
    return 0x4000;
  return result;
}

//----- (10004400) --------------------------------------------------------
unsigned int *__cdecl sub_10004400(unsigned int *a1, unsigned int *a2)
{
  unsigned int *result; // eax

  *a1 = (*a1 + 15) & 0xFFFFFFF0;
  result = a2;
  *a2 = (*a2 + 15) & 0xFFFFFFF0;
  return result;
}

//----- (10004420) --------------------------------------------------------
unsigned int __cdecl sub_10004420(
        unsigned int *a1,
        int a2,
        int a3,
        int a4,
        unsigned int a5,
        unsigned int a6,
        unsigned int a7,
        int a8,
        unsigned int a9)
{
  unsigned int v9; // eax
  int v10; // edi
  unsigned int v11; // esi
  unsigned int v12; // esi
  unsigned int i; // eax
  unsigned int v14; // ebx

  v9 = sub_10004380(a6, a7);
  v10 = a8;
  v11 = v9;
  if ( !a8 || a9 < v9 )
  {
    a8 = 0;
    v10 = off_10033620((int)aWPublicGrannyR_0, 248, 4, v9);
    a9 = v11;
  }
  v12 = 0;
  if ( a5 )
  {
    for ( i = a7; ; i = a7 )
    {
      sub_10007C50(*(_DWORD *)(a3 + 4 * v12), 2 * a6, a6, i, v10);
      sub_10007C50(*(_DWORD *)(a3 + 4 * v12), 4 * a6, a6 >> 1, a7 >> 1, v10);
      sub_10007C50(*(_DWORD *)(a3 + 4 * v12), 8 * a6, a6 >> 2, a7 >> 2, v10);
      sub_10007C50(*(_DWORD *)(a3 + 4 * v12++), 16 * a6, a6 >> 3, a7 >> 3, v10);
      if ( v12 >= a5 )
        break;
    }
  }
  *a1 = 2 * a7 * a6;
  v14 = sub_100047B0(a1 + 1, a2, a3, a4, a5, a6, a7, v10, a9, a1);
  *a1 += (a7 + 15) & 0xFFFFFFF0;
  if ( !a8 )
    off_10033624((int)aWPublicGrannyR_0, 335, v10);
  return v14 + 4;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (100045B0) --------------------------------------------------------
int __cdecl sub_100045B0(int a1, unsigned int a2, int a3, unsigned int a4, unsigned int a5, _BYTE *a6, unsigned int a7)
{
  unsigned int v7; // eax
  unsigned int v8; // esi
  unsigned int v9; // eax
  int v10; // edi
  int result; // eax
  _DWORD *v13; // [esp+30h] [ebp+Ch]
  unsigned int v14; // [esp+34h] [ebp+10h]
  int v15; // [esp+40h] [ebp+1Ch]

  v7 = sub_100043A0(a3);
  v8 = 0;
  if ( a6 && a7 >= v7 )
  {
    v15 = (int)a6;
  }
  else
  {
    a6 = 0;
    v15 = off_10033620((int)aWPublicGrannyR_0, 358, 4, v7);
  }
  v9 = a5;
  v10 = v15 + ((a5 + 15) & 0xFFFFFFF0);
  v13 = (_DWORD *)(a3 + 4);
  if ( a2 )
  {
    v14 = a4 >> 3;
    while ( 1 )
    {
      v13 = (_DWORD *)((char *)v13 + sub_10006650(v13, *(char **)(a1 + 4 * v8), a4, v9, a6, v10));
      sub_10009700(*(_DWORD *)(a1 + 4 * v8), 16 * a4, v14, a5 >> 3, 0, v10);
      sub_10009700(*(_DWORD *)(a1 + 4 * v8), 8 * a4, a4 >> 2, a5 >> 2, 0, v10);
      sub_10009700(*(_DWORD *)(a1 + 4 * v8), 4 * a4, a4 >> 1, a5 >> 1, 0, v10);
      sub_10009700(*(_DWORD *)(a1 + 4 * v8++), 2 * a4, a4, a5, (int)a6, v10);
      if ( v8 >= a2 )
        break;
      v9 = a5;
    }
  }
  result = (int)a6;
  if ( !a6 )
    return off_10033624((int)aWPublicGrannyR_0, 386, v15);
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10004740) --------------------------------------------------------
unsigned int __cdecl sub_10004740(unsigned int a1, unsigned int a2, unsigned int *a3, unsigned int *a4)
{
  unsigned int result; // eax

  result = a1;
  if ( a1 < a4[2] )
  {
    if ( a1 < *a4 )
    {
      if ( a1 <= a2 - 4 )
      {
        *a3 = a1;
      }
      else
      {
        *a3 = a2 - 4;
        return a2 - 4;
      }
    }
    else if ( a1 < a4[1] )
    {
      *a3 = a2 - 3;
      return *a4;
    }
    else
    {
      *a3 = a2 - 2;
      return a4[1];
    }
  }
  else if ( a1 < a4[3] )
  {
    *a3 = a2 - 1;
    return a4[2];
  }
  else
  {
    *a3 = a2;
    return a4[3];
  }
  return result;
}

//----- (100047B0) --------------------------------------------------------
unsigned int __cdecl sub_100047B0(
        unsigned int *a1,
        int a2,
        int a3,
        int a4,
        unsigned int a5,
        unsigned int a6,
        unsigned int a7,
        int a8,
        unsigned int a9,
        unsigned int *a10)
{
  unsigned int v10; // esi
  unsigned int v11; // edi
  unsigned int v12; // eax
  unsigned int v13; // edi
  int v14; // ebx
  _DWORD *v15; // esi
  int v16; // ecx
  int v17; // ecx
  unsigned int v18; // edx
  int v19; // edx
  unsigned int v20; // edx
  int v21; // edx
  unsigned int v22; // edx
  int v23; // ecx
  bool v24; // zf
  unsigned int v25; // esi
  unsigned int v26; // edx
  int *v27; // eax
  int v28; // ecx
  int v29; // edi
  char *v30; // edi
  int *v31; // esi
  int v32; // ebx
  double *v33; // esi
  int v34; // ebx
  int v35; // edi
  unsigned int v36; // esi
  double *v37; // ebx
  unsigned int v38; // edx
  double *v39; // ecx
  double v40; // st7
  double v41; // st7
  double v42; // st7
  double *v43; // eax
  int v44; // ecx
  double v45; // st7
  int v46; // edx
  int v47; // ecx
  double v48; // st7
  unsigned int *v49; // edi
  unsigned int v50; // esi
  int v51; // ebx
  int v52; // eax
  int *v53; // esi
  int *v54; // edi
  int v55; // edx
  int v56; // esi
  unsigned int v57; // eax
  unsigned int v58; // ecx
  bool v59; // cc
  unsigned int v60; // ebx
  unsigned int v61; // edx
  int v62; // esi
  unsigned int v63; // eax
  unsigned int *v64; // esi
  unsigned int v65; // eax
  int v66; // edi
  unsigned int v67; // eax
  bool v68; // cf
  unsigned int v69; // eax
  __int16 *v71; // [esp-1Ch] [ebp-E4h]
  __int16 *v72; // [esp-18h] [ebp-E0h]
  int v73; // [esp-18h] [ebp-E0h]
  int v74; // [esp-14h] [ebp-DCh]
  unsigned int v75; // [esp-14h] [ebp-DCh]
  int v76; // [esp-10h] [ebp-D8h]
  unsigned int v77; // [esp-10h] [ebp-D8h]
  int v78; // [esp-Ch] [ebp-D4h]
  unsigned int v79; // [esp-Ch] [ebp-D4h]
  int v80; // [esp-8h] [ebp-D0h]
  _BYTE *v81; // [esp-8h] [ebp-D0h]
  int v82; // [esp+Ch] [ebp-BCh]
  int v83; // [esp+Ch] [ebp-BCh]
  unsigned int v84; // [esp+Ch] [ebp-BCh]
  int v85; // [esp+Ch] [ebp-BCh]
  unsigned int v86; // [esp+Ch] [ebp-BCh]
  unsigned int v87; // [esp+10h] [ebp-B8h]
  unsigned int v88; // [esp+10h] [ebp-B8h]
  int v89; // [esp+10h] [ebp-B8h]
  _DWORD *v90; // [esp+14h] [ebp-B4h]
  unsigned int v91; // [esp+18h] [ebp-B0h]
  int *v92; // [esp+1Ch] [ebp-ACh]
  unsigned int v93; // [esp+1Ch] [ebp-ACh]
  int *v94; // [esp+20h] [ebp-A8h] BYREF
  int *v95; // [esp+24h] [ebp-A4h]
  int v96; // [esp+28h] [ebp-A0h]
  unsigned int v97; // [esp+2Ch] [ebp-9Ch]
  int v98; // [esp+30h] [ebp-98h]
  int v99; // [esp+34h] [ebp-94h]
  unsigned int v100; // [esp+38h] [ebp-90h]
  unsigned int v101; // [esp+3Ch] [ebp-8Ch]
  _DWORD *v102; // [esp+40h] [ebp-88h] BYREF
  int v103; // [esp+44h] [ebp-84h]
  int v104; // [esp+48h] [ebp-80h]
  unsigned int v105; // [esp+4Ch] [ebp-7Ch]
  unsigned int v106; // [esp+50h] [ebp-78h]
  unsigned int v107; // [esp+54h] [ebp-74h]
  double v108; // [esp+58h] [ebp-70h]
  int v109; // [esp+60h] [ebp-68h]
  int v110; // [esp+64h] [ebp-64h]
  unsigned int v111; // [esp+68h] [ebp-60h]
  int v112; // [esp+6Ch] [ebp-5Ch]
  unsigned int v113; // [esp+70h] [ebp-58h]
  unsigned int v114; // [esp+74h] [ebp-54h]
  unsigned int v115; // [esp+78h] [ebp-50h]
  int v116; // [esp+7Ch] [ebp-4Ch]
  unsigned int *v117; // [esp+80h] [ebp-48h]
  int v118; // [esp+84h] [ebp-44h]
  int v119; // [esp+88h] [ebp-40h]
  int v120; // [esp+8Ch] [ebp-3Ch]
  unsigned int v121; // [esp+90h] [ebp-38h]
  int v122; // [esp+94h] [ebp-34h]
  double v123; // [esp+98h] [ebp-30h]
  double v124; // [esp+A0h] [ebp-28h]
  __int64 v125; // [esp+A8h] [ebp-20h]
  __int64 v126; // [esp+B0h] [ebp-18h]
  __int64 v127; // [esp+B8h] [ebp-10h]
  __int64 v128; // [esp+C0h] [ebp-8h]
  unsigned int v129; // [esp+D4h] [ebp+Ch]

  v129 = a2 + 72 * a5;
  v91 = 8 * v129;
  v120 = 8 * v129;
  v10 = (832 * a5 + 15) & 0xFFFFFFF0;
  v11 = (((a7 * a6) >> 3) + 143) & 0xFFFFFFF0;
  v12 = (2 * a7 * a6) >> 2;
  v122 = 0;
  v119 = 0;
  v109 = 0;
  v121 = -1;
  if ( a8 && v10 + v12 + v11 <= a9 )
  {
    v90 = (_DWORD *)(v11 + a8);
    v118 = a8;
    v115 = v10 + v11 + a8;
    a8 += v10 + v12 + v11;
    a9 -= v10 + v11 + v12;
  }
  else
  {
    v122 = off_10033620((int)aWPublicGrannyR_0, 1425, 4, v10 + v11 + v12);
    v118 = v122;
    v90 = (_DWORD *)(v11 + v122);
    v115 = v10 + v11 + v122;
  }
  v13 = 0;
  if ( a5 )
  {
    v107 = a6 >> 4;
    LODWORD(v108) = 2 * ((a6 >> 4) + 8 * a6);
    v101 = a6 >> 3;
    v117 = (unsigned int *)(2 * ((a6 >> 3) + 4 * a6));
    v87 = a6 >> 2;
    v113 = a7 >> 4;
    v112 = 2 * ((a6 >> 2) + 2 * a6);
    v110 = a7 >> 3;
    v14 = 16 * a6;
    v116 = 2 * ((a6 >> 1) + a6);
    v111 = a7 >> 2;
    v106 = a6 >> 1;
    v114 = a7 >> 1;
    v15 = v90 + 24;
    do
    {
      *(v15 - 16) = *(_DWORD *)(a3 + 4 * v13);
      v16 = v107;
      *v15 = 2 * v107 + *(_DWORD *)(a3 + 4 * v13);
      *(v15 - 14) = v16;
      v15[2] = v16;
      v15[18] = v16;
      v15[34] = v16;
      v17 = v113;
      *(v15 - 13) = v113;
      v15[3] = v17;
      v15[19] = v17;
      v15[35] = v17;
      *(v15 - 15) = v14;
      v15[1] = v14;
      v15[17] = v14;
      v15[33] = v14;
      v15[16] = v14 + *(_DWORD *)(a3 + 4 * v13);
      v15[32] = LODWORD(v108) + *(_DWORD *)(a3 + 4 * v13);
      v15[48] = 2 * v101 + *(_DWORD *)(a3 + 4 * v13);
      v18 = v101;
      v15[50] = v101;
      v15[66] = v18;
      v15[82] = v18;
      v19 = v110;
      v15[51] = v110;
      v15[67] = v19;
      v15[83] = v19;
      v15[49] = 8 * a6;
      v15[65] = 8 * a6;
      v15[81] = 8 * a6;
      v15[64] = 8 * a6 + *(_DWORD *)(a3 + 4 * v13);
      v15[80] = (char *)v117 + *(_DWORD *)(a3 + 4 * v13);
      v15[96] = 2 * v87 + *(_DWORD *)(a3 + 4 * v13);
      v15[98] = v87;
      v15[114] = v87;
      v15[130] = v87;
      v20 = v111;
      v15[97] = 4 * a6;
      v15[113] = 4 * a6;
      v15[129] = 4 * a6;
      v15[99] = v20;
      v15[115] = v20;
      v15[131] = v20;
      v15[112] = 4 * a6 + *(_DWORD *)(a3 + 4 * v13);
      v15[128] = v112 + *(_DWORD *)(a3 + 4 * v13);
      v15[144] = 2 * v106 + *(_DWORD *)(a3 + 4 * v13);
      v21 = v106;
      v15[146] = v106;
      v15[162] = v21;
      v15[178] = v21;
      v22 = v114;
      v15[145] = 2 * a6;
      v15[161] = 2 * a6;
      v15[177] = 2 * a6;
      v15[147] = v22;
      v15[163] = v22;
      v15[179] = v22;
      v23 = v116;
      v15[160] = 2 * a6 + *(_DWORD *)(a3 + 4 * v13);
      v15[176] = v23 + *(_DWORD *)(a3 + 4 * v13);
      v92 = v15 - 13;
      v82 = 13;
      do
      {
        v92[2] = sub_10005880((__int16 *)*(v92 - 3), *(v92 - 2), *(v92 - 1), *v92, v92 + 1);
        v24 = v82 == 1;
        v92 += 16;
        --v82;
      }
      while ( !v24 );
      ++v13;
      v15 += 208;
    }
    while ( v13 < a5 );
  }
  v25 = 0;
  if ( a5 )
  {
    v26 = a5;
    v27 = v90 + 12;
    do
    {
      v28 = 13;
      do
      {
        v29 = *v27;
        v27 += 16;
        --v28;
        v25 += 4 * v29 + 4;
      }
      while ( v28 );
      --v26;
    }
    while ( v26 );
    if ( v25 > a9 )
    {
      v119 = off_10033620((int)aWPublicGrannyR_0, 1495, 4, v25);
      a8 = v119;
      a9 = v25;
    }
  }
  while ( 1 )
  {
    while ( 1 )
    {
      v30 = (char *)a8;
      if ( a5 )
      {
        v31 = v90 + 12;
        v88 = a5;
        do
        {
          v83 = 13;
          do
          {
            v80 = *v31;
            v32 = 4 * *v31 + 4;
            v78 = *(v31 - 1);
            v76 = *(v31 - 2);
            v74 = *(v31 - 3);
            v72 = (__int16 *)*(v31 - 4);
            v31[2] = (int)v30;
            sub_10006470(v32, v72, v74, v76, v78, v80, v30);
            v30 += v32;
            v31 += 16;
            --v83;
          }
          while ( v83 );
          --v88;
        }
        while ( v88 );
      }
      v108 = 0.0;
      if ( a5 )
      {
        v33 = (double *)(v90 + 6);
        v84 = a5;
        do
        {
          v34 = 13;
          do
          {
            if ( !*((_DWORD *)v33 + 7) )
            {
              v77 = *((_DWORD *)v33 + 4) * *((_DWORD *)v33 + 5);
              v75 = *((_DWORD *)v33 + 6);
              v73 = *((_DWORD *)v33 + 8);
              *(_DWORD *)v33 = 1;
              sub_100064E0(v73, v75, v77, 1u, v33 - 3, (_DWORD *)v33 - 2);
              v108 = v108 + *(v33 - 3);
              sub_100065E0((_DWORD *)v33 - 6);
            }
            v33 += 8;
            --v34;
          }
          while ( v34 );
          --v84;
        }
        while ( v84 );
      }
      v126 = v91;
      v123 = (double)v91;
      if ( v108 <= v123 )
        v109 = 100;
      while ( 1 )
      {
        v116 = (int)v108;
        if ( (int)v108 <= v91 )
          break;
        v35 = -1;
        v36 = 0;
        v124 = 0.0;
        if ( !a5 )
          break;
        v37 = (double *)(v90 + 22);
        do
        {
          v38 = 1;
          v39 = v37;
          do
          {
            if ( *(_DWORD *)v39 <= *((_DWORD *)v39 + 6) && !*((_DWORD *)v39 + 7) )
            {
              v40 = *(v39 - 3) - *(v39 - 2);
              v128 = (unsigned int)(*((_DWORD *)v39 - 1) - *((_DWORD *)v39 - 2));
              v41 = v40 / ((double)v128 * *(float *)(a4 + 4 * v36));
              if ( v41 > v124 )
              {
                v124 = v41;
                v35 = v36;
                v114 = v38;
              }
            }
            ++v38;
            v39 += 8;
          }
          while ( v38 < 0xD );
          ++v36;
          v37 += 104;
        }
        while ( v36 < a5 );
        if ( v35 == -1 )
          break;
        v42 = v108;
        v43 = (double *)&v90[16 * (v114 + 13 * v35)];
        v44 = *((_DWORD *)v43 + 2);
        *((_DWORD *)v43 + 6) = *((_DWORD *)v43 + 7);
        v45 = v42 - *v43;
        v46 = *((_DWORD *)v43 + 3);
        *(_DWORD *)v43 = v44;
        v47 = *((_DWORD *)v43 + 5);
        v48 = v45 + v43[1];
        *((_DWORD *)v43 + 1) = v46;
        *((_DWORD *)v43 + 4) = v47;
        v108 = v48;
        sub_100065E0(v43);
      }
      v49 = a1;
      v50 = 0;
      v51 = 0;
      v93 = 0;
      v89 = 0;
      if ( a5 )
      {
        v113 = a7 >> 4;
        v107 = a6 >> 4;
        v52 = 16 * a6;
        v53 = v90 + 22;
        v112 = 16 * a6;
        v106 = a6 >> 1;
        v101 = (unsigned int)(v90 + 22);
        while ( 1 )
        {
          v97 = 0;
          v96 = 0;
          v100 = 0;
          v99 = 0;
          v105 = 0;
          v104 = 0;
          v103 = v118;
          v102 = (_DWORD *)v118;
          v71 = *(__int16 **)(a3 + 4 * v51);
          v117 = v49;
          v54 = (int *)(v49 + 2);
          v95 = v54;
          v94 = v54;
          v98 = 0x7FFFFFFF;
          sub_100052D0((int)&v94, (int)&v102, v71, v52, v107, v113, a8, a9, a10);
          v85 = 12;
          do
          {
            if ( v53[7] || (unsigned int)*v53 <= 1 )
            {
              sub_10005910((int)&v94, (unsigned int)&v102, v53[2], v53[3], v53[4], v53[5], 1, a8, a9, (unsigned int)a10);
            }
            else
            {
              sub_10006310(v115, (__int16 *)v53[2], v53[3], v53[4], v53[5], *v53);
              sub_10005910(
                (int)&v94,
                (unsigned int)&v102,
                v115,
                v53[4],
                v53[4],
                v53[5],
                *v53,
                a8,
                a9,
                (unsigned int)a10);
            }
            v53 += 16;
            --v85;
          }
          while ( v85 );
          sub_10006380((int)&v94, (_WORD *)(2 * v106 + *(_DWORD *)(a3 + 4 * v51)), 2 * a6, v106, a7, a8, a9);
          v55 = v99;
          v56 = v96;
          if ( (v99 & 0x20000000) != 0 )
            v56 = (1 << v97) | v96;
          v57 = v97 + 1;
          if ( v97 == 31 )
          {
            *v94 = v56;
            v55 = v99;
            ++v94;
            v57 = 0;
            v56 = 0;
          }
          v58 = v100 + 1;
          v59 = ++v100 <= 0x20;
          v86 = -((~v55 & 0x20000000) != 0);
          if ( !v59 )
          {
            do
            {
              v60 = v86 << v57;
              v57 += 32;
              v97 = v57;
              v56 |= v60;
              if ( v57 >= 0x20 )
              {
                *v94 = v56;
                v57 = v97 - 32;
                ++v94;
                if ( v97 == 32 )
                  v56 = 0;
                else
                  v56 = v86 >> (32 - v57);
              }
              v58 = v100 - 32;
              v100 -= 32;
            }
            while ( v100 > 0x20 );
          }
          v61 = v86 & dword_1002A3A8[v58];
          v111 = v58;
          v62 = (v61 << v57) | v56;
          v63 = v100 + v57;
          v96 = v62;
          v97 = v63;
          if ( v63 >= 0x20 )
          {
            *v94 = v62;
            v63 = v97 - 32;
            v24 = v97 == 32;
            ++v94;
            v97 -= 32;
            if ( v24 )
              v62 = 0;
            else
              v62 = v61 >> (v111 - v63);
            v96 = v62;
          }
          v100 = 0;
          if ( (-v63 & 0x1F) != 0 )
          {
            v63 += -v63 & 0x1F;
            v97 = v63;
            v96 = v62;
            if ( v63 >= 0x20 )
            {
              *v94 = v62;
              v63 = v97 - 32;
              ++v94;
              v97 -= 32;
              v96 = 0;
            }
          }
          if ( (-v105 & 0x1F) != 0 )
          {
            v105 += -v105 & 0x1F;
            if ( v105 >= 0x20 )
            {
              *v102 = v104;
              v105 -= 32;
              v63 = v97;
              ++v102;
              v104 = 0;
            }
          }
          v64 = v117;
          v65 = (((v63 + 8 * ((char *)v94 - (char *)v95)) >> 3) + 3) & 0xFFFFFFFC;
          *v117 = v65;
          v66 = (int)v54 + v65;
          v81 = (_BYTE *)v118;
          v79 = (((v105 + 8 * ((_DWORD)v102 - v103)) >> 3) + 3) & 0xFFFFFFFC;
          v64[1] = v79;
          sub_10019E10(v79, v81, v66);
          v67 = v64[1];
          v49 = (unsigned int *)(v67 + v66);
          v93 += v67 + *v64 + 8;
          v51 = v89 + 1;
          v53 = (int *)(v101 + 832);
          v68 = ++v89 < a5;
          v101 += 832;
          if ( !v68 )
            break;
          v52 = v112;
        }
        v50 = v93;
      }
      if ( (unsigned int)++v109 > 2 )
        break;
      v69 = abs32(v50 - v129);
      if ( v69 < v121 )
      {
        v121 = v69;
        v120 = v91;
        v109 = 0;
      }
      if ( 100 * v69 / v129 < 2 )
        break;
      v125 = v129;
      v127 = v50;
      v123 = (double)v129 * v123 / ((double)v50 * 8.0);
      v110 = (int)v123;
      v91 = 8 * (int)v123;
      if ( ((v91 >> 2) & 0x3FFFFFFE) > ((5 * v129) & 0xFFFFFFFE) )
        v91 = 20 * v129;
    }
    if ( v91 == v120 )
      break;
    v91 = v120;
  }
  if ( v122 )
    off_10033624((int)aWPublicGrannyR_0, 1730, v122);
  if ( v119 )
    off_10033624((int)aWPublicGrannyR_0, 1733, v119);
  return v50;
}
// 1002A3A8: using guessed type int dword_1002A3A8[6];
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (100052D0) --------------------------------------------------------
int __cdecl sub_100052D0(
        int a1,
        int a2,
        __int16 *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        unsigned int a8,
        unsigned int *a9)
{
  __int16 *v9; // ebp
  int result; // eax
  int v11; // ecx
  int v12; // esi
  int v13; // ebx
  unsigned int v14; // edx
  unsigned int v15; // ecx
  int v16; // esi
  int v17; // ebx
  int v18; // ecx
  bool v19; // zf
  int v20; // ecx
  int v21; // ebx
  unsigned int v23; // edi
  int v24; // eax
  unsigned int v25; // eax
  unsigned int v26; // ecx
  int v27; // edx
  int v28; // ecx
  int v29; // ecx
  int v30; // eax
  int v31; // eax
  int v32; // edi
  unsigned int v33; // eax
  int v34; // edx
  unsigned int v35; // ecx
  unsigned int v36; // eax
  int v37; // ebx
  __int16 *v38; // ebp
  int v39; // ecx
  int v40; // ecx
  int v41; // ebx
  unsigned int v42; // edi
  int v43; // edx
  int v44; // eax
  __int16 *v45; // ebp
  int v46; // ebx
  unsigned int v47; // edi
  int v48; // eax
  int v49; // ecx
  __int16 *v50; // ebx
  int v51; // ebx
  unsigned int v52; // edi
  int v53; // ecx
  unsigned int v54; // [esp+10h] [ebp-Ch]
  unsigned int v55; // [esp+14h] [ebp-8h]
  int v56; // [esp+14h] [ebp-8h]
  int v57; // [esp+18h] [ebp-4h]
  int v58; // [esp+24h] [ebp+8h]
  int v59; // [esp+24h] [ebp+8h]

  v9 = a3;
  if ( sub_10005750(a3, a4, a5, a6, (int *)&a3) )
  {
    result = a2;
    v11 = *(_DWORD *)(a2 + 12);
    v12 = (1 << v11++) | *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a2 + 8) = v12;
    *(_DWORD *)(a2 + 12) = v11;
    if ( v11 == 32 )
    {
      **(_DWORD **)a2 = v12;
      *(_DWORD *)a2 += 4;
      *(_DWORD *)(a2 + 12) = 0;
      *(_DWORD *)(a2 + 8) = 0;
    }
    v13 = *(_DWORD *)(a2 + 8);
    v14 = (unsigned __int16)*v9;
    v15 = *(_DWORD *)(a2 + 12);
    v16 = v14 << v15;
    v15 += 16;
    *(_DWORD *)(a2 + 12) = v15;
    v17 = v16 | v13;
    *(_DWORD *)(a2 + 8) = v17;
    if ( v15 >= 0x20 )
    {
      **(_DWORD **)a2 = v17;
      v18 = *(_DWORD *)(a2 + 12);
      v19 = v18 == 32;
      v20 = v18 - 32;
      *(_DWORD *)a2 += 4;
      *(_DWORD *)(a2 + 12) = v20;
      if ( v19 )
        *(_DWORD *)(a2 + 8) = 0;
      else
        *(_DWORD *)(a2 + 8) = v14 >> (16 - v20);
    }
  }
  else
  {
    v21 = (int)a3 + 1;
    v54 = (unsigned int)a3 + 1;
    v55 = sub_1000E0B0((int)a3 + 1);
    v23 = sub_1000E070((int)a3, v21);
    v24 = *(_DWORD *)(a2 + 12) + 1;
    *(_DWORD *)(a2 + 12) = v24;
    if ( v24 == 32 )
    {
      **(_DWORD **)a2 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)a2 += 4;
      *(_DWORD *)(a2 + 12) = 0;
      *(_DWORD *)(a2 + 8) = 0;
    }
    v25 = (unsigned __int16)a3;
    v26 = *(_DWORD *)(a2 + 12);
    v27 = (unsigned __int16)a3 << v26;
    v26 += 16;
    *(_DWORD *)(a2 + 12) = v26;
    *(_DWORD *)(a2 + 8) |= v27;
    if ( v26 >= 0x20 )
    {
      **(_DWORD **)a2 = *(_DWORD *)(a2 + 8);
      v28 = *(_DWORD *)(a2 + 12);
      v19 = v28 == 32;
      v29 = v28 - 32;
      *(_DWORD *)a2 += 4;
      *(_DWORD *)(a2 + 12) = v29;
      if ( v19 )
        *(_DWORD *)(a2 + 8) = 0;
      else
        *(_DWORD *)(a2 + 8) = v25 >> (16 - v29);
    }
    v30 = a7;
    if ( a7 && v23 + v55 <= a8 )
    {
      a8 = 0;
    }
    else
    {
      v30 = off_10033620((int)aWPublicGrannyR_0, 509, 4, v23 + v55);
      a8 = v30;
    }
    v31 = sub_1000E0C0(v30, v30 + v23, (int)a3, v21);
    v32 = a4 - a5;
    a7 = v31;
    v56 = a4 - a5;
    v33 = sub_1000E090(v21);
    if ( v33 > *a9 )
      *a9 = v33;
    v34 = *v9;
    v35 = *(_DWORD *)(a2 + 12);
    v36 = (unsigned __int16)*v9;
    v37 = v36 << v35;
    v35 += 16;
    v38 = v9 + 1;
    v58 = v34;
    *(_DWORD *)(a2 + 8) |= v37;
    *(_DWORD *)(a2 + 12) = v35;
    if ( v35 >= 0x20 )
    {
      **(_DWORD **)a2 = *(_DWORD *)(a2 + 8);
      v39 = *(_DWORD *)(a2 + 12);
      v19 = v39 == 32;
      v40 = v39 - 32;
      *(_DWORD *)a2 += 4;
      *(_DWORD *)(a2 + 12) = v40;
      if ( v19 )
        *(_DWORD *)(a2 + 8) = 0;
      else
        *(_DWORD *)(a2 + 8) = v36 >> (16 - v40);
    }
    v57 = a5 - 1;
    if ( a5 != 1 )
    {
      --a5;
      while ( 1 )
      {
        v41 = *v38 - v34;
        v42 = abs32(v41);
        ++v38;
        if ( (unsigned int)sub_1000E270(v41, a7, a1, v42) > 0x10000 )
          sub_1000DD90(a1, v42, v54);
        if ( v41 )
        {
          if ( v41 < 0 )
            *(_DWORD *)(a2 + 8) |= 1 << *(_DWORD *)(a2 + 12);
          v43 = *(_DWORD *)(a2 + 12) + 1;
          *(_DWORD *)(a2 + 12) = v43;
          if ( v43 == 32 )
          {
            **(_DWORD **)a2 = *(_DWORD *)(a2 + 8);
            *(_DWORD *)a2 += 4;
            *(_DWORD *)(a2 + 12) = 0;
            *(_DWORD *)(a2 + 8) = 0;
          }
        }
        v19 = a5 == 1;
        v58 += v41;
        --a5;
        if ( v19 )
          break;
        v34 = v58;
      }
      v32 = v56;
    }
    v44 = a6 - 1;
    if ( a6 != 1 )
    {
      a6 = 2 * v32;
      a9 = (unsigned int *)(2 * a4);
      v59 = v44;
      do
      {
        v45 = &v38[a6 / 2u];
        v46 = (char *)v45 - (char *)a9;
        a5 = *v45 - *(__int16 *)((char *)v45 - (char *)a9);
        v47 = abs32(a5);
        if ( (unsigned int)sub_1000E270((char *)v45 - (char *)a9, a7, a1, v47) > 0x10000 )
          sub_1000DD90(a1, v47, v54);
        if ( a5 )
        {
          if ( a5 < 0 )
            *(_DWORD *)(a2 + 8) |= 1 << *(_DWORD *)(a2 + 12);
          v48 = *(_DWORD *)(a2 + 12) + 1;
          *(_DWORD *)(a2 + 12) = v48;
          if ( v48 == 32 )
          {
            **(_DWORD **)a2 = *(_DWORD *)(a2 + 8);
            *(_DWORD *)a2 += 4;
            *(_DWORD *)(a2 + 12) = 0;
            *(_DWORD *)(a2 + 8) = 0;
          }
        }
        v49 = *v45;
        v50 = (__int16 *)(v46 + 2);
        v38 = v45 + 1;
        a5 = (int)v50;
        if ( v57 )
        {
          a4 = v57;
          while ( 1 )
          {
            v51 = *v38 - (v49 + *v50) / 2;
            v52 = abs32(v51);
            if ( (unsigned int)sub_1000E270(v51, a7, a1, v52) > 0x10000 )
              sub_1000DD90(a1, v52, v54);
            if ( v51 )
            {
              if ( v51 < 0 )
                *(_DWORD *)(a2 + 8) |= 1 << *(_DWORD *)(a2 + 12);
              v53 = *(_DWORD *)(a2 + 12) + 1;
              *(_DWORD *)(a2 + 12) = v53;
              if ( v53 == 32 )
              {
                **(_DWORD **)a2 = *(_DWORD *)(a2 + 8);
                *(_DWORD *)a2 += 4;
                *(_DWORD *)(a2 + 12) = 0;
                *(_DWORD *)(a2 + 8) = 0;
              }
            }
            v49 = *v38++;
            v19 = a4 == 1;
            a5 += 2;
            --a4;
            if ( v19 )
              break;
            v50 = (__int16 *)a5;
          }
        }
        --v59;
      }
      while ( v59 );
    }
    result = a8;
    if ( a8 )
      return off_10033624((int)aWPublicGrannyR_0, 599, a8);
  }
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10005750) --------------------------------------------------------
int __cdecl sub_10005750(__int16 *a1, int a2, int a3, int a4, int *a5)
{
  int v5; // ebp
  int v6; // edi
  __int16 *v7; // ecx
  int v8; // ebx
  int v9; // edx
  int v10; // esi
  signed int v11; // eax
  int v12; // eax
  __int16 *v13; // ecx
  __int16 *v14; // esi
  int v15; // edi
  __int64 v16; // rax
  int v17; // eax
  int v18; // edx
  __int16 *v19; // esi
  int v20; // edi
  __int64 v21; // rax
  int v22; // eax
  int v24; // [esp+10h] [ebp-8h]
  int v25; // [esp+14h] [ebp-4h]
  int v26; // [esp+1Ch] [ebp+4h]
  int v27; // [esp+20h] [ebp+8h]
  int v28; // [esp+24h] [ebp+Ch]
  int v29; // [esp+24h] [ebp+Ch]
  int v30; // [esp+28h] [ebp+10h]

  v5 = *a1;
  v6 = a2 - a3;
  v7 = a1 + 1;
  v8 = -32768;
  v24 = 1;
  v9 = v5;
  v25 = a3 - 1;
  if ( a3 != 1 )
  {
    v28 = a3 - 1;
    do
    {
      v10 = *v7;
      v11 = abs32(v10 - v9);
      if ( v11 > v8 )
        v8 = v11;
      v9 = *v7++;
      if ( v5 != v10 )
        v24 = 0;
      --v28;
    }
    while ( v28 );
  }
  v12 = a4 - 1;
  if ( a4 != 1 )
  {
    v26 = v6;
    v30 = 2 * a2;
    v29 = v12;
    do
    {
      v13 = &v7[v26];
      v14 = &v13[v30 / 0xFFFFFFFE];
      v15 = *v13;
      v16 = v15 - v13[v30 / 0xFFFFFFFE];
      v17 = (HIDWORD(v16) ^ v16) - HIDWORD(v16);
      if ( v17 > v8 )
        v8 = v17;
      v18 = *v13;
      v7 = v13 + 1;
      if ( v5 != v15 )
        v24 = 0;
      v19 = v14 + 1;
      if ( v25 )
      {
        v27 = v25;
        do
        {
          v20 = *v7;
          v21 = v20 - (v18 + *v19) / 2;
          v22 = (HIDWORD(v21) ^ v21) - HIDWORD(v21);
          if ( v22 > v8 )
            v8 = v22;
          v18 = *v7++;
          if ( v5 != v20 )
            v24 = 0;
          ++v19;
          --v27;
        }
        while ( v27 );
      }
      --v29;
    }
    while ( v29 );
  }
  if ( a5 )
    *a5 = v8;
  return v24;
}

//----- (10005880) --------------------------------------------------------
int __cdecl sub_10005880(__int16 *a1, int a2, int a3, int a4, int *a5)
{
  int v5; // ebx
  __int16 *v6; // esi
  int v8; // edi
  int v9; // ebp
  int v10; // eax
  int v12; // [esp+14h] [ebp+4h]
  int v13; // [esp+18h] [ebp+8h]
  int v14; // [esp+20h] [ebp+10h]

  v5 = a3;
  v6 = a1;
  v12 = *a1;
  v8 = -32768;
  v9 = 1;
  if ( a4 )
  {
    v14 = 2 * (a2 - a3);
    v13 = a4;
    do
    {
      if ( v5 )
      {
        do
        {
          v10 = abs16(*v6);
          if ( v10 > v8 )
            v8 = v10;
          if ( v12 != *v6 )
            v9 = 0;
          ++v6;
          --v5;
        }
        while ( v5 );
        v5 = a3;
      }
      v6 = (__int16 *)((char *)v6 + v14);
      --v13;
    }
    while ( v13 );
  }
  if ( a5 )
    *a5 = v8;
  return v9;
}

//----- (10005910) --------------------------------------------------------
int __cdecl sub_10005910(
        int a1,
        unsigned int a2,
        unsigned int a3,
        int a4,
        unsigned int a5,
        unsigned int a6,
        int a7,
        unsigned int a8,
        unsigned int a9,
        unsigned int a10)
{
  int v10; // ebx
  unsigned int v11; // edi
  unsigned int v12; // ecx
  int v13; // esi
  unsigned int v14; // eax
  int v15; // edx
  int v16; // ecx
  bool v17; // zf
  int v18; // ecx
  __int16 *v19; // ebp
  int v20; // ecx
  int v21; // ebx
  int v22; // ebx
  int v23; // ebp
  int result; // eax
  unsigned int v25; // ecx
  int v26; // edx
  int v27; // ebp
  int v28; // ecx
  int v29; // ecx
  int v30; // edx
  unsigned int v31; // eax
  unsigned int v32; // esi
  int v33; // eax
  int v34; // ecx
  unsigned int v35; // ecx
  int v36; // ecx
  int v37; // ecx
  int v38; // eax
  int v39; // ebx
  int v40; // eax
  unsigned int v41; // eax
  __int16 *v42; // esi
  _WORD *v43; // ebp
  unsigned int v44; // eax
  unsigned int v45; // ecx
  int v46; // ecx
  int v47; // ecx
  unsigned int v48; // eax
  unsigned int v49; // eax
  unsigned int v50; // ecx
  int v51; // ecx
  int v52; // ecx
  int v53; // esi
  unsigned int v54; // ecx
  int v55; // ecx
  unsigned int v56; // ebx
  int v57; // eax
  __int16 *v58; // esi
  int v59; // edx
  unsigned int v60; // ecx
  int v61; // ecx
  int v62; // eax
  int v63; // edx
  unsigned int v64; // eax
  _WORD *v65; // ebp
  __int16 *v66; // esi
  int v67; // eax
  unsigned int v68; // [esp+10h] [ebp-2Ch] BYREF
  int v69; // [esp+14h] [ebp-28h]
  unsigned int v70; // [esp+18h] [ebp-24h]
  int v71; // [esp+1Ch] [ebp-20h]
  int v72; // [esp+20h] [ebp-1Ch] BYREF
  unsigned int v73; // [esp+24h] [ebp-18h]
  unsigned int v74; // [esp+28h] [ebp-14h]
  int v75; // [esp+2Ch] [ebp-10h]
  int v76; // [esp+30h] [ebp-Ch] BYREF
  int v77; // [esp+34h] [ebp-8h] BYREF
  int v78; // [esp+38h] [ebp-4h]

  v10 = a7;
  v11 = a2;
  v12 = *(_DWORD *)(a2 + 12);
  v13 = *(_DWORD *)(a2 + 8);
  v14 = (unsigned __int16)a7;
  v15 = (unsigned __int16)a7 << v12;
  v12 += 16;
  *(_DWORD *)(a2 + 12) = v12;
  *(_DWORD *)(v11 + 8) = v15 | v13;
  if ( v12 >= 0x20 )
  {
    **(_DWORD **)v11 = *(_DWORD *)(v11 + 8);
    v16 = *(_DWORD *)(v11 + 12);
    v17 = v16 == 32;
    v18 = v16 - 32;
    *(_DWORD *)v11 += 4;
    *(_DWORD *)(v11 + 12) = v18;
    if ( v17 )
      *(_DWORD *)(v11 + 8) = 0;
    else
      *(_DWORD *)(v11 + 8) = v14 >> (16 - v18);
  }
  v19 = (__int16 *)a3;
  if ( sub_10005880((__int16 *)a3, a4, a5, a6, (int *)&a3) )
  {
    v20 = *(_DWORD *)(v11 + 12);
    v21 = *(_DWORD *)(v11 + 8);
    *(_DWORD *)(v11 + 12) = v20 + 1;
    v22 = (1 << v20) | v21;
    *(_DWORD *)(v11 + 8) = v22;
    if ( v20 == 31 )
    {
      **(_DWORD **)v11 = v22;
      *(_DWORD *)v11 += 4;
      *(_DWORD *)(v11 + 12) = 0;
      *(_DWORD *)(v11 + 8) = 0;
    }
    LOWORD(result) = *v19;
    v23 = *(_DWORD *)(v11 + 8);
    result = (unsigned __int16)result;
    v25 = *(_DWORD *)(v11 + 12);
    v26 = (unsigned __int16)result << v25;
    v25 += 16;
    *(_DWORD *)(v11 + 12) = v25;
    v27 = v26 | v23;
    *(_DWORD *)(v11 + 8) = v27;
    if ( v25 >= 0x20 )
    {
      **(_DWORD **)v11 = v27;
      v28 = *(_DWORD *)(v11 + 12);
      v17 = v28 == 32;
      v29 = v28 - 32;
      *(_DWORD *)v11 += 4;
      *(_DWORD *)(v11 + 12) = v29;
      if ( v17 )
      {
        *(_DWORD *)(v11 + 8) = 0;
      }
      else
      {
        result = (unsigned __int16)result >> (16 - v29);
        *(_DWORD *)(v11 + 8) = result;
      }
    }
  }
  else
  {
    v30 = a3;
    v31 = v10 * a3;
    v32 = a3 + 1;
    v73 = a3 + 1;
    if ( v10 * a3 > 0x80 )
    {
      if ( v31 < 0x800 )
      {
        if ( v31 < 0x200 )
          v33 = 9 - (v31 < 0x100);
        else
          v33 = 11 - (v31 < 0x400);
      }
      else if ( v31 < 0x2000 )
      {
        v33 = 13 - (v31 < 0x1000);
      }
      else
      {
        v33 = 15 - (v31 < 0x4000);
      }
    }
    else
    {
      v33 = (unsigned __int8)byte_1002A430[v31];
    }
    v34 = *(_DWORD *)(v11 + 12) + 1;
    a3 = v33 + 1;
    *(_DWORD *)(v11 + 12) = v34;
    if ( v34 == 32 )
    {
      **(_DWORD **)v11 = *(_DWORD *)(v11 + 8);
      *(_DWORD *)v11 += 4;
      *(_DWORD *)(v11 + 12) = 0;
      *(_DWORD *)(v11 + 8) = 0;
    }
    *(_DWORD *)(v11 + 8) |= (unsigned __int16)v30 << *(_DWORD *)(v11 + 12);
    v35 = *(_DWORD *)(v11 + 12) + 16;
    *(_DWORD *)(v11 + 12) = v35;
    if ( v35 >= 0x20 )
    {
      **(_DWORD **)v11 = *(_DWORD *)(v11 + 8);
      v36 = *(_DWORD *)(v11 + 12);
      v17 = v36 == 32;
      v37 = v36 - 32;
      *(_DWORD *)v11 += 4;
      *(_DWORD *)(v11 + 12) = v37;
      if ( v17 )
        *(_DWORD *)(v11 + 8) = 0;
      else
        *(_DWORD *)(v11 + 8) = (unsigned __int16)v30 >> (16 - v37);
    }
    v38 = sub_100060B0((int)&v72, &v76, &v77, v30, v32, a3, a8, a9, (unsigned int *)a10);
    v39 = *v19;
    v75 = v38;
    v74 = a4 - a5;
    v70 = a6;
    sub_1000DD90(a1, abs32(v39), v32);
    if ( v39 )
    {
      if ( v39 < 0 )
        *(_DWORD *)(v11 + 8) |= 1 << *(_DWORD *)(v11 + 12);
      v40 = *(_DWORD *)(v11 + 12) + 1;
      *(_DWORD *)(v11 + 12) = v40;
      if ( v40 == 32 )
      {
        **(_DWORD **)v11 = *(_DWORD *)(v11 + 8);
        *(_DWORD *)v11 += 4;
        *(_DWORD *)(v11 + 12) = 0;
        *(_DWORD *)(v11 + 8) = 0;
      }
    }
    v41 = 0;
    v42 = v19;
    v43 = v19 + 1;
    v69 = v39;
    a8 = v39;
    a10 = 0;
    a9 = 0;
    v68 = 0;
    a2 = 0;
    if ( a5 == 1 )
      goto LABEL_73;
    a6 = a5 - 1;
LABEL_35:
    if ( !(v68 | v41) )
      sub_10006210(v43, a4, a6, v70, a5, &v68, &a2);
    a10 = sub_10004740(v68, 0x3Fu, &a3, dword_10030E58);
    v68 -= a10;
    if ( (unsigned int)sub_1000E270(v39, v76, a1, a3) > 0x10000 )
    {
      v44 = a3 & 0x3F;
      *(_DWORD *)(v11 + 8) |= v44 << *(_DWORD *)(v11 + 12);
      v45 = *(_DWORD *)(v11 + 12) + 6;
      *(_DWORD *)(v11 + 12) = v45;
      if ( v45 >= 0x20 )
      {
        **(_DWORD **)v11 = *(_DWORD *)(v11 + 8);
        v46 = *(_DWORD *)(v11 + 12);
        v17 = v46 == 32;
        v47 = v46 - 32;
        *(_DWORD *)v11 += 4;
        *(_DWORD *)(v11 + 12) = v47;
        if ( v17 )
          *(_DWORD *)(v11 + 8) = 0;
        else
          *(_DWORD *)(v11 + 8) = v44 >> (6 - v47);
      }
    }
    v48 = 0;
    if ( !a2 || v68 )
      a3 = 0;
    else
      v48 = sub_10004740(a2 - 2, 0xFFu, &a3, dword_10030E68) + 2;
    a9 = v48;
    a2 -= v48;
    if ( a2 < 3 )
      a2 = 0;
    if ( (unsigned int)sub_1000E270(v39, v77, a1, a3) > 0x10000 )
    {
      v49 = (unsigned __int8)a3;
      *(_DWORD *)(v11 + 8) |= (unsigned __int8)a3 << *(_DWORD *)(v11 + 12);
      v50 = *(_DWORD *)(v11 + 12) + 8;
      *(_DWORD *)(v11 + 12) = v50;
      if ( v50 >= 0x20 )
      {
        **(_DWORD **)v11 = *(_DWORD *)(v11 + 8);
        v51 = *(_DWORD *)(v11 + 12);
        v17 = v51 == 32;
        v52 = v51 - 32;
        *(_DWORD *)v11 += 4;
        *(_DWORD *)(v11 + 12) = v52;
        if ( v17 )
          *(_DWORD *)(v11 + 8) = 0;
        else
          *(_DWORD *)(v11 + 8) = v49 >> (8 - v52);
      }
    }
    while ( 1 )
    {
      while ( 1 )
      {
        if ( !a10 )
        {
          if ( a9 )
          {
            while ( a9 >= a6 )
            {
              if ( !--v70 )
                goto LABEL_98;
              v64 = a9 - a6;
              v65 = &v43[a6];
              a6 = a5;
              v43 = &v65[v74];
              v66 = &v43[-a4];
              v39 = *v66;
              v42 = v66 + 1;
              a9 = v64;
              v69 = v39;
              a8 = v39;
              if ( !v64 )
                goto LABEL_34;
            }
            v39 = v42[a9 - 1];
            v43 += a9;
            v42 += a9;
            v67 = *(v42 - 2);
            a6 -= a9;
            a8 = 0;
            v69 = v67;
          }
LABEL_34:
          v41 = a2;
          goto LABEL_35;
        }
        if ( a6 <= 1 )
          break;
        v59 = (__int16)*v43;
        v78 = *v42;
        v71 = v59;
        v60 = (a7 * (abs32(v39) + abs32(v69) + abs32(a8) + abs32(v78))) >> 2;
        if ( v60 > 0x80 )
        {
          if ( v60 < 0x800 )
          {
            if ( v60 < 0x200 )
              v61 = 9 - (v60 < 0x100);
            else
              v61 = 11 - (v60 < 0x400);
          }
          else if ( v60 < 0x2000 )
          {
            v61 = 13 - (v60 < 0x1000);
          }
          else
          {
            v61 = 15 - (v60 < 0x4000);
          }
        }
        else
        {
          v61 = (unsigned __int8)byte_1002A430[v60];
        }
        a8 = abs32(v71);
        if ( (unsigned int)sub_1000E270(v39, *(_DWORD *)(v72 + 4 * v61), a1, a8) > 0x10000 )
          sub_1000DD90(a1, a8, v73);
        v62 = v71;
        if ( v71 )
        {
          if ( v71 < 0 )
            *(_DWORD *)(v11 + 8) |= 1 << *(_DWORD *)(v11 + 12);
          v63 = *(_DWORD *)(v11 + 12) + 1;
          *(_DWORD *)(v11 + 12) = v63;
          if ( v63 == 32 )
          {
            **(_DWORD **)v11 = *(_DWORD *)(v11 + 8);
            *(_DWORD *)v11 += 4;
            *(_DWORD *)(v11 + 12) = 0;
            *(_DWORD *)(v11 + 8) = 0;
          }
        }
        a8 = v62;
        ++v43;
        ++v42;
        v69 = v39;
        v39 = v78;
        --a6;
        --a10;
      }
      if ( a6 )
      {
        v53 = (__int16)*v43;
        v54 = (a7 * (abs32(v39) + abs32(v69) + abs32(2 * a8))) >> 2;
        ++v43;
        v71 = v53;
        if ( v54 > 0x80 )
        {
          if ( v54 < 0x800 )
          {
            if ( v54 < 0x200 )
              v55 = 9 - (v54 < 0x100);
            else
              v55 = 11 - (v54 < 0x400);
          }
          else if ( v54 < 0x2000 )
          {
            v55 = 13 - (v54 < 0x1000);
          }
          else
          {
            v55 = 15 - (v54 < 0x4000);
          }
        }
        else
        {
          v55 = (unsigned __int8)byte_1002A430[v54];
        }
        v56 = abs32(v53);
        if ( (unsigned int)sub_1000E270(v56, *(_DWORD *)(v72 + 4 * v55), a1, v56) > 0x10000 )
          sub_1000DD90(a1, v56, v73);
        if ( v71 )
        {
          if ( v71 < 0 )
            *(_DWORD *)(v11 + 8) |= 1 << *(_DWORD *)(v11 + 12);
          v57 = *(_DWORD *)(v11 + 12) + 1;
          *(_DWORD *)(v11 + 12) = v57;
          if ( v57 == 32 )
          {
            **(_DWORD **)v11 = *(_DWORD *)(v11 + 8);
            *(_DWORD *)v11 += 4;
            *(_DWORD *)(v11 + 12) = 0;
            *(_DWORD *)(v11 + 8) = 0;
          }
        }
        --a10;
      }
LABEL_73:
      if ( !--v70 )
        break;
      v43 += v74;
      a6 = a5;
      v58 = &v43[-a4];
      v39 = *v58;
      v42 = v58 + 1;
      v69 = v39;
      a8 = v39;
    }
LABEL_98:
    result = v75;
    if ( v75 )
      return off_10033624((int)aWPublicGrannyR_0, 1105, v75);
  }
  return result;
}
// 10030E58: using guessed type unsigned int dword_10030E58[4];
// 10030E68: using guessed type unsigned int dword_10030E68[4];
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (100060B0) --------------------------------------------------------
int __cdecl sub_100060B0(
        int a1,
        int *a2,
        int *a3,
        int a4,
        unsigned int a5,
        unsigned int a6,
        int a7,
        unsigned int a8,
        unsigned int *a9)
{
  int v9; // eax
  unsigned int v10; // ebx
  unsigned int v11; // esi
  int v12; // eax
  int v13; // ebp
  int v14; // esi
  unsigned int v15; // ebx
  unsigned int v16; // ebx
  unsigned int v17; // esi
  unsigned int v18; // eax
  unsigned int v20; // [esp+10h] [ebp-8h]
  unsigned int v21; // [esp+14h] [ebp-4h]

  v9 = a5;
  if ( a5 < 0x100 )
    v9 = 256;
  v10 = sub_1000E0B0(v9);
  v20 = sub_1000E070(a4, a5);
  v21 = sub_1000E070(63, 64);
  v11 = sub_1000E070(255, 256) + v21 + a6 * (v20 + 4);
  if ( a7 && ((v11 + v10 + 15) & 0xFFFFFFF0) <= a8 )
  {
    v12 = a7;
  }
  else
  {
    a7 = 0;
    v12 = off_10033620((int)aWPublicGrannyR_0, 671, 4, (v11 + v10 + 15) & 0xFFFFFFF0);
  }
  v13 = v12 + 4 * a6;
  v14 = v10 + v13;
  v15 = 0;
  for ( *(_DWORD *)a1 = v12; v15 < a6; ++v15 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 4 * v15) = sub_1000E0C0(v14, v13, a4, a5);
    v14 += v20;
  }
  *a2 = sub_1000E0C0(v14, v13, 63, 64);
  *a3 = sub_1000E0C0(v21 + v14, v13, 255, 256);
  v16 = sub_1000E090(a5);
  v17 = sub_1000E090(64);
  v18 = (a6 * (v16 + 4) + sub_1000E090(256) + v17 + 15) & 0xFFFFFFF0;
  if ( v18 > *a9 )
    *a9 = v18;
  if ( a7 )
    return 0;
  else
    return *(_DWORD *)a1;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (10006210) --------------------------------------------------------
unsigned int __cdecl sub_10006210(_WORD *a1, int a2, int a3, int a4, unsigned int a5, _DWORD *a6, unsigned int *a7)
{
  _WORD *v7; // eax
  int v8; // edx
  int v9; // ebx
  int v10; // edi
  int v11; // esi
  int v12; // ecx
  unsigned int result; // eax
  unsigned int *v14; // edx
  unsigned int *v15; // ecx
  _DWORD *v16; // [esp+0h] [ebp-2Ch]
  int v17; // [esp+14h] [ebp-18h]

  v7 = a1;
  v8 = a4;
  v9 = a2;
  v10 = a5;
  v11 = 0;
  v17 = a2 - a5;
  v12 = a3;
  while ( 1 )
  {
    do
    {
      result = sub_100062C0(v7, v12, v8, v9, v10, &a1, &a2, v16);
      if ( result > 3 )
      {
        v14 = a7;
        *a6 = v11;
        *v14 = result;
        return result;
      }
      v12 = a2;
      if ( a2 )
      {
        v12 = a2 - 1;
        v11 += result + 1;
        ++a1;
        --a2;
      }
      else
      {
        v11 += result;
      }
      v7 = a1;
      v8 = a5;
    }
    while ( v12 );
    if ( a5 <= 1 )
      break;
    v8 = a5 - 1;
    v12 = v10;
    v7 = &a1[v17];
  }
  result = (unsigned int)a6;
  v15 = a7;
  *a6 = v11;
  *v15 = 0;
  return result;
}
// 10006249: variable 'v16' is possibly undefined

//----- (100062C0) --------------------------------------------------------
int __cdecl sub_100062C0(_WORD *a1, int a2, int a3, int a4, int a5, _DWORD *a6, _DWORD *a7, _DWORD *a8)
{
  int result; // eax

  result = 0;
  while ( !*a1 )
  {
    ++result;
    --a2;
    ++a1;
    if ( !a2 )
    {
      --a3;
      a1 += a4 - a5;
      a2 = a5;
      if ( !a3 )
      {
        a2 = 0;
        break;
      }
    }
  }
  *a6 = a1;
  *a7 = a2;
  *a8 = a3;
  return result;
}

//----- (10006310) --------------------------------------------------------
int __cdecl sub_10006310(int a1, __int16 *a2, int a3, int a4, int a5, int a6)
{
  int v6; // ebx
  int result; // eax
  int v10; // edi
  int v11; // eax
  int v12; // [esp+14h] [ebp+Ch]
  int v13; // [esp+20h] [ebp+18h]

  v6 = a6;
  if ( !a6 )
    v6 = 1;
  result = a3 - a4;
  if ( a5 )
  {
    v13 = a5;
    v12 = 2 * result;
    do
    {
      if ( a4 )
      {
        v10 = a4;
        do
        {
          v11 = *a2 / v6;
          a1 += 2;
          ++a2;
          --v10;
          *(_WORD *)(a1 - 2) = v11;
        }
        while ( v10 );
      }
      a2 = (__int16 *)((char *)a2 + v12);
      result = --v13;
    }
    while ( v13 );
  }
  return result;
}

//----- (10006380) --------------------------------------------------------
int __cdecl sub_10006380(int a1, _WORD *a2, int a3, int a4, unsigned int a5, int a6, unsigned int a7)
{
  int v7; // eax
  unsigned int v8; // ebp
  _BYTE *v10; // edx
  _WORD *v12; // eax
  int v13; // ecx
  _BYTE *v14; // ebx
  int result; // eax
  int v17; // [esp+24h] [ebp+14h]
  unsigned int v18; // [esp+2Ch] [ebp+1Ch]
  unsigned int v19; // [esp+2Ch] [ebp+1Ch]

  v7 = a6;
  v8 = 0;
  if ( !a6 || a5 > a7 )
  {
    v7 = off_10033620((int)aWPublicGrannyR_0, 1144, 4, a5);
    a6 = 0;
  }
  v17 = v7;
  v10 = (_BYTE *)v7;
  if ( a5 )
  {
    v18 = a5;
    do
    {
      v12 = a2;
      v13 = a4;
      if ( a4 )
      {
        while ( 1 )
        {
          --v13;
          if ( *v12 )
            break;
          ++v12;
          if ( !v13 )
            goto LABEL_9;
        }
        *v10++ = 1;
      }
      else
      {
LABEL_9:
        *v10++ = 0;
        ++v8;
      }
      a2 = (_WORD *)((char *)a2 + a3);
      --v18;
    }
    while ( v18 );
  }
  sub_1000DD90(a1, v8, a5 + 1);
  v14 = (_BYTE *)v17;
  if ( a5 )
  {
    v19 = a5;
    do
    {
      if ( *v14++ )
        sub_1000DA40(a1, v8, a5 - v8, a5);
      else
        sub_1000DA40(a1, 0, v8, a5);
      --v19;
    }
    while ( v19 );
  }
  result = a6;
  if ( !a6 )
    return off_10033624((int)aWPublicGrannyR_0, 1189, v17);
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10006470) --------------------------------------------------------
char *__usercall sub_10006470@<eax>(int a1@<ebx>, __int16 *a2, int a3, int a4, int a5, int a6, char *a7)
{
  char *result; // eax
  int v9; // ebp
  int v11; // esi
  int v12; // eax
  int v13; // edx
  int v14; // [esp+20h] [ebp+18h]

  sub_10019D80(a1, 4 * a6 + 4, 0, a7);
  result = (char *)(a3 - a4);
  if ( a5 )
  {
    v9 = a5;
    v14 = 2 * (_DWORD)result;
    do
    {
      if ( a4 )
      {
        v11 = a4;
        do
        {
          v12 = abs16(*a2);
          v13 = *(_DWORD *)&a7[4 * v12];
          result = &a7[4 * v12];
          ++a2;
          --v11;
          *(_DWORD *)result = v13 + 1;
        }
        while ( v11 );
      }
      a2 = (__int16 *)((char *)a2 + v14);
      --v9;
    }
    while ( v9 );
  }
  return result;
}

//----- (100064E0) --------------------------------------------------------
_DWORD *__cdecl sub_100064E0(int a1, unsigned int a2, unsigned int a3, unsigned int a4, double *a5, _DWORD *a6)
{
  unsigned int v6; // ecx
  unsigned int v7; // eax
  int v8; // ebx
  unsigned int v9; // esi
  int v10; // edx
  int v11; // ecx
  _DWORD *result; // eax
  int v13; // [esp+10h] [ebp-40h]
  unsigned int v14; // [esp+14h] [ebp-3Ch]
  double v15; // [esp+18h] [ebp-38h]
  double v16; // [esp+38h] [ebp-18h]

  v6 = a4;
  v7 = 0;
  v14 = a4;
  v13 = 0;
  v15 = 0.0;
  v8 = 0;
  do
  {
    v9 = 0;
    if ( v7 <= a2 )
    {
      v10 = v7 - v13;
      do
      {
        if ( v7 >= v14 )
          break;
        v11 = *(_DWORD *)(a1 + 4 * v7);
        v9 += v11;
        v8 += v11 * v10;
        ++v7;
        ++v10;
      }
      while ( v7 <= a2 );
      if ( v9 )
      {
        v16 = (double)v9;
        v6 = a4;
        v15 = v15 - __FYL2X__(v16 / (double)a3, 1.0) * v16;
        if ( v7 >= a4 + 1 )
          v15 = v16 + v15;
      }
      else
      {
        v6 = a4;
      }
    }
    v13 += v6;
    v14 += v6;
  }
  while ( v7 <= a2 );
  result = a6;
  *a5 = v15;
  *a6 = v8;
  return result;
}

//----- (100065E0) --------------------------------------------------------
void __cdecl sub_100065E0(_DWORD *a1)
{
  unsigned int v1; // ebx
  unsigned int v2; // ecx
  _DWORD *v3; // edi
  unsigned int v4; // eax
  int v5; // ecx

  v1 = a1[6];
  v2 = a1[12];
  if ( v1 <= v2 )
  {
    v3 = a1 + 2;
    do
    {
      sub_100064E0(a1[14], v2, a1[11] * a1[10], ++v1, (double *)a1 + 1, a1 + 5);
      if ( *(double *)v3 <= *(double *)a1 )
      {
        v4 = a1[5];
        if ( v4 <= a1[4] )
        {
          v5 = a1[3];
          *a1 = *v3;
          a1[1] = v5;
          a1[4] = v4;
          a1[6] = v1;
        }
      }
      v2 = a1[12];
    }
    while ( v1 <= v2 && *(double *)v3 >= *(double *)a1 );
    a1[7] = v1;
  }
}

//----- (10006650) --------------------------------------------------------
int __cdecl sub_10006650(_DWORD *a1, char *a2, unsigned int a3, unsigned int a4, _BYTE *a5, int a6)
{
  unsigned int v6; // eax
  int v7; // edx
  int v8; // ebx
  unsigned int v10; // ebp
  unsigned int v12; // [esp-Ch] [ebp-4Ch]
  int v13; // [esp+14h] [ebp-2Ch] BYREF
  int v14; // [esp+18h] [ebp-28h]
  int v15; // [esp+1Ch] [ebp-24h]
  int v16; // [esp+20h] [ebp-20h]
  int v17[2]; // [esp+24h] [ebp-1Ch] BYREF
  unsigned int v18; // [esp+2Ch] [ebp-14h]
  int v19; // [esp+30h] [ebp-10h]
  int v20; // [esp+34h] [ebp-Ch]
  int v21; // [esp+38h] [ebp-8h]
  int v22; // [esp+3Ch] [ebp-4h]
  int v23; // [esp+4Ch] [ebp+Ch]

  v17[0] = (int)(a1 + 2);
  v17[1] = (int)(a1 + 2);
  v19 = 0;
  v18 = 0;
  v22 = 0;
  v20 = 0x7FFFFFFF;
  v21 = 0;
  v6 = a1[2];
  v18 = v6 >> 31;
  v6 &= ~0x80000000;
  v17[0] = (int)(a1 + 3);
  v7 = (unsigned __int8)byte_1002A4B4[(unsigned __int8)v6 >> 4];
  v8 = (unsigned __int8)byte_1002A4B4[v6 & 0xF];
  v19 = 1;
  v16 = 0;
  v15 = 0;
  v22 = (unsigned __int8)byte_1002A4C4[(v6 >> 28) & 7] | (8
                                                        * ((unsigned __int8)byte_1002A4B4[HIBYTE(v6) & 0xF] | (16 * ((unsigned __int8)byte_1002A4B4[(v6 >> 20) & 0xF] | (16 * ((unsigned __int8)byte_1002A4B4[HIWORD(v6) & 0xF] | (16 * ((unsigned __int8)byte_1002A4B4[(unsigned __int16)v6 >> 12] | (16 * ((unsigned __int8)byte_1002A4B4[(v6 >> 8) & 0xF] | (16 * ((16 * v8) | v7))))))))))));
  v14 = (int)a1 + *a1 + 8;
  v13 = v14;
  v10 = a3 >> 4;
  v12 = a3 >> 4;
  v23 = 16 * a3;
  sub_10006A30(v10, v17, &v13, a2, v23, v12, a4 >> 4, a6);
  sub_10006E50(v17, &v13, &a2[2 * v10], v23, v10, a4 >> 4, a6);
  sub_10006E50(v17, &v13, &a2[v23], v23, v10, a4 >> 4, a6);
  sub_10006E50(v17, &v13, &a2[16 * a3 + 2 * v10], v23, v10, a4 >> 4, a6);
  sub_10006E50(v17, &v13, &a2[2 * (a3 >> 3)], 8 * a3, a3 >> 3, a4 >> 3, a6);
  sub_10006E50(v17, &v13, &a2[8 * a3], 8 * a3, a3 >> 3, a4 >> 3, a6);
  sub_10006E50(v17, &v13, &a2[8 * a3 + 2 * (a3 >> 3)], 8 * a3, a3 >> 3, a4 >> 3, a6);
  sub_10006E50(v17, &v13, &a2[2 * (a3 >> 2)], 4 * a3, a3 >> 2, a4 >> 2, a6);
  sub_10006E50(v17, &v13, &a2[4 * a3], 4 * a3, a3 >> 2, a4 >> 2, a6);
  sub_10006E50(v17, &v13, &a2[4 * a3 + 2 * (a3 >> 2)], 4 * a3, a3 >> 2, a4 >> 2, a6);
  sub_10006E50(v17, &v13, &a2[2 * (a3 >> 1)], 2 * a3, a3 >> 1, a4 >> 1, a6);
  sub_10006E50(v17, &v13, &a2[2 * a3], 2 * a3, a3 >> 1, a4 >> 1, a6);
  sub_10006E50(v17, &v13, &a2[2 * a3 + 2 * (a3 >> 1)], 2 * a3, a3 >> 1, a4 >> 1, a6);
  if ( a5 )
    sub_100069A0(v17, a5, a4);
  return a1[1] + *a1 + 8;
}

//----- (100069A0) --------------------------------------------------------
unsigned int __cdecl sub_100069A0(int *a1, _BYTE *a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int v5; // edi
  unsigned int v7; // [esp-10h] [ebp-20h]
  int v8; // [esp-Ch] [ebp-1Ch]
  unsigned int v9; // [esp+14h] [ebp+4h]

  result = sub_1000E020(a1, a3 + 1);
  v5 = result;
  if ( a3 )
  {
    v9 = a3;
    do
    {
      if ( (unsigned int)((a3 * (unsigned __int64)(unsigned int)(a1[6] - a1[5] + 1) - 1)
                        / (unsigned int)(a1[4] - a1[5] + 1)) < v5 )
      {
        v8 = v5;
        *a2 = 0;
        v7 = 0;
      }
      else
      {
        v8 = a3 - v5;
        *a2 = 1;
        v7 = v5;
      }
      ++a2;
      sub_1000DDB0(a1, v7, v8, a3);
      result = --v9;
    }
    while ( v9 );
  }
  return result;
}

//----- (10006A30) --------------------------------------------------------
int __usercall sub_10006A30@<eax>(int a1@<ebp>, int *a2, int *a3, char *a4, int a5, unsigned int a6, int a7, int a8)
{
  int *v9; // edx
  int v10; // ecx
  int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // edi
  unsigned int v14; // edx
  __int16 v15; // ax
  unsigned int v16; // edi
  int result; // eax
  unsigned int v18; // edx
  int v19; // edi
  unsigned int v20; // edx
  unsigned int v21; // eax
  int v22; // ebx
  unsigned int v23; // eax
  unsigned int v24; // ebx
  int v25; // edi
  unsigned int v26; // eax
  unsigned int v27; // edx
  int v28; // ebp
  _WORD *v29; // ebp
  unsigned int v30; // eax
  int *v31; // edx
  int v32; // ecx
  int v33; // eax
  unsigned int v34; // eax
  __int16 *v35; // ebp
  unsigned int v36; // edi
  unsigned int v37; // eax
  int *v38; // edx
  int v39; // ecx
  int v40; // eax
  unsigned int v41; // eax
  int v42; // ebx
  __int16 *v43; // ebp
  unsigned int v44; // edi
  unsigned int v45; // eax
  int *v46; // edx
  int v47; // ecx
  int v48; // eax
  unsigned int v49; // eax
  unsigned int v50; // [esp+10h] [ebp-8h]
  int v51; // [esp+14h] [ebp-4h]
  unsigned int v52; // [esp+20h] [ebp+8h]
  unsigned int v53; // [esp+24h] [ebp+Ch]
  _WORD *v54; // [esp+24h] [ebp+Ch]
  _WORD *v55; // [esp+24h] [ebp+Ch]
  int v56; // [esp+28h] [ebp+10h]
  int v57; // [esp+2Ch] [ebp+14h]
  int v58; // [esp+30h] [ebp+18h]
  int v59; // [esp+34h] [ebp+1Ch]

  v9 = (int *)a3[3];
  if ( v9 )
  {
    v10 = a3[2] & 1;
    a3[2] = (unsigned int)a3[2] >> 1;
    a3[3] = (int)v9 - 1;
    v11 = v10;
  }
  else
  {
    v12 = *(_DWORD *)*a3;
    *a3 += 4;
    a3[2] = v12 >> 1;
    a3[3] = 31;
    v11 = v12 & 1;
  }
  if ( v11 )
  {
    v13 = a3[3];
    if ( v13 < 0x10 )
    {
      a1 = a3[2];
      v14 = *(_DWORD *)*a3 >> (16 - v13);
      v15 = a1 | (*(_DWORD *)*a3 << v13);
      v16 = v13 + 16;
      *a3 += 4;
    }
    else
    {
      v14 = *((unsigned __int16 *)a3 + 5);
      v15 = a3[2];
      v16 = v13 - 16;
    }
    a3[2] = v14;
    a3[3] = v16;
    return sub_10006DF0(a1, a4, a5, a6, a7, v15);
  }
  else
  {
    v18 = a3[3];
    if ( v18 < 0x10 )
    {
      v21 = *(_DWORD *)*a3 >> (16 - v18);
      v19 = (unsigned __int16)(a3[2] | (*(_DWORD *)*a3 << v18));
      v20 = v18 + 16;
      v22 = *a3 + 4;
      a3[2] = v21;
      *a3 = v22;
    }
    else
    {
      v19 = (unsigned __int16)a3[2];
      v20 = v18 - 16;
      a3[2] = *((unsigned __int16 *)a3 + 5);
    }
    a3[3] = v20;
    v50 = v19 + 1;
    sub_1000E090(v19 + 1);
    v52 = sub_1000E0C0(a8, 0, v19, v19 + 1);
    v23 = a3[3];
    v24 = a5 - a6;
    if ( v23 < 0x10 )
    {
      v27 = *(_DWORD *)*a3 >> (16 - v23);
      v25 = (unsigned __int16)(*((_WORD *)a3 + 4) | (*(_WORD *)*a3 << v23));
      v26 = v23 + 16;
      v28 = *a3 + 4;
      a3[2] = v27;
      *a3 = v28;
    }
    else
    {
      v25 = (unsigned __int16)a3[2];
      v26 = v23 - 16;
      a3[2] = *((unsigned __int16 *)a3 + 5);
    }
    a3[3] = v26;
    *(_WORD *)a4 = v25;
    v29 = a4 + 2;
    v51 = a6 - 1;
    if ( a6 != 1 )
    {
      v53 = a6 - 1;
      do
      {
        v24 = sub_1000E6F0(v24, v52, (int)a2);
        if ( v24 > 0x10000 )
        {
          v30 = sub_1000E020(a2, v50);
          *(_WORD *)v24 = v30;
          v24 = v30;
        }
        if ( v24 )
        {
          v31 = (int *)a3[3];
          if ( v31 )
          {
            v32 = a3[2] & 1;
            a3[2] = (unsigned int)a3[2] >> 1;
            a3[3] = (int)v31 - 1;
            v33 = v32;
          }
          else
          {
            v34 = *(_DWORD *)*a3;
            *a3 += 4;
            a3[2] = v34 >> 1;
            a3[3] = 31;
            v33 = v34 & 1;
          }
          v24 = (v24 ^ -v33) + v33;
        }
        v25 += v24;
        *v29++ = v25;
        --v53;
      }
      while ( v53 );
      v24 = a5 - a6;
    }
    result = a7 - 1;
    if ( a7 != 1 )
    {
      v58 = v24;
      v59 = 2 * a5;
      v56 = result;
      while ( 1 )
      {
        v54 = &v29[v58];
        v35 = &v29[v58 + v59 / 0xFFFFFFFE];
        v36 = sub_1000E6F0((int)a2, v52, (int)a2);
        if ( v36 > 0x10000 )
        {
          v37 = sub_1000E020(a2, v50);
          *(_WORD *)v36 = v37;
          v36 = v37;
        }
        if ( v36 )
        {
          v38 = (int *)a3[3];
          if ( v38 )
          {
            v39 = a3[2] & 1;
            a3[2] = (unsigned int)a3[2] >> 1;
            a3[3] = (int)v38 - 1;
            v40 = v39;
          }
          else
          {
            v41 = *(_DWORD *)*a3;
            *a3 += 4;
            a3[2] = v41 >> 1;
            a3[3] = 31;
            v40 = v41 & 1;
          }
          v36 = (v36 ^ -v40) + v40;
        }
        v42 = v36 + *v35;
        *v54 = v42;
        v55 = v54 + 1;
        result = v51;
        v43 = v35 + 1;
        if ( v51 )
        {
          v57 = v51;
          do
          {
            v44 = sub_1000E6F0(v42, v52, (int)a2);
            if ( v44 > 0x10000 )
            {
              v45 = sub_1000E020(a2, v50);
              *(_WORD *)v44 = v45;
              v44 = v45;
            }
            if ( v44 )
            {
              v46 = (int *)a3[3];
              if ( v46 )
              {
                v47 = a3[2] & 1;
                a3[2] = (unsigned int)a3[2] >> 1;
                a3[3] = (int)v46 - 1;
                v48 = v47;
              }
              else
              {
                v49 = *(_DWORD *)*a3;
                *a3 += 4;
                a3[2] = v49 >> 1;
                a3[3] = 31;
                v48 = v49 & 1;
              }
              v44 = (v44 ^ -v48) + v48;
            }
            v42 = v44 + (v42 + *v43) / 2;
            *v55++ = v42;
            ++v43;
            result = --v57;
          }
          while ( v57 );
        }
        if ( !--v56 )
          break;
        v29 = v55;
      }
    }
  }
  return result;
}

//----- (10006DF0) --------------------------------------------------------
int __usercall sub_10006DF0@<eax>(int a1@<ebp>, char *a2, int a3, unsigned int a4, int a5, __int16 a6)
{
  int result; // eax
  int v8; // ebx
  char *v9; // edi
  char *v10; // edi
  int i; // ecx
  int v12; // [esp+Ch] [ebp+8h]

  result = a3 - a4;
  if ( a5 )
  {
    result *= 2;
    v12 = result;
    v8 = a5;
    do
    {
      if ( a4 )
      {
        LOWORD(a1) = a6;
        v9 = a2;
        a2 += 2 * a4;
        a1 <<= 16;
        LOWORD(a1) = a6;
        result = a1;
        memset32(v9, a1, a4 >> 1);
        v10 = &v9[4 * (a4 >> 1)];
        for ( i = a4 & 1; i; --i )
        {
          *(_WORD *)v10 = a6;
          v10 += 2;
        }
      }
      a2 += v12;
      --v8;
    }
    while ( v8 );
  }
  return result;
}

//----- (10006E50) --------------------------------------------------------
unsigned int __cdecl sub_10006E50(int *a1, int *a2, char *a3, int a4, unsigned int a5, int a6, int a7)
{
  unsigned int v8; // eax
  int v9; // ebp
  _DWORD *v10; // eax
  int v11; // edx
  int v12; // edi
  int v13; // ecx
  int v14; // eax
  unsigned int v15; // eax
  unsigned int v16; // edi
  unsigned __int16 v17; // ax
  _DWORD *v18; // edi
  int v19; // edx
  int v20; // ebx
  unsigned int result; // eax
  int v22; // eax
  int v23; // edx
  _DWORD *v24; // edi
  unsigned int v25; // eax
  unsigned int v26; // edi
  int v27; // eax
  unsigned int v28; // ebx
  _DWORD *v29; // edx
  int v30; // ecx
  int v31; // eax
  unsigned int v32; // eax
  char *v33; // edi
  _WORD *v34; // ebp
  unsigned int v35; // edx
  unsigned int v36; // eax
  _WORD *v37; // ecx
  int v38; // eax
  unsigned int v39; // edx
  int v40; // eax
  unsigned int v41; // edx
  int v42; // ecx
  unsigned int v43; // edx
  unsigned int v44; // ecx
  int v45; // eax
  unsigned int v46; // edi
  unsigned int v47; // eax
  _DWORD *v48; // edx
  int v49; // ecx
  __int16 v50; // ax
  unsigned int v51; // eax
  __int16 *v52; // edi
  unsigned int v53; // ecx
  int v54; // eax
  unsigned int v55; // eax
  int v56; // eax
  unsigned __int8 v57; // dl
  int v58; // ecx
  unsigned int v59; // ecx
  _WORD *v60; // edi
  int i; // ecx
  __int16 *v62; // edi
  unsigned int v63; // [esp+10h] [ebp-24h]
  unsigned int v64; // [esp+10h] [ebp-24h]
  unsigned int v65; // [esp+14h] [ebp-20h]
  int v66; // [esp+18h] [ebp-1Ch]
  int v67; // [esp+1Ch] [ebp-18h] BYREF
  unsigned int v68; // [esp+20h] [ebp-14h]
  unsigned int v69; // [esp+24h] [ebp-10h]
  unsigned int v70; // [esp+28h] [ebp-Ch] BYREF
  unsigned int v71; // [esp+2Ch] [ebp-8h] BYREF
  unsigned int v72; // [esp+30h] [ebp-4h]
  int v73; // [esp+3Ch] [ebp+8h]
  int v74; // [esp+40h] [ebp+Ch]
  unsigned int v75; // [esp+40h] [ebp+Ch]
  unsigned int v76; // [esp+4Ch] [ebp+18h]
  int v77; // [esp+50h] [ebp+1Ch]

  v8 = a2[3];
  v65 = 0;
  v63 = 0;
  if ( v8 < 0x10 )
  {
    v11 = *(_DWORD *)*a2 >> (16 - v8);
    v9 = (unsigned __int16)(*((_WORD *)a2 + 4) | (*(_WORD *)*a2 << v8));
    v10 = (_DWORD *)(v8 + 16);
    v12 = *a2 + 4;
    a2[2] = v11;
    *a2 = v12;
  }
  else
  {
    v9 = (unsigned __int16)a2[2];
    v10 = (_DWORD *)(v8 - 16);
    a2[2] = *((unsigned __int16 *)a2 + 5);
  }
  v66 = v9;
  a2[3] = (int)v10;
  if ( v10 )
  {
    v13 = a2[2] & 1;
    a2[2] = (unsigned int)a2[2] >> 1;
    a2[3] = (int)v10 - 1;
    v14 = v13;
  }
  else
  {
    v15 = *(_DWORD *)*a2;
    *a2 += 4;
    a2[2] = v15 >> 1;
    a2[3] = 31;
    v14 = v15 & 1;
  }
  v16 = a2[3];
  if ( !v14 )
  {
    if ( v16 < 0x10 )
    {
      v23 = (unsigned __int16)(*((_WORD *)a2 + 4) | (*(_WORD *)*a2 << v16));
      v22 = *(_DWORD *)*a2 >> (16 - v16);
      v24 = (_DWORD *)(v16 + 16);
      *a2 += 4;
    }
    else
    {
      v22 = *((unsigned __int16 *)a2 + 5);
      v23 = (unsigned __int16)a2[2];
      v24 = (_DWORD *)(v16 - 16);
    }
    a2[2] = v22;
    v25 = v9 * v23;
    a2[3] = (int)v24;
    v26 = v23 + 1;
    v68 = v23 + 1;
    if ( (unsigned int)(v9 * v23) > 0x80 )
    {
      if ( v25 < 0x800 )
      {
        if ( v25 < 0x200 )
          v27 = 9 - (v25 < 0x100);
        else
          v27 = 11 - (v25 < 0x400);
      }
      else if ( v25 < 0x2000 )
      {
        v27 = 13 - (v25 < 0x1000);
      }
      else
      {
        v27 = 15 - (v25 < 0x4000);
      }
    }
    else
    {
      v27 = (unsigned __int8)byte_1002A430[v25];
    }
    sub_10007540(&v67, (int *)&v70, (int *)&v71, v23, v23 + 1, v27 + 1, a7);
    v69 = a4 - a5;
    v77 = a6;
    v28 = sub_1000E020(a1, v26);
    if ( v28 )
    {
      v29 = (_DWORD *)a2[3];
      if ( v29 )
      {
        v30 = a2[2] & 1;
        a2[2] = (unsigned int)a2[2] >> 1;
        a2[3] = (int)v29 - 1;
        v31 = v30;
      }
      else
      {
        v32 = *(_DWORD *)*a2;
        *a2 += 4;
        a2[2] = v32 >> 1;
        a2[3] = 31;
        v31 = v32 & 1;
      }
      v28 = v9 * ((v28 ^ -v31) + v31);
    }
    result = a5;
    *(_WORD *)a3 = v28;
    v33 = a3;
    v34 = a3 + 2;
    v73 = v28;
    v74 = v28;
    if ( a5 == 1 )
      goto LABEL_70;
    v76 = a5 - 1;
    while ( 1 )
    {
LABEL_32:
      v65 = sub_1000E6F0(v28, v70, (int)a1);
      if ( v65 <= 0x10000 )
      {
        v36 = v65;
      }
      else
      {
        v35 = a2[3];
        if ( v35 < 6 )
        {
          v64 = *(_DWORD *)*a2;
          v38 = a2[2] | (v64 << v35);
          a2[3] += 26;
          v36 = v38 & 0x3F;
          *a2 += 4;
          v37 = (_WORD *)v65;
          a2[2] = v64 >> (6 - v35);
        }
        else
        {
          v36 = a2[2] & 0x3F;
          a2[2] = (unsigned int)a2[2] >> 6;
          v37 = (_WORD *)v65;
          a2[3] = v35 - 6;
        }
        *v37 = v36;
        v65 = v36;
      }
      if ( v36 >= 0x3C )
        v65 = dword_10030D68[v36];
      v63 = sub_1000E6F0(v28, v71, (int)a1);
      if ( v63 > 0x10000 )
      {
        v39 = a2[3];
        if ( v39 < 8 )
        {
          v72 = *(_DWORD *)*a2;
          v40 = a2[2] | (v72 << v39);
          v41 = v72 >> (8 - v39);
          a2[3] += 24;
          v40 = (unsigned __int8)v40;
          v42 = *a2 + 4;
          a2[2] = v41;
          *a2 = v42;
        }
        else
        {
          v40 = (unsigned __int8)a2[2];
          a2[2] = (unsigned int)a2[2] >> 8;
          a2[3] = v39 - 8;
        }
        *(_WORD *)v63 = v40;
        v63 = v40;
      }
      result = v63;
      if ( v63 < 0xFC )
      {
        if ( !v63 )
          goto LABEL_49;
      }
      else
      {
        result = dword_10030A78[v63];
      }
      result += 2;
      v63 = result;
LABEL_49:
      v43 = v76;
      while ( v65 )
      {
        if ( v43 > 1 )
        {
          v72 = *(__int16 *)v33;
          v53 = (abs32(v74) + abs32(v28) + abs32(v73) + abs32(v72)) >> 2;
          if ( v53 > 0x80 )
          {
            if ( v53 < 0x800 )
            {
              if ( v53 < 0x200 )
                v54 = 9 - (v53 < 0x100);
              else
                v54 = 11 - (v53 < 0x400);
            }
            else if ( v53 < 0x2000 )
            {
              v54 = 13 - (v53 < 0x1000);
            }
            else
            {
              v54 = 15 - (v53 < 0x4000);
            }
          }
          else
          {
            v54 = (unsigned __int8)byte_1002A430[v53];
          }
          v75 = sub_1000E6F0(v28, *(_DWORD *)(v67 + 4 * v54), (int)a1);
          if ( v75 > 0x10000 )
          {
            v55 = sub_1000E020(a1, v68);
            *(_WORD *)v75 = v55;
            v75 = v55;
          }
          v56 = v75;
          if ( v75 )
          {
            if ( a2[3] )
            {
              v57 = a2[2];
              a2[2] = (unsigned int)a2[2] >> 1;
              --a2[3];
              v58 = v57 & 1;
            }
            else
            {
              v59 = *(_DWORD *)*a2;
              *a2 += 4;
              a2[2] = v59 >> 1;
              a2[3] = 31;
              v58 = v59 & 1;
            }
            v56 = v66 * ((v75 ^ -v58) + v58);
          }
          *v34 = v56;
          v74 = v56;
          ++v34;
          v33 += 2;
          v73 = v28;
          v28 = v72;
          --v65;
          result = v63;
          --v76;
          goto LABEL_49;
        }
        if ( v43 )
        {
          v44 = (abs32(v28) + abs32(v73) + abs32(2 * v74)) >> 2;
          if ( v44 > 0x80 )
          {
            if ( v44 < 0x800 )
            {
              if ( v44 < 0x200 )
                v45 = 9 - (v44 < 0x100);
              else
                v45 = 11 - (v44 < 0x400);
            }
            else if ( v44 < 0x2000 )
            {
              v45 = 13 - (v44 < 0x1000);
            }
            else
            {
              v45 = 15 - (v44 < 0x4000);
            }
          }
          else
          {
            v45 = (unsigned __int8)byte_1002A430[v44];
          }
          v46 = sub_1000E6F0((int)a1, *(_DWORD *)(v67 + 4 * v45), (int)a1);
          if ( v46 > 0x10000 )
          {
            v47 = sub_1000E020(a1, v68);
            *(_WORD *)v46 = v47;
            v46 = v47;
          }
          if ( v46 )
          {
            v48 = (_DWORD *)a2[3];
            if ( v48 )
            {
              v49 = a2[2] & 1;
              a2[2] = (unsigned int)a2[2] >> 1;
              a2[3] = (int)v48 - 1;
              v50 = v49;
            }
            else
            {
              v51 = *(_DWORD *)*a2;
              *a2 += 4;
              a2[2] = v51 >> 1;
              a2[3] = 31;
              v50 = v51 & 1;
            }
            LOWORD(v46) = v66 * ((v46 ^ -v50) + v50);
          }
          *v34++ = v46;
          result = --v65;
        }
LABEL_70:
        if ( !--v77 )
          return result;
        v43 = a5;
        v34 += v69;
        v52 = &v34[-a4];
        v28 = *v52;
        result = v63;
        v76 = a5;
        v33 = (char *)(v52 + 1);
        v73 = v28;
        v74 = v28;
      }
      if ( result )
      {
        while ( 1 )
        {
          if ( result < v43 )
          {
            v43 -= result;
            v76 = v43;
            v33 += 2 * result;
            do
            {
              *v34++ = 0;
              --result;
            }
            while ( result );
            v28 = *((__int16 *)v33 - 1);
            v74 = 0;
            v73 = *((__int16 *)v33 - 2);
          }
          else
          {
            result -= v43;
            if ( v43 )
            {
              memset(v34, 0, 4 * (v43 >> 1));
              v60 = &v34[2 * (v43 >> 1)];
              for ( i = v43 & 1; i; --i )
                *v60++ = 0;
              v34 += v43;
            }
            if ( !--v77 )
              return result;
            v43 = a5;
            v34 += v69;
            v62 = &v34[-a4];
            v28 = *v62;
            v76 = a5;
            v33 = (char *)(v62 + 1);
            v73 = v28;
            v74 = v28;
          }
          if ( !result )
            goto LABEL_32;
        }
      }
    }
  }
  if ( v16 < 0x10 )
  {
    v19 = *(_DWORD *)*a2 >> (16 - v16);
    v17 = *((_WORD *)a2 + 4) | (*(_WORD *)*a2 << v16);
    v18 = (_DWORD *)(v16 + 16);
    v20 = *a2 + 4;
    a2[2] = v19;
    *a2 = v20;
  }
  else
  {
    v17 = a2[2];
    v18 = (_DWORD *)(v16 - 16);
    a2[2] = *((unsigned __int16 *)a2 + 5);
  }
  a2[3] = (int)v18;
  return sub_10006DF0(v9, a3, a4, a5, a6, v9 * v17);
}
// 10030A78: using guessed type int dword_10030A78[];
// 10030D68: using guessed type int dword_10030D68[4];

//----- (10007540) --------------------------------------------------------
unsigned int __cdecl sub_10007540(_DWORD *a1, int *a2, int *a3, int a4, int a5, unsigned int a6, int a7)
{
  unsigned int v8; // edi
  int i; // esi
  int v10; // eax
  int v11; // esi
  unsigned int v13; // [esp+10h] [ebp-8h]
  unsigned int v14; // [esp+14h] [ebp-4h]
  unsigned int v15; // [esp+2Ch] [ebp+14h]

  v15 = sub_1000E090(a5);
  v13 = sub_1000E090(64);
  v14 = sub_1000E090(256);
  v8 = 0;
  *a1 = a7;
  for ( i = a7 + 4 * a6; v8 < a6; ++v8 )
  {
    v10 = sub_1000E0C0(i, 0, a4, a5);
    i += v15;
    *(_DWORD *)(*a1 + 4 * v8) = v10;
  }
  *a2 = sub_1000E0C0(i, 0, 63, 64);
  v11 = v13 + i;
  *a3 = sub_1000E0C0(v11, 0, 255, 256);
  return v11 + v14;
}

//----- (100075F0) --------------------------------------------------------
__int16 *__cdecl sub_100075F0(int a1, int a2, int a3, int a4, unsigned int a5, int a6, int a7, int a8)
{
  __int16 *result; // eax
  int v12; // edx
  int v13; // ebx
  int v14; // ebp
  int v15; // esi
  __int16 *v16; // edi
  int v17; // ecx
  int v18; // esi
  int v19; // eax
  __int16 *v20; // edi
  bool v21; // zf
  _WORD *v22; // [esp+4h] [ebp-38h]
  unsigned int v23; // [esp+8h] [ebp-34h]
  __int16 *v24; // [esp+Ch] [ebp-30h]
  int v25; // [esp+10h] [ebp-2Ch]
  int v26; // [esp+18h] [ebp-24h]
  int v27; // [esp+20h] [ebp-1Ch]
  int v28; // [esp+24h] [ebp-18h]
  int v29; // [esp+28h] [ebp-14h]
  int v30; // [esp+34h] [ebp-8h]
  int v31; // [esp+38h] [ebp-4h]
  __int16 *v32; // [esp+40h] [ebp+4h]
  _WORD *v33; // [esp+48h] [ebp+Ch]
  char *v34; // [esp+50h] [ebp+14h]
  int v35; // [esp+58h] [ebp+1Ch]
  unsigned int v36; // [esp+5Ch] [ebp+20h]

  v33 = (_WORD *)(a1 + a7 * a2);
  result = (__int16 *)(a3 + a7 * a4);
  v34 = (char *)v33 + a5;
  v32 = &result[a5];
  v24 = result;
  if ( a8 )
  {
    v36 = a5 >> 1;
    v25 = a8;
    do
    {
      v12 = result[4];
      v13 = result[1];
      v14 = result[2];
      v15 = result[3];
      v29 = *result;
      v22 = v33;
      v35 = 1;
      v28 = v13;
      v27 = v14;
      v30 = v15;
      v31 = v12;
      v26 = v12;
      v16 = result + 5;
      if ( v36 )
      {
        v23 = v36;
        do
        {
          if ( v16 == v32 )
          {
            v16 -= 2;
            v35 = -1;
          }
          v17 = 55883 * v29 + 2479 * (v12 + v26) + 24733 * (v13 + v28) + -1563 * (v15 + v30) - 7250 * (v27 + v14);
          v18 = 2667 * (v28 + v30) + 27400 * (v29 + v14) - 4230 * (v27 + v12) - 51674 * v13;
          *v22 = (v17 + ((v17 >> 31) ^ 0x7FFF)) / 0x10000;
          v19 = v18 + ((v18 >> 31) ^ 0x7FFF);
          v15 = v28;
          *(_WORD *)((char *)v22 + v34 - (char *)v33) = v19 / 0x10000;
          v26 = v27;
          v27 = v29;
          v28 = v13;
          v13 = v30;
          v30 = *v16;
          v20 = &v16[v35];
          v29 = v14;
          v14 = v31;
          if ( v20 == v32 )
          {
            v20 -= 2;
            v35 = -1;
          }
          v12 = *v20;
          v16 = &v20[v35];
          v21 = v23 == 1;
          v31 = v12;
          ++v22;
          --v23;
        }
        while ( !v21 );
        result = v24;
      }
      result = (__int16 *)((char *)result + a4);
      v21 = v25 == 1;
      v24 = result;
      v34 += a2;
      v33 = (_WORD *)((char *)v33 + a2);
      v32 = (__int16 *)((char *)v32 + a4);
      --v25;
    }
    while ( !v21 );
  }
  return result;
}

//----- (10007820) --------------------------------------------------------
int __cdecl sub_10007820(_WORD *a1, int a2, __int16 *a3, int a4, int a5, int a6, int a7, unsigned int a8)
{
  int result; // eax
  __int16 *v10; // esi
  __int16 *v12; // ecx
  __int16 *v13; // edi
  __int16 *v14; // edx
  int v15; // esi
  int v16; // ebx
  int v17; // ebp
  int v18; // edx
  __int16 *v19; // edi
  int v20; // ecx
  int v21; // esi
  int v22; // edx
  int v23; // ecx
  int v24; // eax
  __int16 *v25; // edi
  int v26; // edx
  bool v27; // zf
  __int16 *v28; // [esp+Ch] [ebp-40h]
  _WORD *v29; // [esp+10h] [ebp-3Ch]
  __int16 *v30; // [esp+14h] [ebp-38h]
  unsigned int v31; // [esp+18h] [ebp-34h]
  _WORD *v32; // [esp+1Ch] [ebp-30h]
  unsigned int v33; // [esp+20h] [ebp-2Ch]
  int v34; // [esp+24h] [ebp-28h]
  int v35; // [esp+2Ch] [ebp-20h]
  int v36; // [esp+30h] [ebp-1Ch]
  int v37; // [esp+34h] [ebp-18h]
  int v38; // [esp+38h] [ebp-14h]
  int v39; // [esp+44h] [ebp-8h]
  int v40; // [esp+48h] [ebp-4h]
  __int16 *v41; // [esp+50h] [ebp+4h]
  int v42; // [esp+58h] [ebp+Ch]
  __int16 *v43; // [esp+60h] [ebp+14h]
  __int16 *v44; // [esp+64h] [ebp+18h]
  __int16 *v45; // [esp+6Ch] [ebp+20h]

  result = a4;
  v10 = a3;
  v28 = a3;
  v29 = a1;
  v41 = (__int16 *)((char *)a3 + a6 * a4);
  if ( a7 )
  {
    v28 = (__int16 *)((char *)a3 + a4 * (a7 - 4));
    v10 = v28;
    v29 = (_WORD *)((char *)a1 + a7 * a2);
  }
  if ( a5 )
  {
    v31 = a8 >> 1;
    v12 = (__int16 *)((char *)&v10[a4] + a4);
    v13 = (__int16 *)((char *)&v10[2 * a4] + a4);
    v14 = (__int16 *)((char *)v10 + a4);
    v43 = (__int16 *)((char *)v10 + a4);
    v45 = v12;
    v30 = v13;
    v44 = &v10[4 * a4];
    v34 = a5;
    while ( 1 )
    {
      v15 = *v10;
      v32 = v29;
      v16 = *v14;
      v42 = result;
      if ( a7 )
      {
        v17 = *(__int16 *)((char *)v13 + result);
        v36 = *(__int16 *)((char *)v14 + result);
        v38 = *(__int16 *)((char *)v12 + result);
        v37 = *v12;
        v18 = *(__int16 *)((char *)v13 + result + result);
        v35 = v16;
        v16 = *v13;
        v19 = v44;
        v39 = v18;
        if ( v44 == v41 )
        {
          v19 = &v44[-result];
          v42 = -result;
        }
        v14 = v43;
        v40 = *v19;
        v13 = (__int16 *)((char *)v19 + v42);
        v12 = v45;
      }
      else
      {
        v17 = *(__int16 *)((char *)v14 + result);
        v38 = v15;
        v39 = *v12;
        v35 = v39;
        v15 = *(__int16 *)((char *)v12 + result);
        v37 = *v14;
        v36 = v17;
        v40 = v15;
      }
      if ( v31 )
      {
        v33 = v31;
        do
        {
          if ( v13 == v41 )
          {
            v13 -= v42;
            v42 = -v42;
          }
          v20 = 55883 * v38 + 2479 * (v40 + v15) + 24733 * (v16 + v37) + -1563 * (v35 + v39) - 7250 * (v36 + v17);
          v21 = 2667 * (v37 + v39) + 27400 * (v38 + v17) - 4230 * (v36 + v40) - 51674 * v16;
          *v32 = (v20 + ((v20 >> 31) ^ 0x7FFF)) / 0x10000;
          v22 = v38;
          *(_WORD *)((char *)v32 + a2) = (v21 + ((v21 >> 31) ^ 0x7FFF)) / 0x10000;
          v15 = v36;
          v32 = (_WORD *)((char *)v32 + a2 + a2);
          v23 = v37;
          v37 = v16;
          v16 = v39;
          v39 = *v13;
          v24 = v42;
          v35 = v23;
          v25 = (__int16 *)((char *)v13 + v42);
          v38 = v17;
          v17 = v40;
          v36 = v22;
          if ( v25 == v41 )
          {
            v24 = -v42;
            v25 -= v42;
            v42 = -v42;
          }
          v26 = *v25;
          v13 = (__int16 *)((char *)v25 + v24);
          v27 = v33 == 1;
          v40 = v26;
          --v33;
        }
        while ( !v27 );
        result = a4;
        v14 = v43;
        v12 = v45;
      }
      ++v28;
      ++v30;
      ++v14;
      ++v12;
      v27 = v34 == 1;
      v43 = v14;
      v45 = v12;
      ++v44;
      ++v29;
      ++v41;
      --v34;
      if ( v27 )
        break;
      v13 = v30;
      v10 = v28;
    }
  }
  return result;
}

//----- (10007B00) --------------------------------------------------------
int __cdecl sub_10007B00(int a1, int a2, int a3, int a4, unsigned int a5, int a6, int a7, int a8)
{
  int result; // eax
  _WORD *v9; // ebp
  __int16 *v10; // edi
  char *v11; // ebx
  unsigned int v12; // edx
  __int16 *v13; // ecx
  _WORD *v14; // esi
  int v15; // ebx
  __int16 v16; // ax
  bool v17; // zf
  int v18; // [esp+14h] [ebp+4h]
  char *v19; // [esp+1Ch] [ebp+Ch]
  unsigned int v20; // [esp+24h] [ebp+14h]
  unsigned int v21; // [esp+2Ch] [ebp+1Ch]

  result = a2;
  v9 = (_WORD *)(a7 * a2 + a1);
  v10 = (__int16 *)(a3 + a7 * a4);
  v11 = (char *)v9 + a5;
  v19 = (char *)v9 + a5;
  if ( a8 )
  {
    v12 = a5 >> 1;
    v20 = a5 >> 1;
    v18 = a8;
    do
    {
      v13 = v10;
      v14 = v9;
      if ( v12 )
      {
        v15 = v11 - (char *)v9;
        v21 = v12;
        do
        {
          *v14 = (v13[1] + *v13) / 2;
          v16 = *v13 - v13[1];
          v13 += 2;
          *(_WORD *)((char *)v14++ + v15) = v16;
          --v21;
        }
        while ( v21 );
        result = a2;
        v12 = v20;
      }
      v11 = &v19[result];
      v10 = (__int16 *)((char *)v10 + a4);
      v9 = (_WORD *)((char *)v9 + result);
      v17 = v18 == 1;
      v19 += result;
      --v18;
    }
    while ( !v17 );
  }
  return result;
}

//----- (10007BB0) --------------------------------------------------------
int __cdecl sub_10007BB0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8)
{
  __int16 *v10; // ecx
  int result; // eax
  unsigned int v12; // ebp
  _WORD *v13; // esi
  _WORD *v14; // esi
  bool v15; // zf
  int v16; // [esp+10h] [ebp+8h]
  __int16 *v17; // [esp+18h] [ebp+10h]
  int v18; // [esp+24h] [ebp+1Ch]

  v10 = (__int16 *)(a3 + a7 * a4);
  result = a7 * a2 + a1;
  v17 = v10;
  if ( a5 )
  {
    v12 = a8 >> 1;
    result -= (int)v10;
    v16 = result;
    v18 = a5;
    do
    {
      v13 = (__int16 *)((char *)v10 + result);
      if ( v12 )
      {
        do
        {
          *v13 = (*(__int16 *)((char *)v10 + a4) + *v10) / 2;
          v14 = (_WORD *)((char *)v13 + a2);
          *v14 = *v10 - *(__int16 *)((char *)v10 + a4);
          v13 = (_WORD *)((char *)v14 + a2);
          v10 += a4;
          --v12;
        }
        while ( v12 );
        v12 = a8 >> 1;
        v10 = v17;
        result = v16;
      }
      ++v10;
      v15 = v18 == 1;
      v17 = v10;
      --v18;
    }
    while ( !v15 );
  }
  return result;
}

//----- (10007C50) --------------------------------------------------------
unsigned int __cdecl sub_10007C50(int a1, int a2, unsigned int a3, unsigned int a4, int a5)
{
  unsigned int v5; // ebp
  int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // edi
  int v9; // edi
  unsigned int result; // eax
  unsigned int v11; // [esp+0h] [ebp-10h]
  int v12; // [esp+4h] [ebp-Ch]
  void (__cdecl *v13)(int, int, int, int, unsigned int, unsigned int, unsigned int, int); // [esp+8h] [ebp-8h]
  void (__cdecl *v14)(int, int, int, int, unsigned int, unsigned int, int, unsigned int); // [esp+Ch] [ebp-4h]

  v14 = (void (__cdecl *)(int, int, int, int, unsigned int, unsigned int, int, unsigned int))sub_100075F0;
  if ( a3 < 0xC )
    v14 = (void (__cdecl *)(int, int, int, int, unsigned int, unsigned int, int, unsigned int))sub_10007B00;
  v5 = a4;
  v13 = (void (__cdecl *)(int, int, int, int, unsigned int, unsigned int, unsigned int, int))sub_10007820;
  if ( a4 < 0xA )
    v13 = (void (__cdecl *)(int, int, int, int, unsigned int, unsigned int, unsigned int, int))sub_10007BB0;
  if ( a4 > 0x14 )
  {
    a4 = 12;
    v6 = 12;
  }
  else
  {
    v6 = a4;
  }
  v7 = v5 - v6;
  v8 = v5;
  v12 = 0;
  v11 = v5;
  v13(a5, a2, a1, a2, a3, v5, 0, v6);
  while ( 1 )
  {
    if ( v8 > 0x10 )
      v8 = 8;
    v14(a1, a2, a5, a2, a3, v5, v12, v8);
    v12 += v8;
    v11 -= v8;
    if ( v7 )
    {
      v9 = v7;
      if ( v7 > 0x10 )
        v9 = 8;
      v13(a5, a2, a1, a2, a3, v5, a4, v9);
      a4 += v9;
      v7 -= v9;
    }
    result = v11;
    if ( !v11 )
      break;
    v8 = v11;
  }
  return result;
}

//----- (10007D70) --------------------------------------------------------
unsigned int __cdecl sub_10007D70(
        int a1,
        int a2,
        int a3,
        int a4,
        unsigned int a5,
        unsigned int a6,
        int a7,
        int a8,
        int a9)
{
  unsigned int result; // eax
  _WORD *v10; // edx
  int v11; // ecx
  int *v12; // edi
  _WORD *v13; // esi
  __int16 v14; // ax
  _QWORD *v15; // ecx
  __int16 v16; // dx
  bool v17; // zf
  int v18; // edx
  int v19; // ecx
  __int16 v20; // dx
  int v21; // ecx
  int v22; // edx
  int v23; // ecx
  int v24; // edx
  int v25; // eax
  int v26; // ecx
  int v27; // ecx
  int v28; // edx
  int v29; // ecx
  int v30; // [esp+8h] [ebp-90h]
  unsigned int v31; // [esp+8h] [ebp-90h]
  int v32; // [esp+8h] [ebp-90h]
  int v33; // [esp+Ch] [ebp-8Ch]
  unsigned int v34; // [esp+14h] [ebp-84h]
  int v35; // [esp+14h] [ebp-84h]
  int v36; // [esp+18h] [ebp-80h]
  _BYTE v37[6]; // [esp+28h] [ebp-70h]
  _BYTE v38[6]; // [esp+2Eh] [ebp-6Ah]
  __int16 v39; // [esp+34h] [ebp-64h]
  __int128 v40; // [esp+38h] [ebp-60h]
  int *v41; // [esp+48h] [ebp-50h]
  unsigned int v42; // [esp+48h] [ebp-50h]
  int v43; // [esp+48h] [ebp-50h]
  int v44; // [esp+4Ch] [ebp-4Ch]
  int v45; // [esp+50h] [ebp-48h]
  int v46; // [esp+54h] [ebp-44h]
  int v47; // [esp+58h] [ebp-40h]
  _QWORD *v48; // [esp+5Ch] [ebp-3Ch]
  int v49; // [esp+5Ch] [ebp-3Ch]
  int v50; // [esp+60h] [ebp-38h]
  unsigned int v51; // [esp+68h] [ebp-30h]
  _WORD *v52; // [esp+6Ch] [ebp-2Ch]
  int *v53; // [esp+70h] [ebp-28h]
  int v54; // [esp+74h] [ebp-24h]
  int v55; // [esp+7Ch] [ebp-1Ch]
  int v56; // [esp+84h] [ebp-14h]
  _BYTE *v57; // [esp+B8h] [ebp+20h]

  result = a5;
  v51 = a5 >> 1;
  v53 = (int *)(a1 + a8 * a2);
  v57 = (_BYTE *)(a8 + a7);
  v10 = (_WORD *)(a3 + a8 * a4);
  v52 = v10;
  if ( a9 )
  {
    v11 = (int)v10 + a5 + 8;
    v47 = v11;
    v54 = a9;
    do
    {
      *(_WORD *)&v38[4] = v10[4];
      v12 = v53;
      v39 = *(_WORD *)(2 - a5 + v11);
      *(_WORD *)v38 = *(_WORD *)(-4 - a5 + v11);
      *(_WORD *)&v38[2] = *(_WORD *)(-2 - a5 + v11);
      v13 = (_WORD *)(4 - a5 + v11);
      DWORD1(v40) = *(_DWORD *)(v11 - 8);
      *((_QWORD *)&v40 + 1) = *(_QWORD *)(v11 - 4);
      LOWORD(v40) = WORD3(v40);
      *(_WORD *)&v37[2] = *v10;
      v14 = *(_WORD *)(-6 - a5 + v11);
      WORD1(v40) = WORD2(v40);
      v15 = (_QWORD *)(v11 + 4);
      v50 = 2;
      v41 = v53;
      *(_WORD *)&v37[4] = v14;
      *(_WORD *)v37 = v14;
      v48 = v15;
      if ( v51 >= 8 )
        v34 = (v51 - 8) >> 2;
      else
        v34 = 0;
      if ( (unsigned int)v57 <= a6 || *v57 )
      {
        if ( v34 )
        {
          v31 = v34;
          do
          {
            v22 = 7250 * (SWORD1(v40) + SWORD3(v40))
                + 27400 * (*(__int16 *)&v37[2] + v14)
                + -2479 * ((__int16)v40 + SWORD4(v40))
                - 4230 * (*(__int16 *)v37 + *(__int16 *)v38)
                - 55882 * SWORD2(v40);
            v56 = 51674 * v14
                + 24733 * (SWORD3(v40) + SWORD2(v40))
                + -1563 * (SWORD1(v40) + SWORD4(v40))
                - 2667 * (*(__int16 *)&v37[2] + *(__int16 *)v38);
            v55 = 7250 * (SWORD2(v40) + SWORD4(v40))
                + 27400 * (v14 + *(__int16 *)v38)
                + -2479 * (SWORD1(v40) + SWORD5(v40))
                - 4230 * (*(__int16 *)&v37[2] + *(__int16 *)&v38[2])
                - 55882 * SWORD3(v40);
            v45 = 51674 * *(__int16 *)v38
                + 24733 * (SWORD3(v40) + SWORD4(v40))
                + -1563 * (SWORD2(v40) + SWORD5(v40))
                - 2667 * (*(__int16 *)&v38[2] + v14);
            v23 = 7250 * (SWORD4(v40) + SWORD6(v40))
                + 27400 * (*(__int16 *)&v38[2] + *(__int16 *)&v38[4])
                + -4230 * (*(__int16 *)v38 + v39)
                - 2479 * (SWORD3(v40) + SHIWORD(v40))
                - 55882 * SWORD5(v40);
            *v41 = (unsigned __int16)((51674 * *(__int16 *)&v37[2]
                                     + 24733 * (SWORD1(v40) + SWORD2(v40))
                                     + -2667 * (v14 + *(__int16 *)v37)
                                     - 1563 * ((__int16)v40 + SWORD3(v40))
                                     + (((51674 * *(__int16 *)&v37[2]
                                        + 24733 * (SWORD1(v40) + SWORD2(v40))
                                        + -2667 * (v14 + *(__int16 *)v37)
                                        - 1563 * ((__int16)v40 + SWORD3(v40))) >> 31) ^ 0x7FFF))
                                    / 0x10000) | (((v22 + ((v22 >> 31) ^ 0x7FFF)) / 0x10000) << 16);
            v24 = 7250 * (SWORD3(v40) + SWORD5(v40))
                + 27400 * (*(__int16 *)v38 + *(__int16 *)&v38[2])
                + -2479 * (SWORD2(v40) + SWORD6(v40))
                - 4230 * (v14 + *(__int16 *)&v38[4])
                - 55882 * SWORD4(v40);
            v41[1] = (unsigned __int16)((v56 + ((v56 >> 31) ^ 0x7FFF)) / 0x10000) | (((v55 + ((v55 >> 31) ^ 0x7FFF))
                                                                                    / 0x10000) << 16);
            v25 = v23 + ((v23 >> 31) ^ 0x7FFF);
            v26 = 51674 * *(__int16 *)&v38[2]
                + 24733 * (SWORD4(v40) + SWORD5(v40))
                + -1563 * (SWORD3(v40) + SWORD6(v40))
                - 2667 * (*(__int16 *)&v38[4] + *(__int16 *)v38);
            v41[2] = (unsigned __int16)((v45 + ((v45 >> 31) ^ 0x7FFF)) / 0x10000) | (((v24 + ((v24 >> 31) ^ 0x7FFF))
                                                                                    / 0x10000) << 16);
            v27 = (unsigned __int16)((v26 + ((v26 >> 31) ^ 0x7FFF)) / 0x10000) | ((v25 / 0x10000) << 16);
            v14 = v39;
            v41[3] = v27;
            *(_DWORD *)v37 = *(_DWORD *)&v38[2];
            *(_WORD *)v38 = *v13;
            *(_WORD *)&v38[2] = v13[1];
            *(_WORD *)&v38[4] = v13[2];
            v39 = v13[3];
            *(_QWORD *)&v40 = *((_QWORD *)&v40 + 1);
            *((_QWORD *)&v40 + 1) = *v48;
            v12 = v41 + 4;
            v15 = v48 + 1;
            v13 += 4;
            v17 = v31 == 1;
            v41 += 4;
            ++v48;
            --v31;
          }
          while ( !v17 );
          *(_WORD *)&v37[4] = v14;
        }
        v28 = a5 >> 1;
        if ( v51 >= 8 )
          v28 = ((a5 >> 1) & 3) + 8;
        if ( v28 )
        {
          v32 = v28;
          do
          {
            if ( v13 == (_WORD *)(v47 - 8) )
            {
              v13 = (_WORD *)((char *)v13 - v50);
              v48 = (_QWORD *)((char *)v15 - 2 * v50);
              v50 = -v50;
            }
            v29 = 51674 * *(__int16 *)&v37[2]
                + 24733 * (SWORD1(v40) + SWORD2(v40))
                + -2667 * (*(__int16 *)v37 + v14)
                - 1563 * ((__int16)v40 + SWORD3(v40));
            *v12 = (unsigned __int16)((v29 + ((v29 >> 31) ^ 0x7FFF)) / 0x10000) | (((7250 * (SWORD3(v40) + SWORD1(v40))
                                                                                   + 27400
                                                                                   * (*(__int16 *)&v37[4]
                                                                                    + *(__int16 *)&v37[2])
                                                                                   + -4230
                                                                                   * (*(__int16 *)v37 + *(__int16 *)v38)
                                                                                   - 2479 * ((__int16)v40 + SWORD4(v40))
                                                                                   - 55882 * SWORD2(v40)
                                                                                   + (((7250
                                                                                      * (SWORD3(v40) + SWORD1(v40))
                                                                                      + 27400
                                                                                      * (*(__int16 *)&v37[4]
                                                                                       + *(__int16 *)&v37[2])
                                                                                      + -4230
                                                                                      * (*(__int16 *)v37
                                                                                       + *(__int16 *)v38)
                                                                                      - 2479
                                                                                      * ((__int16)v40 + SWORD4(v40))
                                                                                      - 55882 * SWORD2(v40)) >> 31) ^ 0x7FFF))
                                                                                  / 0x10000) << 16);
            *(_DWORD *)v37 = *(_DWORD *)&v37[2];
            v14 = *(_WORD *)v38;
            *(_DWORD *)v38 = *(_DWORD *)&v38[2];
            ++v12;
            *(_WORD *)&v37[4] = v14;
            *(_WORD *)&v38[4] = v39;
            v39 = *v13;
            *(_QWORD *)&v40 = *(_QWORD *)((char *)&v40 + 2);
            DWORD2(v40) = *(_DWORD *)((char *)&v40 + 10);
            WORD6(v40) = HIWORD(v40);
            HIWORD(v40) = *(_WORD *)v48;
            v15 = (_QWORD *)((char *)v48 + v50);
            v13 = (_WORD *)((char *)v13 + v50);
            v17 = v32 == 1;
            v48 = (_QWORD *)((char *)v48 + v50);
            --v32;
          }
          while ( !v17 );
        }
        v19 = v47;
      }
      else
      {
        if ( v34 )
        {
          v42 = v34;
          do
          {
            v49 = 51674 * v14 - 2667 * (*(__int16 *)v38 + *(__int16 *)&v37[2]);
            v35 = 27400 * (*(__int16 *)v38 + v14) - 4230 * (*(__int16 *)&v38[2] + *(__int16 *)&v37[2]);
            v36 = 51674 * *(__int16 *)v38 - 2667 * (*(__int16 *)&v38[2] + v14);
            v46 = 27400 * (*(__int16 *)v38 + *(__int16 *)&v38[2]) - 4230 * (*(__int16 *)&v38[4] + v14);
            v33 = 51674 * *(__int16 *)&v38[2] - 2667 * (*(__int16 *)v38 + *(__int16 *)&v38[4]);
            v44 = 27400 * (*(__int16 *)&v38[4] + *(__int16 *)&v38[2]) - 4230 * (*(__int16 *)v38 + v39);
            *v12 = (unsigned __int16)((51674 * *(__int16 *)&v37[2]
                                     - 2667 * (v14 + *(__int16 *)v37)
                                     + (((51674 * *(__int16 *)&v37[2] - 2667 * (v14 + *(__int16 *)v37)) >> 31) ^ 0x7FFF))
                                    / 0x10000) | (((27400 * (v14 + *(__int16 *)&v37[2])
                                                  - 4230 * (*(__int16 *)v38 + *(__int16 *)v37)
                                                  + (((27400 * (v14 + *(__int16 *)&v37[2])
                                                     - 4230 * (*(__int16 *)v38 + *(__int16 *)v37)) >> 31) ^ 0x7FFF))
                                                 / 0x10000) << 16);
            v12[1] = (unsigned __int16)((v49 + ((v49 >> 31) ^ 0x7FFF)) / 0x10000) | (((v35 + ((v35 >> 31) ^ 0x7FFF))
                                                                                    / 0x10000) << 16);
            v12[2] = (unsigned __int16)((v36 + ((v36 >> 31) ^ 0x7FFF)) / 0x10000) | (((v46 + ((v46 >> 31) ^ 0x7FFF))
                                                                                    / 0x10000) << 16);
            v14 = v39;
            v12[3] = (unsigned __int16)((v33 + ((v33 >> 31) ^ 0x7FFF)) / 0x10000) | (((v44 + ((v44 >> 31) ^ 0x7FFF))
                                                                                    / 0x10000) << 16);
            *(_DWORD *)v37 = *(_DWORD *)&v38[2];
            *(_WORD *)&v38[2] = v13[1];
            v39 = v13[3];
            *(_WORD *)v38 = *v13;
            v16 = v13[2];
            v12 += 4;
            v13 += 4;
            v17 = v42 == 1;
            *(_WORD *)&v38[4] = v16;
            --v42;
          }
          while ( !v17 );
          *(_WORD *)&v37[4] = v14;
        }
        v18 = a5 >> 1;
        v19 = v47;
        if ( v51 >= 8 )
          v18 = ((a5 >> 1) & 3) + 8;
        if ( v18 )
        {
          v43 = v18;
          v20 = *(_WORD *)v37;
          do
          {
            if ( v13 == (_WORD *)(v19 - 8) )
            {
              --v13;
              v50 = -2;
            }
            v21 = 51674 * *(__int16 *)&v37[2] - 2667 * (v20 + v14);
            v30 = ((27400 * (*(__int16 *)&v37[2] + v14)
                  - 4230 * (v20 + *(__int16 *)v38)
                  + (((27400 * (*(__int16 *)&v37[2] + v14) - 4230 * (v20 + *(__int16 *)v38)) >> 31) ^ 0x7FFF))
                 / 0x10000) << 16;
            v20 = *(_WORD *)&v37[2];
            *v12 = (unsigned __int16)((v21 + ((v21 >> 31) ^ 0x7FFF)) / 0x10000) | v30;
            *(_WORD *)&v37[2] = *(_WORD *)&v37[4];
            v14 = *(_WORD *)v38;
            *(_DWORD *)v38 = *(_DWORD *)&v38[2];
            *(_WORD *)&v38[4] = v39;
            v39 = *v13;
            v13 = (_WORD *)((char *)v13 + v50);
            ++v12;
            v17 = v43-- == 1;
            v19 = v47;
            *(_WORD *)&v37[4] = v14;
          }
          while ( !v17 );
        }
      }
      v10 = (_WORD *)((char *)v52 + a4);
      v11 = a4 + v19;
      result = v54 - 1;
      v17 = v54 == 1;
      v53 = (int *)((char *)v53 + a2);
      v52 = (_WORD *)((char *)v52 + a4);
      v47 = v11;
      ++v57;
      --v54;
    }
    while ( !v17 );
  }
  return result;
}

//----- (10008950) --------------------------------------------------------
int __cdecl sub_10008950(
        int *a1,
        int a2,
        _DWORD *a3,
        int a4,
        unsigned int a5,
        int a6,
        unsigned int a7,
        unsigned int a8)
{
  _DWORD *v8; // esi
  __int16 *v9; // ecx
  int result; // eax
  int v11; // edi
  int v12; // edx
  __int16 *v13; // esi
  __int16 *v14; // ecx
  _DWORD *v15; // eax
  int v16; // eax
  bool v17; // zf
  __int16 *v18; // ecx
  __int16 *v19; // esi
  int v20; // ecx
  int v21; // edx
  __int16 *v22; // esi
  int v23; // edx
  int v24; // ecx
  int v25; // eax
  int *v26; // [esp+8h] [ebp-1E0h]
  __int16 *v27; // [esp+8h] [ebp-1E0h]
  int *v28; // [esp+Ch] [ebp-1DCh]
  __int16 *v29; // [esp+Ch] [ebp-1DCh]
  __int16 *v30; // [esp+10h] [ebp-1D8h]
  __int16 *v31; // [esp+10h] [ebp-1D8h]
  _DWORD *v32; // [esp+14h] [ebp-1D4h]
  __int16 *v33; // [esp+14h] [ebp-1D4h]
  _DWORD *v34; // [esp+18h] [ebp-1D0h]
  int *v35; // [esp+1Ch] [ebp-1CCh]
  __int16 *v36; // [esp+1Ch] [ebp-1CCh]
  __int16 *v37; // [esp+20h] [ebp-1C8h]
  unsigned int v38; // [esp+24h] [ebp-1C4h]
  unsigned int v39; // [esp+24h] [ebp-1C4h]
  int v40; // [esp+28h] [ebp-1C0h]
  int v41; // [esp+28h] [ebp-1C0h]
  int v42; // [esp+2Ch] [ebp-1BCh]
  int v43; // [esp+30h] [ebp-1B8h]
  int v44; // [esp+30h] [ebp-1B8h]
  int v45; // [esp+30h] [ebp-1B8h]
  _DWORD *v46; // [esp+34h] [ebp-1B4h]
  int *v47; // [esp+38h] [ebp-1B0h]
  unsigned int v48; // [esp+3Ch] [ebp-1ACh]
  int *v49; // [esp+3Ch] [ebp-1ACh]
  int v50; // [esp+40h] [ebp-1A8h]
  __int16 *v51; // [esp+40h] [ebp-1A8h]
  __int16 *v52; // [esp+44h] [ebp-1A4h]
  __int16 *v53; // [esp+48h] [ebp-1A0h]
  __int16 *v54; // [esp+4Ch] [ebp-19Ch]
  int *v55; // [esp+50h] [ebp-198h]
  int v56; // [esp+54h] [ebp-194h]
  int v57; // [esp+58h] [ebp-190h]
  int v58; // [esp+5Ch] [ebp-18Ch]
  int v59; // [esp+60h] [ebp-188h]
  int v60; // [esp+64h] [ebp-184h]
  int v61; // [esp+68h] [ebp-180h]
  int v62; // [esp+68h] [ebp-180h]
  int v63; // [esp+6Ch] [ebp-17Ch]
  int v64; // [esp+6Ch] [ebp-17Ch]
  int v65; // [esp+70h] [ebp-178h]
  int v66; // [esp+70h] [ebp-178h]
  int v67; // [esp+74h] [ebp-174h]
  int v68; // [esp+7Ch] [ebp-16Ch]
  int v69; // [esp+80h] [ebp-168h]
  int v70; // [esp+84h] [ebp-164h]
  unsigned int v71; // [esp+88h] [ebp-160h]
  int v72; // [esp+8Ch] [ebp-15Ch]
  int v73; // [esp+90h] [ebp-158h]
  int v74; // [esp+94h] [ebp-154h]
  int v75; // [esp+A0h] [ebp-148h] BYREF
  int v76; // [esp+A4h] [ebp-144h]
  int v77; // [esp+A8h] [ebp-140h]
  int v78; // [esp+ACh] [ebp-13Ch]
  int v79; // [esp+B0h] [ebp-138h]
  int v80; // [esp+B4h] [ebp-134h]
  int v81; // [esp+B8h] [ebp-130h]
  int v82; // [esp+BCh] [ebp-12Ch]
  int v83; // [esp+140h] [ebp-A8h] BYREF
  int v84; // [esp+144h] [ebp-A4h]
  int v85; // [esp+148h] [ebp-A0h]
  int v86; // [esp+14Ch] [ebp-9Ch]
  int v87; // [esp+150h] [ebp-98h]
  int v88; // [esp+154h] [ebp-94h]
  int v89; // [esp+158h] [ebp-90h]
  int v90; // [esp+15Ch] [ebp-8Ch]
  int v91; // [esp+160h] [ebp-88h]
  int v92; // [esp+164h] [ebp-84h]
  int v93; // [esp+1FCh] [ebp+14h]

  v71 = a8 >> 1;
  v47 = a1;
  v8 = a3;
  v9 = (__int16 *)((char *)a3 + a4);
  v53 = (__int16 *)((char *)a3 + a6 * a4);
  result = 2 * a4;
  v11 = a2;
  v34 = a3;
  v37 = (__int16 *)((char *)a3 + a4);
  v93 = 2 * a4;
  if ( a7 )
  {
    v47 = (int *)((char *)a1 + a7 * a2);
    v34 = (_DWORD *)((char *)a3 + result * ((a7 >> 1) - 1));
    v8 = v34;
    v9 = (__int16 *)((char *)v9 + result * ((a7 >> 1) - 2));
    v37 = v9;
  }
  if ( a5 >> 2 )
  {
    v55 = (int *)((char *)v9 + result);
    v28 = (_DWORD *)((char *)v8 + result);
    v54 = &v9[result];
    v26 = (_DWORD *)((char *)v8 + 2 * result);
    v32 = (_DWORD *)((char *)v9 + 3 * result);
    v30 = (__int16 *)((char *)v34 + 3 * result);
    v40 = (int)&v9[2 * result] + result;
    v12 = 4 - result;
    v50 = 4 - result;
    v48 = a5 >> 2;
    do
    {
      v42 = result;
      v35 = v47;
      v13 = (__int16 *)&v75;
      v14 = (__int16 *)&v83;
      if ( a7 )
      {
        v75 = *v34;
        v76 = *(int *)((char *)v28 + v12);
        v83 = *(_DWORD *)v37;
        v84 = *(int *)((char *)v55 + v12);
        v77 = *v28;
        v78 = *(int *)((char *)v26 + v12);
        v85 = *v55;
        v86 = *(_DWORD *)((char *)v54 + v12);
        v79 = *v26;
        v80 = *(_DWORD *)((char *)v30 + v12);
        v87 = *(_DWORD *)v54;
        v88 = *(_DWORD *)((char *)v32 + v12);
        v81 = *(_DWORD *)v30;
        v82 = *(_DWORD *)((char *)&v30[v93 / 2u] + v50);
        v52 = &v30[v93 / 2u];
        v89 = *v32;
        v12 = v50;
        v90 = *(_DWORD *)((char *)v32 + v93 + v50);
        v91 = *(_DWORD *)((char *)v32 + v93);
        v92 = *(_DWORD *)(v50 + v40);
        v15 = (_DWORD *)v40;
      }
      else
      {
        v77 = *v34;
        v78 = *(int *)((char *)v28 + v12);
        v79 = *v28;
        v75 = v79;
        v80 = *(int *)((char *)v26 + v12);
        v76 = v80;
        v81 = *v26;
        v82 = *(_DWORD *)((char *)v30 + v12);
        v52 = v30;
        v87 = *(_DWORD *)v37;
        v85 = v87;
        v88 = *(int *)((char *)v55 + v12);
        v86 = v88;
        v89 = *v55;
        v83 = v89;
        v90 = *(_DWORD *)((char *)v54 + v12);
        v84 = v90;
        v91 = *(_DWORD *)v54;
        v92 = *(_DWORD *)((char *)v32 + v12);
        v15 = v32;
      }
      v46 = v15;
      if ( v71 )
      {
        v38 = a8 >> 1;
        v16 = v42;
        do
        {
          if ( v52 == v53 )
          {
            v52 = (__int16 *)((char *)v52 - v16);
            v46 = (_DWORD *)((char *)v46 - 2 * v16);
            v42 = -v16;
          }
          v61 = v14[8];
          v72 = 51674 * v13[4] + 24733 * (v61 + v14[4]) + -1563 * (*v14 + v14[12]) - 2667 * (v13[8] + *v13);
          v63 = v14[9];
          v74 = 51674 * v13[5] + 24733 * (v63 + v14[5]) + -1563 * (v14[13] + v14[1]) - 2667 * (v13[9] + v13[1]);
          v65 = v14[10];
          v67 = 51674 * v13[6] + 24733 * (v65 + v14[6]) + -1563 * (v14[14] + v14[2]) - 2667 * (v13[10] + v13[2]);
          v43 = v14[11];
          v73 = 51674 * v13[7] + 24733 * (v43 + v14[7]) + -1563 * (v14[15] + v14[3]) - 2667 * (v13[11] + v13[3]);
          v62 = 27400 * (v13[8] + v13[4])
              + 7250 * (v14[4] + v14[12])
              + -2479 * (*v14 + v14[16])
              - 4230 * (*v13 + v13[12])
              - 55882 * v61;
          v64 = 27400 * (v13[9] + v13[5])
              + 7250 * (v14[13] + v14[5])
              + -2479 * (v14[1] + v14[17])
              - 4230 * (v13[1] + v13[13])
              - 55882 * v63;
          v66 = 27400 * (v13[10] + v13[6])
              + 7250 * (v14[14] + v14[6])
              + -2479 * (v14[2] + v14[18])
              - 4230 * (v13[2] + v13[14])
              - 55882 * v65;
          v44 = 27400 * (v13[11] + v13[7])
              + 7250 * (v14[15] + v14[7])
              + -2479 * (v14[3] + v14[19])
              - 4230 * (v13[3] + v13[15])
              - 55882 * v43;
          *v35 = (unsigned __int16)((v72 + ((v72 >> 31) ^ 0x7FFF)) / 0x10000) | (((v74 + ((v74 >> 31) ^ 0x7FFF))
                                                                                / 0x10000) << 16);
          v35[1] = (unsigned __int16)((v67 + ((v67 >> 31) ^ 0x7FFF)) / 0x10000) | (((v73 + ((v73 >> 31) ^ 0x7FFF))
                                                                                  / 0x10000) << 16);
          *(int *)((char *)v35 + a2) = (unsigned __int16)((v62 + ((v62 >> 31) ^ 0x7FFF)) / 0x10000) | (((v64 + ((v64 >> 31) ^ 0x7FFF)) / 0x10000) << 16);
          v11 = a2;
          *(int *)((char *)v35 + a2 + 4) = (unsigned __int16)((v66 + ((v66 >> 31) ^ 0x7FFF)) / 0x10000) | (((v44 + ((v44 >> 31) ^ 0x7FFF)) / 0x10000) << 16);
          v13 += 4;
          v35 = (int *)((char *)v35 + 2 * a2);
          v14 += 4;
          if ( v13 + 12 == (__int16 *)&v83 )
          {
            v75 = *((_DWORD *)v13 + 2);
            v76 = *((_DWORD *)v13 + 3);
            v77 = *((_DWORD *)v13 + 4);
            v78 = *((_DWORD *)v13 + 5);
            v79 = *((_DWORD *)v13 + 6);
            v80 = *((_DWORD *)v13 + 7);
            v83 = *((_DWORD *)v14 + 2);
            v84 = *((_DWORD *)v14 + 3);
            v85 = *((_DWORD *)v14 + 4);
            v86 = *((_DWORD *)v14 + 5);
            v87 = *((_DWORD *)v14 + 6);
            v88 = *((_DWORD *)v14 + 7);
            v89 = *((_DWORD *)v14 + 8);
            v90 = *((_DWORD *)v14 + 9);
            v13 = (__int16 *)&v75;
            v14 = (__int16 *)&v83;
          }
          *((_DWORD *)v13 + 6) = *(_DWORD *)v52;
          *((_DWORD *)v13 + 7) = *((_DWORD *)v52 + 1);
          *((_DWORD *)v14 + 8) = *v46;
          *((_DWORD *)v14 + 9) = v46[1];
          v16 = v42;
          v52 = (__int16 *)((char *)v52 + v42);
          v46 = (_DWORD *)((char *)v46 + v42);
          --v38;
        }
        while ( v38 );
        v12 = v50;
      }
      v47 += 2;
      v37 += 4;
      v55 += 2;
      v54 += 4;
      v32 += 2;
      v40 += 8;
      v34 += 2;
      v28 += 2;
      v26 += 2;
      v17 = v48-- == 1;
      result = v93;
      v30 += 4;
      v53 += 4;
    }
    while ( !v17 );
    v9 = v37;
    v8 = v34;
  }
  if ( (a5 & 3) != 0 )
  {
    v29 = (__int16 *)((char *)v9 + result);
    v33 = (__int16 *)((char *)v9 + 3 * result);
    v18 = (__int16 *)v34;
    v19 = (__int16 *)((char *)v8 + result);
    v36 = (__int16 *)((char *)v34 + 3 * result);
    v51 = v19;
    v45 = a5 & 3;
    do
    {
      v20 = *v18;
      v49 = v47;
      v21 = *v19;
      v41 = result;
      if ( a7 )
      {
        v68 = *v19;
        v21 = *(__int16 *)((char *)v19 + result);
        v70 = *v36;
        v31 = (__int16 *)((char *)v36 + result);
        v56 = *v37;
        v57 = *v29;
        v58 = *(__int16 *)((char *)v29 + result);
        v59 = *v33;
        v60 = *(__int16 *)((char *)v33 + result);
        v22 = (__int16 *)((char *)v33 + result + result);
      }
      else
      {
        v70 = *(__int16 *)((char *)v19 + result);
        v31 = v36;
        v58 = *v37;
        v57 = v58;
        v59 = *v29;
        v56 = v59;
        v68 = v20;
        v60 = *(__int16 *)((char *)v29 + result);
        v22 = v33;
        v20 = v21;
      }
      v27 = v22;
      v69 = v21;
      if ( v71 )
      {
        v39 = a8 >> 1;
        do
        {
          if ( v31 == v53 )
          {
            v31 = (__int16 *)((char *)v31 - v41);
            v27 -= v41;
            v41 = -v41;
          }
          v23 = 51674 * v68 + 24733 * (v57 + v58) + -2667 * (v20 + v21) - 1563 * (v56 + v59);
          v24 = 27400 * (v68 + v69) + 7250 * (v57 + v59) + -4230 * (v70 + v20) - 2479 * (v56 + v60) - 55882 * v58;
          *(_WORD *)v49 = (v23 + ((v23 >> 31) ^ 0x7FFF)) / 0x10000;
          v25 = v24 + ((v24 >> 31) ^ 0x7FFF);
          v20 = v68;
          *(_WORD *)((char *)v49 + v11) = v25 / 0x10000;
          v49 = (int *)((char *)v49 + 2 * v11);
          v68 = v69;
          v21 = v70;
          v70 = *v31;
          v56 = v57;
          v57 = v58;
          v58 = v59;
          v59 = v60;
          v60 = *v27;
          v31 = (__int16 *)((char *)v31 + v41);
          v69 = v21;
          v27 = (__int16 *)((char *)v27 + v41);
          --v39;
        }
        while ( v39 );
        result = v93;
      }
      v47 = (int *)((char *)v47 + 2);
      ++v37;
      ++v29;
      v19 = v51 + 1;
      ++v33;
      v18 = (__int16 *)v34 + 1;
      ++v36;
      ++v53;
      v17 = v45 == 1;
      v34 = (_DWORD *)((char *)v34 + 2);
      ++v51;
      --v45;
    }
    while ( !v17 );
  }
  return result;
}

//----- (100094C0) --------------------------------------------------------
int __cdecl sub_100094C0(int a1, int a2, int a3, int a4, unsigned int a5, unsigned int a6, int a7, int a8, int a9)
{
  int *v9; // edi
  unsigned __int16 *v10; // edx
  _BYTE *v11; // ebx
  int result; // eax
  unsigned int v13; // ebp
  int *v14; // esi
  unsigned __int16 *v15; // ecx
  unsigned int v16; // ebx
  int v17; // ebx
  int v18; // edx
  bool v19; // zf
  unsigned int v20; // [esp+Ch] [ebp-4h]
  unsigned __int16 *v21; // [esp+14h] [ebp+4h]
  int v22; // [esp+1Ch] [ebp+Ch]
  char *v23; // [esp+24h] [ebp+14h]
  _BYTE *v24; // [esp+2Ch] [ebp+1Ch]
  int *v25; // [esp+30h] [ebp+20h]

  v9 = (int *)(a1 + a8 * a2);
  v10 = (unsigned __int16 *)(a3 + a8 * a4);
  v11 = (_BYTE *)(a8 + a7);
  result = a9;
  v13 = a5 >> 1;
  v20 = a5 >> 1;
  v25 = v9;
  v21 = v10;
  v24 = v11;
  if ( a9 )
  {
    v23 = (char *)v10 + a5;
    v22 = a9;
    do
    {
      v14 = v9;
      v15 = v10;
      if ( (unsigned int)v11 <= a6 || *v11 )
      {
        if ( v13 )
        {
          v17 = v23 - (char *)v10;
          do
          {
            v18 = *(__int16 *)((char *)v15 + v17);
            *v14++ = (unsigned __int16)((v18 + 2 * (__int16)*v15 + (((v18 + 2 * (__int16)*v15) >> 31) ^ 1)) / 2) | (((2 * (__int16)*v15 - v18 + (((2 * (__int16)*v15 - v18) >> 31) ^ 1)) / 2) << 16);
            ++v15;
            --v13;
          }
          while ( v13 );
          v9 = v25;
          v10 = v21;
          goto LABEL_13;
        }
      }
      else if ( v13 )
      {
        v16 = v13;
        do
        {
          *v14++ = *v15 | ((__int16)*v15 << 16);
          ++v15;
          --v16;
        }
        while ( v16 );
LABEL_13:
        v13 = v20;
      }
      v9 = (int *)((char *)v9 + a2);
      v10 = (unsigned __int16 *)((char *)v10 + a4);
      v11 = v24 + 1;
      result = v22 - 1;
      v19 = v22 == 1;
      v25 = v9;
      v21 = v10;
      v23 += a4;
      ++v24;
      --v22;
    }
    while ( !v19 );
  }
  return result;
}

//----- (100095F0) --------------------------------------------------------
int __cdecl sub_100095F0(_WORD *a1, int a2, char *a3, int a4, int a5, int a6, unsigned int a7, unsigned int a8)
{
  char *v8; // esi
  unsigned int v10; // edx
  char *v11; // ebp
  int v12; // ebx
  int v13; // ecx
  int result; // eax
  _WORD *v15; // ecx
  int v16; // ebp
  int v17; // edx
  int v18; // eax
  __int64 v19; // rax
  bool v20; // zf
  unsigned int v21; // [esp+10h] [ebp-4h]
  char *v22; // [esp+18h] [ebp+4h]
  char *v23; // [esp+20h] [ebp+Ch]
  int v24; // [esp+24h] [ebp+10h]
  unsigned int v25; // [esp+30h] [ebp+1Ch]
  _WORD *v26; // [esp+34h] [ebp+20h]

  v8 = a3;
  v10 = a8 >> 1;
  v11 = &a3[a4];
  v12 = 2 * a4;
  v21 = a8 >> 1;
  v26 = a1;
  v22 = a3;
  v23 = &a3[a4];
  v24 = 2 * a4;
  if ( a7 )
  {
    v13 = v12 * (a7 >> 1);
    v26 = (_WORD *)((char *)a1 + a7 * a2);
    v11 += v13;
    v22 = &v8[v13];
    v23 = v11;
    v8 += v13;
  }
  result = a5;
  if ( a5 )
  {
    do
    {
      v15 = v26;
      if ( v10 )
      {
        v16 = v11 - v8;
        v25 = v10;
        do
        {
          v17 = *(__int16 *)&v8[v16];
          v18 = 2 * *(__int16 *)v8;
          *v15 = (v17 + v18 + (((v17 + v18) >> 31) ^ 1)) / 2;
          v19 = v18 - v17 + (((v18 - v17) >> 31) ^ 1);
          *(_WORD *)((char *)v15 + a2) = ((int)v19 - HIDWORD(v19)) >> 1;
          v15 += a2;
          v8 += v24;
          --v25;
        }
        while ( v25 );
        v10 = v21;
        v8 = v22;
      }
      v11 = v23 + 2;
      v8 += 2;
      result = a5 - 1;
      v20 = a5 == 1;
      ++v26;
      v23 += 2;
      v22 = v8;
      --a5;
    }
    while ( !v20 );
  }
  return result;
}

//----- (10009700) --------------------------------------------------------
unsigned int __cdecl sub_10009700(int a1, int a2, unsigned int a3, unsigned int a4, int a5, int a6)
{
  unsigned int v6; // ebp
  int v7; // eax
  unsigned int v8; // edi
  unsigned int v9; // ebx
  int v10; // ebx
  unsigned int result; // eax
  unsigned int v12; // [esp+0h] [ebp-10h]
  int v13; // [esp+4h] [ebp-Ch]
  void (__cdecl *v14)(int, int, int, int, unsigned int, unsigned int, int, unsigned int, int); // [esp+8h] [ebp-8h]
  void (__cdecl *v15)(int, int, int, int, unsigned int, unsigned int, int, unsigned int); // [esp+Ch] [ebp-4h]

  v14 = (void (__cdecl *)(int, int, int, int, unsigned int, unsigned int, int, unsigned int, int))sub_10007D70;
  if ( a3 < 0xC )
    v14 = (void (__cdecl *)(int, int, int, int, unsigned int, unsigned int, int, unsigned int, int))sub_100094C0;
  v6 = a4;
  v15 = (void (__cdecl *)(int, int, int, int, unsigned int, unsigned int, int, unsigned int))sub_10008950;
  if ( a4 < 0xA )
    v15 = (void (__cdecl *)(int, int, int, int, unsigned int, unsigned int, int, unsigned int))sub_100095F0;
  if ( a4 > 0x10 )
  {
    a4 = 12;
    v7 = 12;
  }
  else
  {
    v7 = a4;
  }
  v8 = v6 - v7;
  v9 = v6;
  v13 = 0;
  v12 = v6;
  v14(a6, a2, a1, a2, a3, v6, a5, 0, v7);
  while ( 1 )
  {
    if ( v9 > 0xC )
      v9 = 8;
    v15(a1, a2, a6, a2, a3, v6, v13, v9);
    v13 += v9;
    v12 -= v9;
    if ( v8 )
    {
      v10 = v8;
      if ( v8 > 0xC )
        v10 = 8;
      v14(a6, a2, a1, a2, a3, v6, a5, a4, v10);
      a4 += v10;
      v8 -= v10;
    }
    result = v12;
    if ( !v12 )
      break;
    v9 = v12;
  }
  return result;
}

//----- (10009830) --------------------------------------------------------
int __cdecl sub_10009830(
        char *a1,
        char *a2,
        char *a3,
        char *a4,
        int a5,
        int a6,
        unsigned __int8 *a7,
        int a8,
        int a9,
        int a10)
{
  int v10; // ecx
  char *v11; // ebx
  char *v12; // ebp
  int v15; // eax
  __int16 v16; // dx
  __int16 v17; // cx
  __int16 v18; // ax
  bool v19; // zf
  int result; // eax
  int v21; // esi
  int v22; // [esp+10h] [ebp-8h]
  __int16 v23; // [esp+14h] [ebp-4h]
  int v24; // [esp+1Ch] [ebp+4h]
  int v25; // [esp+24h] [ebp+Ch]
  unsigned int v26; // [esp+34h] [ebp+1Ch]

  v10 = a10;
  v11 = a2;
  v12 = a3;
  if ( a10 )
  {
    v15 = a9;
    v26 = a5 - a9;
    v22 = a10;
    while ( 1 )
    {
      if ( v15 )
      {
        v24 = v15;
        do
        {
          v16 = a7[1];
          v23 = a7[3];
          v17 = a7[2];
          v18 = *a7;
          *(_WORD *)a1 = (*a7 + a7[2] + 2 * (unsigned int)a7[1]) >> 2;
          *(_WORD *)a2 = v18 - v16;
          *(_WORD *)a3 = v17 - v16;
          *(_WORD *)a4 = v23;
          a4 += 2;
          v11 = a2 + 2;
          v12 = a3 + 2;
          a1 += 2;
          a7 += 4;
          v19 = v24 == 1;
          a2 += 2;
          a3 += 2;
          --v24;
        }
        while ( !v19 );
      }
      a1 = sub_100099F0((int)v11, a1, *((_WORD *)a1 - 1), v26);
      v11 = sub_100099F0((int)v11, v11, *((_WORD *)v11 - 1), v26);
      a2 = v11;
      v12 = sub_100099F0((int)v11, v12, *((_WORD *)v12 - 1), v26);
      a3 = v12;
      a4 = sub_100099F0((int)v11, a4, *((_WORD *)a4 - 1), v26);
      a7 += a8 - 4 * a9;
      if ( !--v22 )
        break;
      v15 = a9;
    }
    v10 = a10;
  }
  result = a6 - v10;
  if ( a6 != v10 )
  {
    v21 = 2 * a5;
    v25 = a6 - v10;
    do
    {
      sub_10019E10(v21, &a1[-v21], (int)a1);
      sub_10019E10(v21, &v11[-v21], (int)v11);
      sub_10019E10(v21, &v12[-v21], (int)v12);
      sub_10019E10(v21, &a4[-v21], (int)a4);
      a1 += v21;
      v11 += v21;
      v12 += v21;
      result = v25 - 1;
      v19 = v25 == 1;
      a4 += v21;
      --v25;
    }
    while ( !v19 );
  }
  return result;
}

//----- (100099F0) --------------------------------------------------------
char *__usercall sub_100099F0@<eax>(int a1@<ebx>, char *a2, __int16 a3, unsigned int a4)
{
  int v4; // ebx
  char *v5; // edi
  int i; // ecx

  if ( !a4 )
    return a2;
  LOWORD(a1) = a3;
  v4 = a1 << 16;
  LOWORD(v4) = a3;
  memset32(a2, v4, a4 >> 1);
  v5 = &a2[4 * (a4 >> 1)];
  for ( i = a4 & 1; i; --i )
  {
    *(_WORD *)v5 = a3;
    v5 += 2;
  }
  return &a2[2 * a4];
}
// 100099F0: could not find valid save-restore pair for ebx

//----- (10009A30) --------------------------------------------------------
int __cdecl sub_10009A30(int *a1, __int16 *a2, __int16 *a3, __int16 *a4, __int16 *a5, int a6, int a7, int a8)
{
  int v8; // edx
  int result; // eax
  int v11; // esi
  int v12; // ebx
  int v13; // edi
  int v14; // ecx
  int v15; // esi
  int v16; // ebx
  int v17; // edi
  bool v18; // zf
  int v19; // [esp+0h] [ebp-4h]
  int v20; // [esp+1Ch] [ebp+18h]

  v8 = a7;
  result = a6 - 4 * a7;
  v19 = result;
  if ( a8 )
  {
    do
    {
      if ( v8 )
      {
        v20 = v8;
        do
        {
          v11 = *a2;
          v12 = *a3;
          ++a2;
          v13 = *a4++;
          v14 = *a5++;
          v15 = (v13 + v12) / -4 + v11;
          ++a3;
          v16 = v15 + v12;
          v17 = v15 + v13;
          if ( v14 >= 0 )
          {
            if ( v14 > 255 )
              v14 = 255;
          }
          else
          {
            v14 = 0;
          }
          if ( v16 >= 0 )
          {
            if ( v16 > 255 )
              v16 = 255;
          }
          else
          {
            v16 = 0;
          }
          if ( v15 >= 0 )
          {
            if ( v15 > 255 )
              v15 = 255;
          }
          else
          {
            v15 = 0;
          }
          if ( v17 >= 0 )
          {
            if ( v17 > 255 )
              v17 = 255;
          }
          else
          {
            v17 = 0;
          }
          *a1++ = v16 | ((v15 | ((v17 | (v14 << 8)) << 8)) << 8);
          --v20;
        }
        while ( v20 );
        v8 = a7;
        result = v19;
      }
      v18 = a8 == 1;
      a1 = (int *)((char *)a1 + result);
      --a8;
    }
    while ( !v18 );
  }
  return result;
}

//----- (10009B60) --------------------------------------------------------
int *__cdecl sub_10009B60(char a1)
{
  int *result; // eax

  result = &dword_1002A228;
  if ( !a1 )
    return (int *)&unk_1002A204;
  return result;
}
// 1002A228: using guessed type int dword_1002A228;

//----- (10009B80) --------------------------------------------------------
unsigned int __cdecl sub_10009B80(int a1, int a2, char a3, int a4)
{
  char v4; // si
  int v5; // eax
  int v7; // [esp-8h] [ebp-8h]

  if ( !sub_10009C30(&a1, &a2) )
    return a2 * a1 * sub_10009BF0(a3);
  v4 = a3;
  v7 = sub_10009C00(a1, a2, a3, a4);
  v5 = sub_10009BF0(v4);
  return sub_100043B0(a1, a2, v5, v7);
}

//----- (10009BF0) --------------------------------------------------------
int __cdecl sub_10009BF0(char a1)
{
  return (a1 != 0) + 3;
}

//----- (10009C00) --------------------------------------------------------
int __cdecl sub_10009C00(int a1, int a2, char a3, int a4)
{
  int v4; // esi

  v4 = a4;
  if ( a4 < 1 )
    v4 = 1;
  return a2 * a1 * sub_10009BF0(a3) / v4;
}

//----- (10009C30) --------------------------------------------------------
char __cdecl sub_10009C30(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // esi
  _DWORD *v3; // edi
  _DWORD *v4; // ecx
  _DWORD *v5; // eax

  v2 = a1;
  v3 = a2;
  v4 = (_DWORD *)*a2;
  if ( *a1 * *a2 <= 256 )
    return 0;
  a1 = (_DWORD *)*a1;
  a2 = v4;
  sub_10004400((unsigned int *)&a1, (unsigned int *)&a2);
  v5 = a2;
  *v2 = a1;
  *v3 = v5;
  return 1;
}

//----- (10009C80) --------------------------------------------------------
int __cdecl sub_10009C80(int a1, int a2, int a3, unsigned __int8 *a4, char a5, int a6, unsigned int *a7)
{
  int v8; // eax
  int v9; // edi
  unsigned int v10; // ebx
  int v11; // ebp
  int v12; // ebp
  unsigned int v13; // edi
  int i; // esi
  int v16; // eax
  unsigned int v17; // edi
  int v18; // ebx
  int v19; // esi
  unsigned int *v20; // edx
  unsigned int v21; // [esp+Ch] [ebp-2Ch] BYREF
  int v22; // [esp+10h] [ebp-28h] BYREF
  unsigned int v23; // [esp+14h] [ebp-24h]
  char *v24[4]; // [esp+18h] [ebp-20h] BYREF
  _DWORD v25[4]; // [esp+28h] [ebp-10h] BYREF
  unsigned int v26; // [esp+4Ch] [ebp+14h]
  int v27; // [esp+50h] [ebp+18h]

  v21 = a1;
  v22 = a2;
  if ( sub_10009C30(&v21, &v22) )
  {
    v25[0] = 1086324736;
    v25[1] = 1065353216;
    v25[2] = 1065353216;
    v25[3] = 1065353216;
    v8 = sub_10009BF0(a5);
    v9 = v22;
    v10 = v21;
    v23 = v8;
    v26 = sub_10004380(v21, v22);
    v22 = off_10033620((int)aWPublicGrannyR_0, 3809, 4, v26);
    v11 = 0;
    v27 = sub_10009C00(v10, v9, a5, a6);
    do
      v24[v11++] = (char *)off_10033620((int)aWPublicGrannyR_0, 3816, 4, 2 * v10 * v9);
    while ( v11 < 4 );
    sub_10009830(v24[0], v24[1], v24[2], v24[3], v10, v9, a4, a3, a1, a2);
    v12 = v22;
    v13 = sub_10004420(a7, v27, (int)v24, (int)v25, v23, v10, v9, v22, v26);
    for ( i = 0; i < 4; ++i )
      off_10033624((int)aWPublicGrannyR_0, 3830, (int)v24[i]);
    off_10033624((int)aWPublicGrannyR_0, 3833, v12);
    return v13;
  }
  else
  {
    v16 = sub_10009BF0(a5);
    v17 = v21;
    v18 = v22;
    v19 = v16;
    sub_10002980(v21, v22, &dword_1002A228, a3, (int *)a4, v20, v21 * v16, a7);
    return v17 * v18 * v19;
  }
}
// 10009E2B: variable 'v20' is possibly undefined
// 1002A228: using guessed type int dword_1002A228;
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10009E50) --------------------------------------------------------
unsigned int *__cdecl sub_10009E50(int *a1, int a2, char a3, int *a4, unsigned int *a5, int a6, unsigned int *a7)
{
  int v7; // ebp
  int v8; // eax
  unsigned int v9; // edi
  int v10; // esi
  int v11; // ebx
  int v12; // esi
  int v13; // ebx
  int v14; // esi
  int *v15; // edi
  int i; // esi
  int v18; // eax
  _DWORD *v19; // edx
  int v20; // [esp-34h] [ebp-50h]
  unsigned int v21; // [esp+0h] [ebp-1Ch] BYREF
  unsigned int v22; // [esp+4h] [ebp-18h] BYREF
  unsigned int v23; // [esp+8h] [ebp-14h]
  __int16 *v24[4]; // [esp+Ch] [ebp-10h] BYREF
  _BYTE *v25; // [esp+28h] [ebp+Ch]

  v22 = (unsigned int)a1;
  v21 = a2;
  if ( sub_10009C30(&v22, &v21) )
  {
    v23 = sub_10009BF0(a3);
    v7 = sub_100043A0((int)a4);
    v8 = off_10033620((int)aWPublicGrannyR_0, 3861, 4, v7);
    v9 = v22;
    v10 = v22 * v21;
    v25 = (_BYTE *)v8;
    v11 = 0;
    v22 = off_10033620((int)aWPublicGrannyR_0, 3863, 4, 4 * v22 * v21);
    v12 = 2 * v10;
    do
      v24[v11++] = (__int16 *)off_10033620((int)aWPublicGrannyR_0, 3869, 4, v12);
    while ( v11 < 4 );
    v13 = v21;
    sub_100045B0((int)v24, v23, (int)a4, v9, v21, v25, v7);
    v20 = v9;
    v14 = 4 * v9;
    v15 = (int *)v22;
    sub_10009A30((int *)v22, v24[0], v24[1], v24[2], v24[3], v14, v20, v13);
    sub_10002980((unsigned int)a1, a2, &dword_1002A228, v14, v15, a5, a6, a7);
    for ( i = 0; i < 4; ++i )
      off_10033624((int)aWPublicGrannyR_0, 3885, (int)v24[i]);
    off_10033624((int)aWPublicGrannyR_0, 3888, (int)v15);
    return (unsigned int *)off_10033624((int)aWPublicGrannyR_0, 3889, (int)v25);
  }
  else
  {
    v18 = sub_10009BF0(a3);
    return sub_10002980(v22, v21, v19, v22 * v18, a4, a5, a6, a7);
  }
}
// 1000A00B: variable 'v19' is possibly undefined
// 1002A228: using guessed type int dword_1002A228;
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (1000A020) --------------------------------------------------------
_DWORD *__cdecl sub_1000A020(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  _DWORD *result; // eax

  result = a2;
  *a4 = *a2;
  return result;
}

//----- (1000A030) --------------------------------------------------------
int __cdecl sub_1000A030(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  int result; // eax

  *a4 = *a2;
  a4[1] = a2[1];
  result = a2[2];
  a4[2] = result;
  return result;
}

//----- (1000A050) --------------------------------------------------------
int __cdecl sub_1000A050(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  int result; // eax

  *a4 = *a2;
  a4[1] = a2[1];
  a4[2] = a2[2];
  result = a2[3];
  a4[3] = result;
  return result;
}

//----- (1000A070) --------------------------------------------------------
int __cdecl sub_1000A070(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  int result; // eax

  *a4 = *a2;
  a4[1] = a2[1];
  a4[2] = a2[2];
  a4[3] = a2[3];
  a4[4] = a2[4];
  a4[5] = a2[5];
  a4[6] = a2[6];
  a4[7] = a2[7];
  result = a2[8];
  a4[8] = result;
  return result;
}

//----- (1000A0B0) --------------------------------------------------------
float *__cdecl sub_1000A0B0(float *a1, float *a2, float a3, float *a4)
{
  double v4; // st7
  float *result; // eax

  v4 = (a3 - *(a1 - 1)) / (*a1 - *(a1 - 1));
  result = a4;
  *a4 = (1.0 - v4) * *(a2 - 3) + v4 * *a2;
  return result;
}

//----- (1000A0F0) --------------------------------------------------------
float *__cdecl sub_1000A0F0(float *a1, float *a2, float a3, float *a4)
{
  float *result; // eax
  double v5; // st7

  result = a2;
  v5 = (a3 - *(a1 - 1)) / (*a1 - *(a1 - 1));
  *a4 = (1.0 - v5) * *(a2 - 3) + v5 * *a2;
  a4[1] = (1.0 - v5) * *(a2 - 2) + v5 * a2[1];
  a4[2] = (1.0 - v5) * *(a2 - 1) + v5 * a2[2];
  return result;
}

//----- (1000A140) --------------------------------------------------------
float *__cdecl sub_1000A140(float *a1, float *a2, float a3, float *a4)
{
  float *result; // eax
  double v5; // st7
  double v6; // st7
  double v7; // st3

  result = a4;
  v5 = (a3 - *(a1 - 1)) / (*a1 - *(a1 - 1));
  *a4 = (1.0 - v5) * *(a2 - 4) + v5 * *a2;
  a4[1] = (1.0 - v5) * *(a2 - 3) + v5 * a2[1];
  a4[2] = (1.0 - v5) * *(a2 - 2) + v5 * a2[2];
  v6 = (1.0 - v5) * *(a2 - 1) + v5 * a2[3];
  a4[3] = v6;
  v7 = (3.0 - (*a4 * *a4 + a4[1] * a4[1] + result[2] * result[2] + v6 * v6)) * 0.5;
  *a4 = v7 * *a4;
  a4[1] = v7 * a4[1];
  a4[2] = v7 * a4[2];
  a4[3] = v7 * a4[3];
  return result;
}

//----- (1000A1F0) --------------------------------------------------------
float *__cdecl sub_1000A1F0(float *a1, float *a2, float a3, float *a4)
{
  float *result; // eax
  double v5; // st7

  result = a2;
  v5 = (a3 - *(a1 - 1)) / (*a1 - *(a1 - 1));
  *a4 = (1.0 - v5) * *(a2 - 9) + v5 * *a2;
  a4[1] = (1.0 - v5) * *(a2 - 8) + v5 * a2[1];
  a4[2] = (1.0 - v5) * *(a2 - 7) + v5 * a2[2];
  a4[3] = (1.0 - v5) * *(a2 - 6) + v5 * a2[3];
  a4[4] = (1.0 - v5) * *(a2 - 5) + v5 * a2[4];
  a4[5] = (1.0 - v5) * *(a2 - 4) + v5 * a2[5];
  a4[6] = (1.0 - v5) * *(a2 - 3) + v5 * a2[6];
  a4[7] = (1.0 - v5) * *(a2 - 2) + v5 * a2[7];
  a4[8] = (1.0 - v5) * *(a2 - 1) + v5 * a2[8];
  return result;
}

//----- (1000A2A0) --------------------------------------------------------
float *__cdecl sub_1000A2A0(float *a1, float *a2, float a3, float *a4)
{
  double v5; // st7
  double v6; // st6
  double v7; // st5
  double v8; // st7
  float *result; // eax
  float v10; // [esp+0h] [ebp-4h]
  float v11; // [esp+8h] [ebp+4h]
  float v12; // [esp+10h] [ebp+Ch]

  v5 = *a1;
  v6 = *(a1 - 1);
  v7 = *(a1 - 2);
  v10 = a3 - v6;
  v11 = v10 / (v5 - v6);
  v12 = v11 + (a3 - v7) / (v5 - v7) - (a3 - v7) / (v5 - v7) * v11;
  v8 = v10 / (a1[1] - v6) * v11;
  result = a4;
  *a4 = (1.0 - v12) * *(a2 - 6) + (v12 - v8) * *(a2 - 3) + v8 * *a2;
  return result;
}

//----- (1000A330) --------------------------------------------------------
float *__cdecl sub_1000A330(float *a1, float *a2, float a3, float *a4)
{
  double v5; // st7
  double v6; // st6
  double v7; // st5
  double v8; // st7
  double v9; // rtt
  double v10; // st6
  float *result; // eax
  double v12; // st7
  double v13; // st6
  double v14; // st5
  float v15; // [esp+0h] [ebp-4h]
  float v16; // [esp+8h] [ebp+4h]
  float v17; // [esp+10h] [ebp+Ch]

  v5 = *a1;
  v6 = *(a1 - 1);
  v7 = *(a1 - 2);
  v15 = a3 - v6;
  v16 = v15 / (v5 - v6);
  v8 = (a3 - v7) / (v5 - v7);
  v9 = v6;
  v17 = v16 + v8 - v8 * v16;
  v10 = a1[1];
  result = a2;
  v12 = v15 / (v10 - v9) * v16;
  v13 = v17 - v12;
  v14 = 1.0 - v17;
  *a4 = v14 * *(a2 - 6) + v13 * *(a2 - 3) + v12 * *a2;
  a4[1] = v14 * *(a2 - 5) + v13 * *(a2 - 2) + v12 * a2[1];
  a4[2] = v14 * *(a2 - 4) + v13 * *(a2 - 1) + v12 * a2[2];
  return result;
}

//----- (1000A3E0) --------------------------------------------------------
float *__cdecl sub_1000A3E0(float *a1, float *a2, float a3, float *a4)
{
  double v5; // st7
  double v6; // st6
  double v7; // st5
  double v8; // st7
  double v9; // rtt
  double v10; // st6
  float *result; // eax
  double v12; // st7
  double v13; // st6
  double v14; // st5
  double v15; // st7
  double v16; // st3
  float v17; // [esp+0h] [ebp-4h]
  float v18; // [esp+8h] [ebp+4h]
  float v19; // [esp+10h] [ebp+Ch]

  v5 = *a1;
  v6 = *(a1 - 1);
  v7 = *(a1 - 2);
  v17 = a3 - v6;
  v18 = v17 / (v5 - v6);
  v8 = (a3 - v7) / (v5 - v7);
  v9 = v6;
  v19 = v18 + v8 - v8 * v18;
  v10 = a1[1];
  result = a4;
  v12 = v17 / (v10 - v9) * v18;
  v13 = v19 - v12;
  v14 = 1.0 - v19;
  *a4 = v14 * *(a2 - 8) + v13 * *(a2 - 4) + v12 * *a2;
  a4[1] = v14 * *(a2 - 7) + v13 * *(a2 - 3) + v12 * a2[1];
  a4[2] = v14 * *(a2 - 6) + v13 * *(a2 - 2) + v12 * a2[2];
  v15 = v14 * *(a2 - 5) + v13 * *(a2 - 1) + v12 * a2[3];
  a4[3] = v15;
  v16 = (3.0 - (*a4 * *a4 + a4[1] * a4[1] + result[2] * result[2] + v15 * v15)) * 0.5;
  *a4 = v16 * *a4;
  a4[1] = v16 * a4[1];
  a4[2] = v16 * a4[2];
  a4[3] = v16 * a4[3];
  return result;
}

//----- (1000A500) --------------------------------------------------------
float *__cdecl sub_1000A500(float *a1, float *a2, float a3, float *a4)
{
  double v5; // st7
  double v6; // st6
  double v7; // st5
  double v8; // st7
  double v9; // rtt
  double v10; // st6
  float *result; // eax
  double v12; // st7
  double v13; // st6
  double v14; // st5
  float v15; // [esp+0h] [ebp-4h]
  float v16; // [esp+8h] [ebp+4h]
  float v17; // [esp+10h] [ebp+Ch]

  v5 = *a1;
  v6 = *(a1 - 1);
  v7 = *(a1 - 2);
  v15 = a3 - v6;
  v16 = v15 / (v5 - v6);
  v8 = (a3 - v7) / (v5 - v7);
  v9 = v6;
  v17 = v16 + v8 - v8 * v16;
  v10 = a1[1];
  result = a2;
  v12 = v15 / (v10 - v9) * v16;
  v13 = v17 - v12;
  v14 = 1.0 - v17;
  *a4 = v14 * *(a2 - 18) + v13 * *(a2 - 9) + v12 * *a2;
  a4[1] = v14 * *(a2 - 17) + v13 * *(a2 - 8) + v12 * a2[1];
  a4[2] = v14 * *(a2 - 16) + v13 * *(a2 - 7) + v12 * a2[2];
  a4[3] = v14 * *(a2 - 15) + v13 * *(a2 - 6) + v12 * a2[3];
  a4[4] = v14 * *(a2 - 14) + v13 * *(a2 - 5) + v12 * a2[4];
  a4[5] = v14 * *(a2 - 13) + v13 * *(a2 - 4) + v12 * a2[5];
  a4[6] = v14 * *(a2 - 12) + v13 * *(a2 - 3) + v12 * a2[6];
  a4[7] = v14 * *(a2 - 11) + v13 * *(a2 - 2) + v12 * a2[7];
  a4[8] = v14 * *(a2 - 10) + v13 * *(a2 - 1) + v12 * a2[8];
  return result;
}

//----- (1000A640) --------------------------------------------------------
float *__cdecl sub_1000A640(float *a1, float *a2, float a3, float *a4)
{
  double v5; // st7
  double v6; // st6
  float v7; // edx
  double v8; // st5
  double v9; // rt1
  double v10; // st5
  double v11; // st4
  double v12; // st4
  float *result; // eax
  float v14; // [esp+4h] [ebp-14h]
  float v15; // [esp+8h] [ebp-10h]
  float v16; // [esp+Ch] [ebp-Ch]
  float v17; // [esp+10h] [ebp-8h]
  float v18; // [esp+14h] [ebp-4h]
  int v19; // [esp+1Ch] [ebp+4h]
  float v20; // [esp+1Ch] [ebp+4h]
  float v21; // [esp+24h] [ebp+Ch]

  v5 = a1[1];
  v6 = *a1;
  v7 = *(a1 - 2);
  v8 = *(a1 - 3);
  v19 = *((int *)a1 - 1);
  v14 = a3 - *(float *)&v19;
  v16 = a3 - v7;
  v15 = v14 / (v6 - *(float *)&v19);
  v17 = v16 / (v6 - v7);
  v18 = v14 / (v5 - *(float *)&v19);
  v9 = (a3 - v8) / (v6 - v8);
  v10 = v14 / (a1[2] - *(float *)&v19);
  v11 = 1.0 - v15;
  v21 = (1.0 - v17) * v11;
  v20 = v18 * v15;
  v12 = v11 * v17 + (1.0 - v18) * v15;
  result = a4;
  *a4 = ((1.0 - v10) * v20 + v12 * (v16 / (v5 - v7))) * *(a2 - 3)
      + ((1.0 - v16 / (v5 - v7)) * v12 + v21 * v9) * *(a2 - 6)
      + (1.0 - v9) * v21 * *(a2 - 9)
      + v20 * v10 * *a2;
  return result;
}

//----- (1000A760) --------------------------------------------------------
float *__cdecl sub_1000A760(float *a1, float *a2, float a3, float *a4)
{
  double v5; // st7
  double v6; // st6
  float v7; // edx
  double v8; // st5
  double v9; // rt1
  double v10; // st6
  double v11; // st6
  double v12; // st7
  float *result; // eax
  double v14; // st6
  double v15; // st5
  float v16; // [esp+4h] [ebp-14h]
  float v17; // [esp+4h] [ebp-14h]
  float v18; // [esp+8h] [ebp-10h]
  float v19; // [esp+Ch] [ebp-Ch]
  float v20; // [esp+Ch] [ebp-Ch]
  float v21; // [esp+10h] [ebp-8h]
  float v22; // [esp+10h] [ebp-8h]
  float v23; // [esp+14h] [ebp-4h]
  float v24; // [esp+14h] [ebp-4h]
  int v25; // [esp+1Ch] [ebp+4h]
  float v26; // [esp+1Ch] [ebp+4h]
  float v27; // [esp+24h] [ebp+Ch]

  v5 = a1[1];
  v6 = *a1;
  v7 = *(a1 - 2);
  v8 = *(a1 - 3);
  v25 = *((int *)a1 - 1);
  v16 = a3 - *(float *)&v25;
  v19 = a3 - v7;
  v18 = v16 / (v6 - *(float *)&v25);
  v21 = v19 / (v6 - v7);
  v23 = v16 / (v5 - *(float *)&v25);
  v9 = (a3 - v8) / (v6 - v8);
  v20 = v19 / (v5 - v7);
  v17 = v16 / (a1[2] - *(float *)&v25);
  v10 = 1.0 - v18;
  v26 = (1.0 - v21) * v10;
  v11 = v10 * v21;
  v22 = v23 * v18;
  v27 = (1.0 - v9) * v26;
  v24 = (1.0 - v23) * v18 + v11;
  v12 = (1.0 - v20) * v24 + v26 * v9;
  result = a2;
  v14 = (1.0 - v17) * v22 + v24 * v20;
  v15 = v22 * v17;
  *a4 = v27 * *(a2 - 9) + v12 * *(a2 - 6) + v14 * *(a2 - 3) + v15 * *a2;
  a4[1] = v27 * *(a2 - 8) + v12 * *(a2 - 5) + v14 * *(a2 - 2) + v15 * a2[1];
  a4[2] = v27 * *(a2 - 7) + v12 * *(a2 - 4) + v14 * *(a2 - 1) + v15 * a2[2];
  return result;
}

//----- (1000A8E0) --------------------------------------------------------
float *__cdecl sub_1000A8E0(float *a1, float *a2, float a3, float *a4)
{
  double v5; // st7
  double v6; // st6
  float v7; // edx
  double v8; // st5
  double v9; // rt1
  double v10; // st6
  double v11; // st6
  double v12; // st7
  float *result; // eax
  double v14; // st6
  double v15; // st5
  double v16; // st7
  double v17; // st3
  float v18; // [esp+4h] [ebp-14h]
  float v19; // [esp+4h] [ebp-14h]
  float v20; // [esp+8h] [ebp-10h]
  float v21; // [esp+Ch] [ebp-Ch]
  float v22; // [esp+Ch] [ebp-Ch]
  float v23; // [esp+10h] [ebp-8h]
  float v24; // [esp+10h] [ebp-8h]
  float v25; // [esp+14h] [ebp-4h]
  float v26; // [esp+14h] [ebp-4h]
  int v27; // [esp+1Ch] [ebp+4h]
  float v28; // [esp+1Ch] [ebp+4h]
  float v29; // [esp+24h] [ebp+Ch]

  v5 = a1[1];
  v6 = *a1;
  v7 = *(a1 - 2);
  v8 = *(a1 - 3);
  v27 = *((int *)a1 - 1);
  v18 = a3 - *(float *)&v27;
  v21 = a3 - v7;
  v20 = v18 / (v6 - *(float *)&v27);
  v23 = v21 / (v6 - v7);
  v25 = v18 / (v5 - *(float *)&v27);
  v9 = (a3 - v8) / (v6 - v8);
  v22 = v21 / (v5 - v7);
  v19 = v18 / (a1[2] - *(float *)&v27);
  v10 = 1.0 - v20;
  v28 = (1.0 - v23) * v10;
  v11 = v10 * v23;
  v24 = v25 * v20;
  v29 = (1.0 - v9) * v28;
  v26 = (1.0 - v25) * v20 + v11;
  v12 = (1.0 - v22) * v26 + v28 * v9;
  result = a2;
  v14 = (1.0 - v19) * v24 + v26 * v22;
  v15 = v24 * v19;
  *a4 = v29 * *(a2 - 12) + v12 * *(a2 - 8) + v14 * *(a2 - 4) + v15 * *a2;
  a4[1] = v29 * *(a2 - 11) + v12 * *(a2 - 7) + v14 * *(a2 - 3) + v15 * a2[1];
  a4[2] = v29 * *(a2 - 10) + v12 * *(a2 - 6) + v14 * *(a2 - 2) + v15 * a2[2];
  v16 = v29 * *(result - 9) + v12 * *(result - 5) + v14 * *(result - 1) + v15 * result[3];
  a4[3] = v16;
  v17 = (3.0 - (*a4 * *a4 + a4[1] * a4[1] + a4[2] * a4[2] + v16 * v16)) * 0.5;
  *a4 = v17 * *a4;
  a4[1] = v17 * a4[1];
  a4[2] = v17 * a4[2];
  a4[3] = v17 * a4[3];
  return result;
}

//----- (1000AAD0) --------------------------------------------------------
float *__cdecl sub_1000AAD0(float *a1, float *a2, float a3, float *a4)
{
  double v5; // st7
  double v6; // st6
  float v7; // edx
  double v8; // st5
  double v9; // rt1
  double v10; // st6
  double v11; // st6
  double v12; // st7
  float *result; // eax
  double v14; // st6
  double v15; // st5
  float v16; // [esp+4h] [ebp-14h]
  float v17; // [esp+4h] [ebp-14h]
  float v18; // [esp+8h] [ebp-10h]
  float v19; // [esp+Ch] [ebp-Ch]
  float v20; // [esp+Ch] [ebp-Ch]
  float v21; // [esp+10h] [ebp-8h]
  float v22; // [esp+10h] [ebp-8h]
  float v23; // [esp+14h] [ebp-4h]
  float v24; // [esp+14h] [ebp-4h]
  int v25; // [esp+1Ch] [ebp+4h]
  float v26; // [esp+1Ch] [ebp+4h]
  float v27; // [esp+24h] [ebp+Ch]

  v5 = a1[1];
  v6 = *a1;
  v7 = *(a1 - 2);
  v8 = *(a1 - 3);
  v25 = *((int *)a1 - 1);
  v16 = a3 - *(float *)&v25;
  v19 = a3 - v7;
  v18 = v16 / (v6 - *(float *)&v25);
  v21 = v19 / (v6 - v7);
  v23 = v16 / (v5 - *(float *)&v25);
  v9 = (a3 - v8) / (v6 - v8);
  v20 = v19 / (v5 - v7);
  v17 = v16 / (a1[2] - *(float *)&v25);
  v10 = 1.0 - v18;
  v26 = (1.0 - v21) * v10;
  v11 = v10 * v21;
  v22 = v23 * v18;
  v27 = (1.0 - v9) * v26;
  v24 = (1.0 - v23) * v18 + v11;
  v12 = (1.0 - v20) * v24 + v26 * v9;
  result = a2;
  v14 = (1.0 - v17) * v22 + v24 * v20;
  v15 = v22 * v17;
  *a4 = v27 * *(a2 - 27) + v12 * *(a2 - 18) + v14 * *(a2 - 9) + v15 * *a2;
  a4[1] = v27 * *(a2 - 26) + v12 * *(a2 - 17) + v14 * *(a2 - 8) + v15 * a2[1];
  a4[2] = v27 * *(a2 - 25) + v12 * *(a2 - 16) + v14 * *(a2 - 7) + v15 * a2[2];
  a4[3] = v27 * *(a2 - 24) + v12 * *(a2 - 15) + v14 * *(a2 - 6) + v15 * a2[3];
  a4[4] = v27 * *(a2 - 23) + v12 * *(a2 - 14) + v14 * *(a2 - 5) + v15 * a2[4];
  a4[5] = v27 * *(a2 - 22) + v12 * *(a2 - 13) + v14 * *(a2 - 4) + v15 * a2[5];
  a4[6] = v27 * *(a2 - 21) + v12 * *(a2 - 12) + v14 * *(a2 - 3) + v15 * a2[6];
  a4[7] = v27 * *(a2 - 20) + v12 * *(a2 - 11) + v14 * *(a2 - 2) + v15 * a2[7];
  a4[8] = v27 * *(a2 - 19) + v12 * *(a2 - 10) + v14 * *(a2 - 1) + v15 * a2[8];
  return result;
}

//----- (1000AD10) --------------------------------------------------------
void __cdecl sub_1000AD10(unsigned int a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  void (__cdecl *v6)(int, int, int, int); // edx

  if ( a1 >= 4 )
  {
    sub_10017FE0(3, 21, "%s(%d): Degree %d is out of range [0, %d)", aWPublicGrannyR_8, 336, a1, 4);
  }
  else if ( a2 > 9 )
  {
    sub_10017FE0(3, 21, "%s(%d): Dimension %d is out of range [0, %d)", aWPublicGrannyR_8, 337, a2, 10);
  }
  else
  {
    v6 = (void (__cdecl *)(int, int, int, int))dword_10030EA0[10 * a1 + a2];
    if ( v6 )
      v6(a3, a4, a5, a6);
    else
      sub_10017FE0(3, 21, "%s(%d): Unrecognized degree/dimension combination (%d/%d)", aWPublicGrannyR_8, 348, a1, a2);
  }
}
// 10030EA0: using guessed type int dword_10030EA0[];

//----- (1000ADC0) --------------------------------------------------------
int __cdecl sub_1000ADC0(int a1, int a2, float a3)
{
  int v3; // ecx
  int v4; // edi
  bool v6; // zf
  bool v7; // c0
  bool v8; // c3

  v3 = a1;
  v4 = 0;
  if ( a1 <= 1 )
    return v4 + 1;
  while ( 1 )
  {
    v6 = (v3 & 1) == 0;
    v3 /= 2;
    v7 = a3 < (double)*(float *)(a2 + 4 * v3);
    v8 = a3 == *(float *)(a2 + 4 * v3);
    if ( !v6 )
    {
      if ( !v7 && !v8 )
      {
        v4 += v3;
        a2 += 4 * v3;
      }
      ++v3;
      goto LABEL_9;
    }
    if ( !v7 && !v8 )
      break;
LABEL_9:
    if ( v3 <= 1 )
      return v4 + 1;
  }
  if ( a3 > (double)*(float *)(a2 + 4 * v3 + 4) )
  {
    v4 += v3 + 1;
    a2 += 4 * v3-- + 4;
    goto LABEL_9;
  }
  v4 += v3;
  return v4 + 1;
}

//----- (1000AE30) --------------------------------------------------------
int __cdecl sub_1000AE30(int a1, int a2, float a3, int a4)
{
  int v5; // ecx
  double v6; // st7
  int v8; // [esp+Ch] [ebp+4h]

  if ( a1 <= 0 )
    return 0;
  v5 = a4;
  if ( !a4 )
    v5 = 1;
  v6 = *(float *)(a2 + 4 * v5 - 4);
  if ( v5 < a1 )
  {
    do
    {
      v8 = *(int *)(a2 + 4 * v5);
      if ( v6 <= a3 && *(float *)&v8 >= (double)a3 )
        return v5;
      v6 = *(float *)&v8;
    }
    while ( ++v5 < a1 );
  }
  v5 = 1;
  if ( a4 <= 1 )
    return 0;
  while ( *(float *)(a2 + 4 * v5) < (double)a3 )
  {
    if ( ++v5 >= a4 )
      return 0;
  }
  return v5;
}

//----- (1000AEB0) --------------------------------------------------------
char __cdecl sub_1000AEB0(int a1, _DWORD *a2, _DWORD *a3, int a4, int a5, _DWORD *a6, int a7, _DWORD *a8, _DWORD *a9)
{
  _DWORD *v9; // ecx
  int v10; // eax
  int v11; // ebx
  int v13; // edx
  bool v14; // sf
  int v15; // edi
  char result; // al
  _DWORD *v17; // edi
  int v19; // esi
  int v20; // ebp
  int v21; // eax
  int v22; // eax
  int v23; // edx
  bool v24; // cc
  int v25; // [esp+10h] [ebp-8h]
  int v26; // [esp+14h] [ebp-4h]
  int v27; // [esp+1Ch] [ebp+4h]
  float v28; // [esp+1Ch] [ebp+4h]
  int v29; // [esp+20h] [ebp+8h]
  int v30; // [esp+20h] [ebp+8h]
  int v31; // [esp+20h] [ebp+8h]
  int v32; // [esp+24h] [ebp+Ch]
  int v33; // [esp+2Ch] [ebp+14h]
  int v34; // [esp+38h] [ebp+20h]
  int v35; // [esp+38h] [ebp+20h]
  int v36; // [esp+38h] [ebp+20h]
  int v37; // [esp+38h] [ebp+20h]
  float v38; // [esp+3Ch] [ebp+24h]

  v9 = a3;
  v10 = *a3;
  v11 = a3[1];
  v25 = v11;
  if ( v11 && a4 )
    v25 = --v11;
  v13 = 2 * v10;
  v15 = a5 - v10;
  v14 = a5 - v10 < 0;
  v26 = 2 * v10;
  v33 = a5 - v10;
  if ( v14 || v13 + v15 > v11 )
  {
    v17 = a6;
    *a8 = &a6[v10];
    v19 = a7;
    *a9 = a7 + 4 * a1 * v10;
    v20 = 0;
    if ( a2 )
    {
      v21 = a2[1] - 1;
      v34 = v21 + v33;
      v38 = -*(float *)(a2[2] + 4 * v21);
      if ( v33 < 0 )
      {
        v22 = 4 * a1 * v34;
        v35 = 4 * v34;
        v27 = v22;
        do
        {
          if ( v20 >= v26 )
            break;
          *((float *)++v17 - 1) = v38 + *(float *)(v35 + a2[2]);
          sub_10019E30(a1, (_DWORD *)(v27 + a2[4]), v19);
          v19 += 4 * a1;
          v27 += 4 * a1;
          ++v20;
          v35 += 4;
          v9 = a3;
        }
        while ( v33 + v20 < 0 );
      }
    }
    else if ( v33 < 0 )
    {
      while ( v20 < v13 )
      {
        *v17++ = *(_DWORD *)v9[2];
        sub_10019E30(a1, (_DWORD *)v9[4], v19);
        ++v20;
        v9 = a3;
        v19 += 4 * a1;
        if ( v33 + v20 >= 0 )
          break;
        v13 = v26;
      }
    }
    v23 = v25;
    if ( v20 + v33 < v25 )
    {
      v29 = v20 + v33;
      v36 = 4 * a1 * (v20 + v33);
      do
      {
        if ( v20 >= v26 )
          break;
        *v17++ = *(_DWORD *)(v9[2] + 4 * v29);
        sub_10019E30(a1, (_DWORD *)(v36 + v9[4]), v19);
        v19 += 4 * a1;
        ++v20;
        ++v29;
        v9 = a3;
        v36 += 4 * a1;
      }
      while ( v29 < v25 );
      v23 = v25;
    }
    if ( a4 )
    {
      v28 = *(float *)(v9[2] + 4 * v23);
      if ( v20 + v33 >= v23 )
      {
        v37 = v20 + v33;
        v32 = 0;
        v30 = 0;
        do
        {
          if ( v20 >= v26 )
            break;
          *((float *)++v17 - 1) = v28 + *(float *)(*(_DWORD *)(a4 + 8) + v32);
          sub_10019E30(a1, (_DWORD *)(v30 + *(_DWORD *)(a4 + 16)), v19);
          v19 += 4 * a1;
          v32 += 4;
          ++v20;
          v24 = ++v37 < v25;
          v30 += 4 * a1;
        }
        while ( !v24 );
      }
    }
    else if ( v20 + v33 >= v23 )
    {
      v31 = v20 + v33;
      while ( v20 < v26 )
      {
        *v17++ = *(_DWORD *)(v9[2] + 4 * v23 - 4);
        sub_10019E30(a1, (_DWORD *)(v9[4] + 4 * a1 * (v23 - 1)), v19);
        ++v20;
        v24 = v31 + 1 < v25;
        v19 += 4 * a1;
        ++v31;
        if ( v24 )
          return 1;
        v9 = a3;
        v23 = v25;
      }
    }
    return 1;
  }
  else
  {
    *a8 = a3[2] + 4 * a5;
    result = 0;
    *a9 = a3[4] + 4 * a5 * a1;
  }
  return result;
}

//----- (1000B1B0) --------------------------------------------------------
int sub_1000B1B0()
{
  int result; // eax

  result = 2139095040;
  dword_100360E8 = 2139095040;
  return result;
}
// 100360E8: using guessed type int dword_100360E8;

//----- (1000B1D0) --------------------------------------------------------
int sub_1000B1D0()
{
  int result; // eax

  result = -4194304;
  dword_100360EC = -4194304;
  return result;
}
// 100360EC: using guessed type int dword_100360EC;

//----- (1000B1F0) --------------------------------------------------------
int sub_1000B1F0()
{
  int result; // eax

  result = -8388608;
  dword_10036100 = -8388608;
  return result;
}
// 10036100: using guessed type int dword_10036100;

//----- (1000B210) --------------------------------------------------------
int sub_1000B210()
{
  int result; // eax

  result = 0;
  dword_100360F8 = 0;
  dword_100360FC = 2146435072;
  return result;
}
// 100360F8: using guessed type int dword_100360F8;
// 100360FC: using guessed type int dword_100360FC;

//----- (1000B240) --------------------------------------------------------
int sub_1000B240()
{
  int result; // eax

  result = 0;
  dword_100360F0 = 0;
  dword_100360F4 = -524288;
  return result;
}
// 100360F0: using guessed type int dword_100360F0;
// 100360F4: using guessed type int dword_100360F4;

//----- (1000B270) --------------------------------------------------------
int sub_1000B270()
{
  int result; // eax

  result = 0;
  dword_100360E0 = 0;
  dword_100360E4 = -1048576;
  return result;
}
// 100360E0: using guessed type int dword_100360E0;
// 100360E4: using guessed type int dword_100360E4;

//----- (1000B290) --------------------------------------------------------
char __thiscall sub_1000B290(float *this, float a2)
{
  char result; // al

  sub_1000B2C0((int)this);
  do
    result = sub_1000B300(this, a2);
  while ( result );
  return result;
}

//----- (1000B2C0) --------------------------------------------------------
int __thiscall sub_1000B2C0(int this)
{
  int v2; // eax

  v2 = *(_DWORD *)(this + 12);
  if ( v2 )
    *(_DWORD *)(this + 20) = v2 + 1;
  else
    *(_DWORD *)(this + 20) = 2;
  sub_1000BA50((float *)this);
  return sub_1000C1A0((float *)this);
}

//----- (1000B300) --------------------------------------------------------
char __thiscall sub_1000B300(float *this, float a2)
{
  return sub_1000C4C0(this, a2);
}

//----- (1000B310) --------------------------------------------------------
char __thiscall sub_1000B310(int this, float a2, float a3, int a4)
{
  int v4; // ebx
  float v6; // eax
  float *v7; // edx
  int v8; // ecx
  float *v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // ecx
  float *v13; // edi
  int v14; // ecx
  float *v15; // edx
  int v16; // ecx
  float *v17; // ecx
  double v18; // st7
  double v19; // st6
  double v20; // st5
  double v21; // st7
  double v22; // st6
  int v23; // eax
  int v24; // ecx
  float *v25; // edi
  float *v26; // ebp
  float *v27; // eax
  int v28; // eax
  int v29; // ebp
  int v30; // edi
  int v31; // eax
  int v32; // eax
  int v33; // eax
  int v34; // eax
  double v35; // st7
  int v36; // eax
  int v37; // eax
  int v38; // ecx
  int v40; // [esp+10h] [ebp-18h] BYREF
  int v41; // [esp+14h] [ebp-14h] BYREF
  int v42; // [esp+18h] [ebp-10h] BYREF
  float *v43; // [esp+1Ch] [ebp-Ch]
  float *v44; // [esp+20h] [ebp-8h]
  float *v45; // [esp+24h] [ebp-4h]

  v4 = LODWORD(a2);
  switch ( *(_DWORD *)(this + 12) )
  {
    case 0:
      *(float *)&v40 = 0.0;
      *(float *)&v41 = 0.0;
      *(float *)&v42 = 0.0;
      a2 = 1.0;
      break;
    case 1:
      v6 = *(float *)(this + 20);
      *(float *)&v40 = 0.0;
      *(float *)&v41 = 0.0;
      if ( v6 == 0.0 || SLODWORD(a2) < SLODWORD(v6) )
      {
        if ( a2 >= 0.0 )
        {
          v7 = (float *)(*(_DWORD *)(this + 24) + 4 * LODWORD(a2));
        }
        else
        {
          v7 = (float *)(this + 60);
          *(float *)(this + 60) = (float)SLODWORD(a2);
        }
      }
      else
      {
        *(_DWORD *)(this + 60) = *(_DWORD *)(*(_DWORD *)(this + 24) + 4 * LODWORD(v6) - 4);
        v7 = (float *)(this + 60);
      }
      v8 = v4 - 1;
      LODWORD(a2) = v4 - 1;
      if ( v6 == 0.0 || v8 < SLODWORD(v6) )
      {
        if ( v8 >= 0 )
        {
          v9 = (float *)(*(_DWORD *)(this + 24) + 4 * v8);
        }
        else
        {
          v9 = (float *)(this + 60);
          *(float *)(this + 60) = (float)SLODWORD(a2);
        }
      }
      else
      {
        v9 = (float *)(this + 60);
        *(_DWORD *)(this + 60) = *(_DWORD *)(*(_DWORD *)(this + 24) + 4 * LODWORD(v6) - 4);
      }
      a2 = (a3 - *v9) / (*v7 - *v9);
      *(float *)&v42 = 1.0 - a2;
      break;
    case 2:
      v10 = *(_DWORD *)(this + 20);
      v11 = LODWORD(a2) + 1;
      *(float *)&v40 = 0.0;
      v43 = (float *)(LODWORD(a2) + 1);
      if ( v10 && v11 >= v10 )
      {
        v12 = this + 60;
        *(_DWORD *)(this + 60) = *(_DWORD *)(*(_DWORD *)(this + 24) + 4 * v10 - 4);
      }
      else if ( v11 >= 0 )
      {
        v12 = *(_DWORD *)(this + 24) + 4 * v11;
      }
      else
      {
        v12 = this + 60;
        *(float *)(this + 60) = (float)(int)v43;
      }
      v42 = v12;
      if ( v10 && v4 >= v10 )
      {
        *(_DWORD *)(this + 60) = *(_DWORD *)(*(_DWORD *)(this + 24) + 4 * v10 - 4);
        v13 = (float *)(this + 60);
      }
      else if ( v4 >= 0 )
      {
        v13 = (float *)(*(_DWORD *)(this + 24) + 4 * v4);
      }
      else
      {
        v13 = (float *)(this + 60);
        *(float *)(this + 60) = (float)SLODWORD(a2);
      }
      v14 = v4 - 1;
      LODWORD(a2) = v4 - 1;
      if ( v10 && v14 >= v10 )
      {
        *(_DWORD *)(this + 60) = *(_DWORD *)(*(_DWORD *)(this + 24) + 4 * v10 - 4);
        v15 = (float *)(this + 60);
      }
      else if ( v14 >= 0 )
      {
        v15 = (float *)(*(_DWORD *)(this + 24) + 4 * v14);
      }
      else
      {
        v15 = (float *)(this + 60);
        *(float *)(this + 60) = (float)SLODWORD(a2);
      }
      v16 = v4 - 2;
      LODWORD(a2) = v4 - 2;
      if ( v10 && v16 >= v10 )
      {
        v17 = (float *)(this + 60);
        *(_DWORD *)(this + 60) = *(_DWORD *)(*(_DWORD *)(this + 24) + 4 * v10 - 4);
      }
      else if ( v16 >= 0 )
      {
        v17 = (float *)(*(_DWORD *)(this + 24) + 4 * v16);
      }
      else
      {
        v17 = (float *)(this + 60);
        *(float *)(this + 60) = (float)SLODWORD(a2);
      }
      v18 = *v13;
      v19 = *v15;
      v20 = *v17;
      *(float *)&v41 = a3 - v19;
      a2 = *(float *)&v41 / (v18 - v19);
      a3 = (a3 - v20) / (v18 - v20);
      v21 = a3 + a2 - a3 * a2;
      v22 = *(float *)&v41 / (*(float *)v42 - v19) * a2;
      a2 = v22;
      *(float *)&v42 = v21 - v22;
      *(float *)&v41 = 1.0 - v21;
      break;
    case 3:
      v23 = *(_DWORD *)(this + 20);
      v24 = LODWORD(a2) + 2;
      LODWORD(a2) += 2;
      if ( v23 && v24 >= v23 )
      {
        *(_DWORD *)(this + 60) = *(_DWORD *)(*(_DWORD *)(this + 24) + 4 * v23 - 4);
        v43 = (float *)(this + 60);
      }
      else if ( v24 >= 0 )
      {
        v43 = (float *)(*(_DWORD *)(this + 24) + 4 * v24);
      }
      else
      {
        v43 = (float *)(this + 60);
        *(float *)(this + 60) = (float)SLODWORD(a2);
      }
      v25 = (float *)sub_1000B6E0((float *)this, v4 + 1);
      v26 = (float *)sub_1000B6E0((float *)this, v4);
      v44 = (float *)sub_1000B6E0((float *)this, v4 - 1);
      v45 = (float *)sub_1000B6E0((float *)this, v4 - 2);
      v27 = (float *)sub_1000B6E0((float *)this, v4 - 3);
      sub_1000B750(*v27, *v45, *v44, *v26, *v25, *v43, a3, (float *)&v40, (float *)&v41, (float *)&v42, &a2);
      break;
    default:
      break;
  }
  v28 = *(_DWORD *)(this + 4);
  v29 = a4;
  v30 = 0;
  a3 = 0.0;
  if ( v28 > 0 )
  {
    do
    {
      v31 = sub_1000B720((_DWORD *)this, v4 - 3);
      *(float *)&a4 = *(float *)&v40 * *(float *)(v31 + 4 * v30);
      v32 = sub_1000B720((_DWORD *)this, v4 - 2);
      *(float *)&a4 = *(float *)&v41 * *(float *)(v32 + 4 * v30) + *(float *)&a4;
      v33 = sub_1000B720((_DWORD *)this, v4);
      *(float *)&a4 = a2 * *(float *)(v33 + 4 * v30) + *(float *)&a4;
      v34 = sub_1000B720((_DWORD *)this, v4 - 1);
      ++v30;
      v35 = *(float *)&v42 * *(float *)(v34 + 4 * v30 - 4) + *(float *)&a4;
      *(float *)(v29 + 4 * v30 - 4) = v35;
      v36 = *(_DWORD *)(this + 4);
      a3 = v35 + a3;
    }
    while ( v30 < v36 );
  }
  LOBYTE(v37) = *(_BYTE *)(this + 16);
  if ( (_BYTE)v37 )
  {
    v38 = *(_DWORD *)(this + 4);
    v37 = 0;
    a3 = (3.0 - a3) * 0.5;
    if ( v38 > 0 )
    {
      do
      {
        ++v37;
        *(float *)(v29 + 4 * v37 - 4) = a3 * *(float *)(v29 + 4 * v37 - 4);
      }
      while ( v37 < *(_DWORD *)(this + 4) );
    }
  }
  return v37;
}
// 1002A170: using guessed type float flt_1002A170;

//----- (1000B6E0) --------------------------------------------------------
int __thiscall sub_1000B6E0(float *this, int a2)
{
  int v2; // edx
  int result; // eax

  v2 = *((_DWORD *)this + 5);
  if ( v2 && a2 >= v2 )
  {
    result = (int)(this + 15);
    this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v2 - 4);
  }
  else if ( a2 >= 0 )
  {
    return *((_DWORD *)this + 6) + 4 * a2;
  }
  else
  {
    result = (int)(this + 15);
    this[15] = (float)a2;
  }
  return result;
}

//----- (1000B720) --------------------------------------------------------
int __thiscall sub_1000B720(_DWORD *this, int a2)
{
  int v2; // eax
  int v3; // edx

  v2 = a2;
  v3 = this[5];
  if ( a2 >= v3 )
    v2 = v3 - 1;
  if ( v2 < 0 )
    v2 = 0;
  return this[7] + 4 * v2 * this[1];
}

//----- (1000B750) --------------------------------------------------------
float *__cdecl sub_1000B750(
        float a1,
        float a2,
        float a3,
        float a4,
        float a5,
        float a6,
        float a7,
        float *a8,
        float *a9,
        float *a10,
        float *a11)
{
  double v11; // st7
  double v12; // st6
  double v13; // st6
  double v14; // st5
  float *result; // eax
  float v16; // [esp+0h] [ebp-Ch]
  float v17; // [esp+4h] [ebp-8h]
  float v18; // [esp+8h] [ebp-4h]
  float v19; // [esp+14h] [ebp+8h]
  float v20; // [esp+18h] [ebp+Ch]
  float v21; // [esp+1Ch] [ebp+10h]
  float v22; // [esp+28h] [ebp+1Ch]

  v11 = a7 - a3;
  v12 = a7 - a2;
  v16 = v11 / (a4 - a3);
  v17 = v12 / (a4 - a2);
  v18 = v11 / (a5 - a3);
  v22 = (a7 - a1) / (a4 - a1);
  v13 = v12 / (a5 - a2);
  v19 = v11 / (a6 - a3);
  v14 = (1.0 - v17) * (1.0 - v16);
  v21 = v18 * v16;
  *a8 = (1.0 - v22) * v14;
  v20 = (1.0 - v18) * v16 + (1.0 - v16) * v17;
  *a9 = (1.0 - v13) * v20 + v14 * v22;
  result = a11;
  *a10 = (1.0 - v19) * v21 + v20 * v13;
  *a11 = v21 * v19;
  return result;
}

//----- (1000B860) --------------------------------------------------------
_DWORD *__thiscall sub_1000B860(_DWORD *this, int a2, int a3, int a4, char a5)
{
  int v6; // eax
  int v7; // ecx
  int v8; // eax

  *this = a2;
  this[3] = a4;
  this[1] = a3;
  *((_BYTE *)this + 16) = a5;
  this[5] = 0;
  this[2] = off_10033620((int)aWPublicGrannyR_9, 226, 4, 4 * a3 * a2);
  v6 = off_10033620((int)aWPublicGrannyR_9, 227, 4, 4 * *this);
  v7 = *this;
  this[6] = v6;
  this[7] = off_10033620((int)aWPublicGrannyR_9, 228, 4, 4 * v7 * this[1]);
  this[8] = off_10033620((int)aWPublicGrannyR_9, 232, 4, 4 * *this);
  this[9] = off_10033620((int)aWPublicGrannyR_9, 233, 4, 4 * this[1]);
  v8 = 2 * *this * (this[3] + 2);
  this[11] = v8;
  this[10] = 0;
  this[12] = off_10033620((int)aWPublicGrannyR_9, 240, 4, 4 * v8);
  this[13] = off_10033620((int)aWPublicGrannyR_9, 243, 4, 12 * *this);
  this[14] = off_10033620((int)aWPublicGrannyR_9, 244, 4, 12 * *this);
  return this;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (1000B9A0) --------------------------------------------------------
int __thiscall sub_1000B9A0(int *this)
{
  off_10033624((int)aWPublicGrannyR_9, 250, this[13]);
  off_10033624((int)aWPublicGrannyR_9, 251, this[14]);
  off_10033624((int)aWPublicGrannyR_9, 253, this[12]);
  off_10033624((int)aWPublicGrannyR_9, 255, this[9]);
  off_10033624((int)aWPublicGrannyR_9, 256, this[8]);
  off_10033624((int)aWPublicGrannyR_9, 258, this[7]);
  off_10033624((int)aWPublicGrannyR_9, 259, this[6]);
  return off_10033624((int)aWPublicGrannyR_9, 260, this[2]);
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (1000BA50) --------------------------------------------------------
int __thiscall sub_1000BA50(float *this)
{
  int result; // eax
  int v2; // edx
  float *v3; // esi
  double v4; // st7
  int v5; // [esp+0h] [ebp-8h]
  float i; // [esp+4h] [ebp-4h]

  result = *((_DWORD *)this + 5);
  v2 = 0;
  v5 = 0;
  for ( i = (double)(*(_DWORD *)this - 1) / (double)(result - 1); v2 < result; result = *((_DWORD *)this + 5) )
  {
    if ( result && v2 >= result )
    {
      v3 = this + 15;
      this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * result - 4);
    }
    else if ( v2 >= 0 )
    {
      v3 = (float *)(*((_DWORD *)this + 6) + 4 * v2);
    }
    else
    {
      v3 = this + 15;
      this[15] = (float)v5;
    }
    v4 = (double)v5;
    v5 = ++v2;
    *v3 = v4 * i;
  }
  return result;
}

//----- (1000BAD0) --------------------------------------------------------
int __thiscall sub_1000BAD0(float *this)
{
  int result; // eax
  int v2; // edx
  int v3; // ebx
  int v4; // edi
  int v5; // esi
  float *v6; // eax
  int v7; // eax
  int v8; // [esp+8h] [ebp-8h]
  int i; // [esp+Ch] [ebp-4h]

  result = *(_DWORD *)this;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v8 = 0;
  for ( i = 0; v3 < *(_DWORD *)this; i = v3 )
  {
    v5 = *((_DWORD *)this + 5);
    while ( 1 )
    {
      if ( v5 && v2 >= v5 )
      {
        v6 = this + 15;
        this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v5 - 4);
      }
      else if ( v2 >= 0 )
      {
        v6 = (float *)(*((_DWORD *)this + 6) + 4 * v2);
      }
      else
      {
        v6 = this + 15;
        this[15] = (float)v8;
      }
      if ( (double)i <= *v6 )
        break;
      v8 = ++v2;
      v4 = 0;
    }
    v7 = v4++;
    *(_DWORD *)(*(_DWORD *)(*((_DWORD *)this + 13) + 12 * v2 + 8) + 4 * v7) = 1065353216;
    result = *(_DWORD *)this;
    ++v3;
  }
  return result;
}

//----- (1000BB60) --------------------------------------------------------
int __thiscall sub_1000BB60(float *this)
{
  int result; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // ebp
  double v5; // st7
  int v6; // esi
  float *v7; // eax
  float *v8; // edi
  int v9; // eax
  float *v10; // eax
  double v11; // st7
  double v12; // st6
  int v13; // eax
  int v14; // [esp+8h] [ebp-10h]
  int i; // [esp+10h] [ebp-8h]

  result = *(_DWORD *)this;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v14 = 0;
  for ( i = 0; i < *(_DWORD *)this; ++i )
  {
    v5 = (double)i;
    v6 = *((_DWORD *)this + 5);
    while ( 1 )
    {
      if ( v6 && v3 >= v6 )
      {
        v7 = this + 15;
        this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v6 - 4);
      }
      else if ( v3 >= 0 )
      {
        v7 = (float *)(*((_DWORD *)this + 6) + 4 * v3);
      }
      else
      {
        v7 = this + 15;
        this[15] = (float)v14;
      }
      if ( v5 <= *v7 )
        break;
      ++v3;
      v4 = v2;
      v14 = v3;
      v2 = 0;
    }
    if ( v6 && v3 >= v6 )
    {
      this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v6 - 4);
      v8 = this + 15;
    }
    else if ( v3 >= 0 )
    {
      v8 = (float *)(*((_DWORD *)this + 6) + 4 * v3);
    }
    else
    {
      v8 = this + 15;
      this[15] = (float)v14;
    }
    v9 = v3 - 1;
    if ( v6 && v9 >= v6 )
    {
      v10 = this + 15;
      this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v6 - 4);
    }
    else if ( v9 >= 0 )
    {
      v10 = (float *)(*((_DWORD *)this + 6) + 4 * v9);
    }
    else
    {
      v10 = this + 15;
      this[15] = (float)(v3 - 1);
    }
    v11 = (v5 - *v10) / (*v8 - *v10);
    v12 = 1.0 - v11;
    if ( v3 <= 0 )
    {
      v11 = v11 + v12;
    }
    else
    {
      v13 = v4++;
      *(float *)(*(_DWORD *)(*((_DWORD *)this + 13) + 12 * v3 - 4) + 4 * v13) = v12;
    }
    *(float *)(*(_DWORD *)(*((_DWORD *)this + 13) + 12 * v3 + 8) + 4 * v2++) = v11;
    result = i + 1;
  }
  return result;
}

//----- (1000BCA0) --------------------------------------------------------
int __thiscall sub_1000BCA0(float *this)
{
  int result; // eax
  int v2; // edx
  int v3; // ebp
  double v4; // st7
  int v5; // esi
  float *v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  float *v10; // ebx
  int v11; // eax
  float *v12; // edi
  int v13; // eax
  float *v14; // eax
  double v15; // st6
  double v16; // st7
  double v17; // st6
  double v18; // st5
  int v19; // eax
  int v20; // eax
  int v21; // [esp+4h] [ebp-24h]
  int v22; // [esp+8h] [ebp-20h]
  float v23; // [esp+10h] [ebp-18h]
  int v24; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  float *v26; // [esp+1Ch] [ebp-Ch]
  float v27; // [esp+20h] [ebp-8h]
  float v28; // [esp+24h] [ebp-4h]

  result = *(_DWORD *)this;
  v2 = 0;
  v3 = 0;
  v22 = 0;
  v24 = 0;
  v21 = 0;
  for ( i = 0; i < *(_DWORD *)this; ++i )
  {
    v4 = (double)i;
    v5 = *((_DWORD *)this + 5);
    while ( 1 )
    {
      if ( v5 && v2 >= v5 )
      {
        v6 = this + 15;
        this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v5 - 4);
      }
      else if ( v2 >= 0 )
      {
        v6 = (float *)(*((_DWORD *)this + 6) + 4 * v2);
      }
      else
      {
        v6 = this + 15;
        this[15] = (float)v22;
      }
      if ( v4 <= *v6 )
        break;
      v7 = v21;
      ++v2;
      v21 = v3;
      v22 = v2;
      v24 = v7;
      v3 = 0;
    }
    v8 = v2 + 1;
    if ( v5 && v8 >= v5 )
    {
      v9 = (int)(this + 15);
      this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v5 - 4);
    }
    else if ( v8 >= 0 )
    {
      v9 = *((_DWORD *)this + 6) + 4 * v8;
    }
    else
    {
      v9 = (int)(this + 15);
      this[15] = (float)(v2 + 1);
    }
    v26 = (float *)v9;
    if ( v5 && v2 >= v5 )
    {
      this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v5 - 4);
      v10 = this + 15;
    }
    else if ( v2 >= 0 )
    {
      v10 = (float *)(*((_DWORD *)this + 6) + 4 * v2);
    }
    else
    {
      v10 = this + 15;
      this[15] = (float)v22;
    }
    v11 = v2 - 1;
    if ( v5 && v11 >= v5 )
    {
      this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v5 - 4);
      v12 = this + 15;
    }
    else if ( v11 >= 0 )
    {
      v12 = (float *)(*((_DWORD *)this + 6) + 4 * v11);
    }
    else
    {
      v12 = this + 15;
      this[15] = (float)(v2 - 1);
    }
    v13 = v2 - 2;
    if ( v5 && v13 >= v5 )
    {
      v14 = this + 15;
      this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v5 - 4);
    }
    else if ( v13 >= 0 )
    {
      v14 = (float *)(*((_DWORD *)this + 6) + 4 * v13);
    }
    else
    {
      v14 = this + 15;
      this[15] = (float)(v2 - 2);
    }
    v15 = *v10;
    v27 = v4 - *v12;
    v23 = v27 / (v15 - *v12);
    v28 = v23 + (v4 - *v14) / (v15 - *v14) - (v4 - *v14) / (v15 - *v14) * v23;
    v16 = v27 / (*v26 - *v12) * v23;
    v17 = v28 - v16;
    v18 = 1.0 - v28;
    if ( v2 <= 1 )
    {
      v17 = v17 + v18;
    }
    else
    {
      v19 = v24++;
      *(float *)(*(_DWORD *)(*((_DWORD *)this + 13) + 12 * v2 - 16) + 4 * v19) = v18;
    }
    if ( v2 <= 0 )
    {
      v16 = v16 + v17;
    }
    else
    {
      v20 = v21++;
      *(float *)(*(_DWORD *)(*((_DWORD *)this + 13) + 12 * v2 - 4) + 4 * v20) = v17;
    }
    *(float *)(*(_DWORD *)(*((_DWORD *)this + 13) + 12 * v2 + 8) + 4 * v3++) = v16;
    result = i + 1;
  }
  return result;
}

//----- (1000BED0) --------------------------------------------------------
int __thiscall sub_1000BED0(float *this)
{
  int result; // eax
  int v3; // edi
  int v4; // ebp
  bool v5; // cc
  int v6; // ecx
  float *v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  float *v15; // ebx
  int v16; // eax
  float *v17; // edx
  int v18; // eax
  float *v19; // eax
  int v20; // edx
  int v21; // eax
  int v22; // eax
  int v23; // edx
  int v24; // eax
  int v25; // [esp+Ch] [ebp-3Ch]
  int v26; // [esp+10h] [ebp-38h] BYREF
  int v27; // [esp+14h] [ebp-34h]
  int v28; // [esp+18h] [ebp-30h] BYREF
  int v29; // [esp+1Ch] [ebp-2Ch]
  int v30; // [esp+20h] [ebp-28h]
  int v31; // [esp+24h] [ebp-24h]
  int v32; // [esp+28h] [ebp-20h] BYREF
  int v33; // [esp+2Ch] [ebp-1Ch]
  float v34; // [esp+30h] [ebp-18h]
  float *v35; // [esp+34h] [ebp-14h]
  float *v36; // [esp+38h] [ebp-10h]
  float *v37; // [esp+3Ch] [ebp-Ch]
  int v38; // [esp+40h] [ebp-8h] BYREF
  int v39; // [esp+44h] [ebp-4h]

  result = *(_DWORD *)this;
  v3 = 0;
  v4 = 0;
  v5 = *(_DWORD *)this <= 0;
  v29 = 0;
  v30 = 0;
  v25 = 0;
  v27 = 0;
  v31 = 0;
  v33 = 0;
  if ( !v5 )
  {
    do
    {
      v6 = *((_DWORD *)this + 5);
      v34 = (float)v33;
      while ( 1 )
      {
        if ( v6 && v3 >= v6 )
        {
          v7 = this + 15;
          this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v6 - 4);
        }
        else if ( v3 >= 0 )
        {
          v7 = (float *)(*((_DWORD *)this + 6) + 4 * v3);
        }
        else
        {
          v7 = this + 15;
          this[15] = (float)v29;
        }
        if ( *v7 >= (double)v34 )
          break;
        ++v3;
        v30 = v25;
        v8 = v27;
        v27 = v4;
        v29 = v3;
        v25 = v8;
        v4 = 0;
      }
      v9 = v3 + 2;
      v31 = v4;
      v37 = (float *)(v3 + 2);
      if ( v6 && v9 >= v6 )
      {
        v10 = (int)(this + 15);
        this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v6 - 4);
      }
      else if ( v9 >= 0 )
      {
        v10 = *((_DWORD *)this + 6) + 4 * v9;
      }
      else
      {
        v10 = (int)(this + 15);
        this[15] = (float)(int)v37;
      }
      v35 = (float *)v10;
      v11 = v3 + 1;
      v37 = (float *)(v3 + 1);
      if ( v6 && v11 >= v6 )
      {
        v12 = (int)(this + 15);
        this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v6 - 4);
      }
      else if ( v11 >= 0 )
      {
        v12 = *((_DWORD *)this + 6) + 4 * v11;
      }
      else
      {
        v12 = (int)(this + 15);
        this[15] = (float)(int)v37;
      }
      v36 = (float *)v12;
      if ( v6 && v3 >= v6 )
      {
        v13 = (int)(this + 15);
        this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v6 - 4);
      }
      else if ( v3 >= 0 )
      {
        v13 = *((_DWORD *)this + 6) + 4 * v3;
      }
      else
      {
        v13 = (int)(this + 15);
        this[15] = (float)v29;
      }
      v37 = (float *)v13;
      v14 = v3 - 1;
      v39 = v3 - 1;
      if ( v6 && v14 >= v6 )
      {
        this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v6 - 4);
        v15 = this + 15;
      }
      else if ( v14 >= 0 )
      {
        v15 = (float *)(*((_DWORD *)this + 6) + 4 * v14);
      }
      else
      {
        v15 = this + 15;
        this[15] = (float)v39;
      }
      v16 = v3 - 2;
      v39 = v3 - 2;
      if ( v6 && v16 >= v6 )
      {
        this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v6 - 4);
        v17 = this + 15;
      }
      else if ( v16 >= 0 )
      {
        v17 = (float *)(*((_DWORD *)this + 6) + 4 * v16);
      }
      else
      {
        v17 = this + 15;
        this[15] = (float)v39;
      }
      v18 = v3 - 3;
      v39 = v3 - 3;
      if ( v6 && v18 >= v6 )
      {
        v4 = v31;
        v19 = this + 15;
        this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v6 - 4);
      }
      else if ( v18 >= 0 )
      {
        v19 = (float *)(*((_DWORD *)this + 6) + 4 * v18);
      }
      else
      {
        v19 = this + 15;
        this[15] = (float)v39;
      }
      sub_1000B750(*v19, *v17, *v15, *v37, *v36, *v35, v34, (float *)&v38, (float *)&v26, (float *)&v28, (float *)&v32);
      if ( v3 <= 2 )
      {
        *(float *)&v26 = *(float *)&v38 + *(float *)&v26;
      }
      else
      {
        v20 = *((_DWORD *)this + 13);
        v21 = v30++;
        *(float *)(*(_DWORD *)(v20 + 12 * v3 - 28) + 4 * v21) = *(float *)&v38;
      }
      if ( v3 <= 1 )
      {
        *(float *)&v28 = *(float *)&v26 + *(float *)&v28;
      }
      else
      {
        v22 = v25++;
        *(float *)(*(_DWORD *)(*((_DWORD *)this + 13) + 12 * v3 - 16) + 4 * v22) = *(float *)&v26;
      }
      if ( v3 <= 0 )
      {
        *(float *)&v32 = *(float *)&v28 + *(float *)&v32;
      }
      else
      {
        v23 = *((_DWORD *)this + 13);
        v24 = v27++;
        *(float *)(*(_DWORD *)(v23 + 12 * v3 - 4) + 4 * v24) = *(float *)&v28;
      }
      *(float *)(*(_DWORD *)(*((_DWORD *)this + 13) + 12 * v3 + 8) + 4 * v4++) = *(float *)&v32;
      result = v33 + 1;
      v5 = v33 + 1 < *(_DWORD *)this;
      v31 = v4;
      ++v33;
    }
    while ( v5 );
  }
  return result;
}

//----- (1000C1A0) --------------------------------------------------------
int __thiscall sub_1000C1A0(float *this)
{
  int v2; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // eax
  int v6; // ebx
  int v7; // ebx
  int v8; // ebp
  int v9; // eax
  int v10; // edi
  int v11; // eax
  int v12; // edi
  int v13; // eax
  int result; // eax
  int v15; // ebx
  int j; // eax
  int v17; // edi
  int v18; // ebx
  float *v19; // ebp
  int v20; // ecx
  int k; // eax
  int v22; // edx
  int v23; // [esp+10h] [ebp-2Ch]
  int i; // [esp+14h] [ebp-28h]
  _DWORD v25[2]; // [esp+24h] [ebp-18h] BYREF
  int v26; // [esp+2Ch] [ebp-10h]
  _DWORD v27[3]; // [esp+30h] [ebp-Ch] BYREF

  sub_1000C8B0(this);
  v2 = *((_DWORD *)this + 5);
  v3 = 0;
  if ( v2 > 0 )
  {
    v23 = 0;
    do
    {
      v4 = *((_DWORD *)this + 3) + 1;
      if ( v4 + v3 >= v2 )
        v4 = v2 - v3;
      v5 = sub_1000C890(this, v4);
      sub_1000C8C0((_DWORD *)(v23 + *((_DWORD *)this + 14)), v4, v3, v5);
      v6 = 1 - sub_1000C3E0(this, v3);
      v7 = sub_1000C450((char *)this, v3) + v6;
      v8 = 0;
      if ( v3 - 1 >= 0 )
        v8 = (int)*(float *)sub_1000B6E0(this, v3 - 1) + 1;
      v9 = sub_1000C890(this, v7);
      sub_1000C8C0((_DWORD *)(v23 + *((_DWORD *)this + 13)), v7, v8, v9);
      v2 = *((_DWORD *)this + 5);
      ++v3;
      v23 += 12;
    }
    while ( v3 < v2 );
  }
  switch ( *((_DWORD *)this + 3) )
  {
    case 0:
      sub_1000BAD0(this);
      break;
    case 1:
      sub_1000BB60(this);
      break;
    case 2:
      sub_1000BCA0(this);
      break;
    case 3:
      sub_1000BED0(this);
      break;
    default:
      break;
  }
  sub_1000C980(*((_DWORD *)this + 5), *((_DWORD **)this + 13), *((_DWORD *)this + 14));
  sub_1000CA00(*((_DWORD *)this + 5), *((_DWORD *)this + 14));
  v10 = *(_DWORD *)this;
  v11 = sub_1000C890(this, *(_DWORD *)this);
  sub_1000C8C0(v27, v10, 0, v11);
  v12 = *((_DWORD *)this + 5);
  v13 = sub_1000C890(this, v12);
  sub_1000C8C0(v25, v12, 0, v13);
  result = *((_DWORD *)this + 1);
  v15 = 0;
  for ( i = 0; v15 < result; i = v15 )
  {
    for ( j = 0; j < *(_DWORD *)this; ++j )
      *(_DWORD *)(v27[2] + 4 * j) = *(_DWORD *)(*((_DWORD *)this + 2) + 4 * (v15 + j * *((_DWORD *)this + 1)));
    v17 = 0;
    if ( *((int *)this + 5) > 0 )
    {
      v18 = 0;
      do
      {
        v19 = (float *)(v26 + 4 * v17);
        *v19 = sub_1000C910(v27, (_DWORD *)(v18 + *((_DWORD *)this + 13)));
        ++v17;
        v18 += 12;
      }
      while ( v17 < *((_DWORD *)this + 5) );
      v15 = i;
    }
    sub_1000CB60(*((_DWORD *)this + 5), *((_DWORD *)this + 14), (int)v25);
    v20 = *((_DWORD *)this + 5);
    for ( k = 0; k < v20; ++k )
    {
      v22 = k;
      if ( k >= v20 )
        v22 = v20 - 1;
      if ( v22 < 0 )
        v22 = 0;
      *(_DWORD *)(*((_DWORD *)this + 7) + 4 * (v15 + v22 * *((_DWORD *)this + 1))) = *(_DWORD *)(v26 + 4 * k);
      v20 = *((_DWORD *)this + 5);
    }
    result = *((_DWORD *)this + 1);
    ++v15;
  }
  return result;
}

//----- (1000C3E0) --------------------------------------------------------
int __thiscall sub_1000C3E0(float *this, int a2)
{
  int v2; // edx
  int result; // eax
  int v4; // esi
  float *v5; // eax

  v2 = a2 - 1;
  result = 0;
  if ( a2 - 1 >= 0 )
  {
    v4 = *((_DWORD *)this + 5);
    if ( v4 && v2 >= v4 )
    {
      v5 = this + 15;
      this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v4 - 4);
    }
    else
    {
      v5 = (float *)(*((_DWORD *)this + 6) + 4 * v2);
    }
    return (int)*v5 + 1;
  }
  return result;
}

//----- (1000C450) --------------------------------------------------------
int __thiscall sub_1000C450(char *this, int a2)
{
  int result; // eax
  float *v3; // eax
  int v4; // [esp+14h] [ebp+4h]

  result = *(_DWORD *)this - 1;
  v4 = a2 + *((_DWORD *)this + 3);
  if ( v4 < *((_DWORD *)this + 5) )
  {
    if ( v4 >= 0 )
    {
      v3 = (float *)(*((_DWORD *)this + 6) + 4 * v4);
    }
    else
    {
      v3 = (float *)(this + 60);
      *((float *)this + 15) = (float)v4;
    }
    return (int)*v3;
  }
  return result;
}

//----- (1000C4C0) --------------------------------------------------------
char __thiscall sub_1000C4C0(float *this, float a2)
{
  int v3; // ebx
  int v4; // edi
  int v5; // ecx
  float *v6; // eax
  int v7; // eax
  float *v8; // edx
  int v9; // ecx
  float *v10; // ecx
  int v11; // eax
  int v12; // ecx
  float *v13; // eax
  int *v14; // ebp
  int v15; // ebx
  int v16; // eax
  int v17; // edi
  float *v18; // ecx
  float v19; // edx
  int v20; // ecx
  float *v21; // ecx
  int v22; // eax
  float *v23; // ecx
  int v25; // [esp+10h] [ebp-18h]
  int *v26; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  float v28; // [esp+18h] [ebp-10h]
  float v29; // [esp+20h] [ebp-8h]
  float v30; // [esp+24h] [ebp-4h]

  v26 = (int *)*((_DWORD *)this + 8);
  v3 = 1;
  v4 = 0;
  v25 = 0;
  for ( i = 1; v3 < *(_DWORD *)this; i = v3 )
  {
    v5 = *((_DWORD *)this + 5);
    v28 = (float)i;
    while ( 1 )
    {
      if ( v5 && v4 >= v5 )
      {
        v6 = this + 15;
        this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v5 - 4);
      }
      else if ( v4 >= 0 )
      {
        v6 = (float *)(*((_DWORD *)this + 6) + 4 * v4);
      }
      else
      {
        v6 = this + 15;
        this[15] = (float)v25;
      }
      if ( *v6 >= (double)v28 )
        break;
      v25 = ++v4;
    }
    if ( sub_1000C840(this, v4, v28, v3) > a2 )
    {
      v7 = *((_DWORD *)this + 5);
      if ( v7 && v4 >= v7 )
      {
        this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v7 - 4);
        v8 = this + 15;
      }
      else if ( v4 >= 0 )
      {
        v8 = (float *)(*((_DWORD *)this + 6) + 4 * v4);
      }
      else
      {
        v8 = this + 15;
        this[15] = (float)v25;
      }
      v9 = v4 - 1;
      if ( v7 && v9 >= v7 )
      {
        v10 = this + 15;
        this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v7 - 4);
      }
      else if ( v9 >= 0 )
      {
        v10 = (float *)(*((_DWORD *)this + 6) + 4 * v9);
      }
      else
      {
        v10 = this + 15;
        this[15] = (float)(v4 - 1);
      }
      if ( *v8 - *v10 >= 3.0 )
      {
        *v26++ = v4;
        v11 = v4 + *((_DWORD *)this + 3);
        v12 = *(_DWORD *)this - 1;
        if ( v11 < *((_DWORD *)this + 5) )
        {
          if ( v11 >= 0 )
          {
            v13 = (float *)(*((_DWORD *)this + 6) + 4 * v11);
          }
          else
          {
            v13 = this + 15;
            this[15] = (float)(v4 + *((_DWORD *)this + 3));
          }
          v12 = (int)*v13;
        }
        v3 = v12;
      }
    }
    ++v3;
  }
  v14 = (int *)*((_DWORD *)this + 8);
  v15 = 0;
  if ( v14 == v26 )
    return 0;
  do
  {
    v16 = *((_DWORD *)this + 5);
    v17 = v15 + *v14;
    ++v15;
    if ( v16 && v17 >= v16 )
    {
      v18 = this + 15;
      this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v16 - 4);
    }
    else if ( v17 >= 0 )
    {
      v18 = (float *)(*((_DWORD *)this + 6) + 4 * v17);
    }
    else
    {
      v18 = this + 15;
      this[15] = (float)v17;
    }
    v19 = *v18;
    v20 = v17 - 1;
    v29 = v19;
    if ( v16 && v20 >= v16 )
    {
      v21 = this + 15;
      this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v16 - 4);
    }
    else if ( v20 >= 0 )
    {
      v21 = (float *)(*((_DWORD *)this + 6) + 4 * v20);
    }
    else
    {
      v21 = this + 15;
      this[15] = (float)(v17 - 1);
    }
    v30 = *v21;
    sub_1000C810((unsigned int *)this, v17);
    v22 = *((_DWORD *)this + 5);
    if ( v22 && v17 >= v22 )
    {
      v23 = this + 15;
      this[15] = *(float *)(*((_DWORD *)this + 6) + 4 * v22 - 4);
    }
    else if ( v17 >= 0 )
    {
      v23 = (float *)(*((_DWORD *)this + 6) + 4 * v17);
    }
    else
    {
      v23 = this + 15;
      this[15] = (float)v17;
    }
    *v23 = (v30 + v29) * 0.5;
    sub_1000C1A0(this);
    ++v14;
  }
  while ( v14 != v26 );
  return 1;
}

//----- (1000C750) --------------------------------------------------------
int __thiscall sub_1000C750(unsigned int *this, int a2, int a3)
{
  int v3; // eax
  int v4; // ebp
  _DWORD *v5; // esi
  _DWORD *v6; // edx
  __int64 v7; // rax
  int v8; // edi
  int v9; // esi

  v3 = this[5];
  v4 = a2;
  if ( v3 && a2 >= v3 )
  {
    this[15] = *(_DWORD *)(this[6] + 4 * v3 - 4);
    v5 = this + 15;
  }
  else if ( a2 >= 0 )
  {
    v5 = (_DWORD *)(this[6] + 4 * a2);
  }
  else
  {
    v5 = this + 15;
    *((float *)this + 15) = (float)a2;
  }
  if ( v3 && a3 >= v3 )
  {
    v6 = this + 15;
    this[15] = *(_DWORD *)(this[6] + 4 * v3 - 4);
  }
  else if ( a3 >= 0 )
  {
    v6 = (_DWORD *)(this[6] + 4 * a3);
  }
  else
  {
    v6 = this + 15;
    *((float *)this + 15) = (float)a3;
  }
  *v6 = *v5;
  v7 = this[1];
  if ( (int)v7 > 0 )
  {
    while ( 1 )
    {
      v8 = this[5];
      v9 = a3;
      if ( a3 >= v8 )
        v9 = v8 - 1;
      if ( v9 < 0 )
        v9 = 0;
      *(_DWORD *)(this[7] + 4 * (HIDWORD(v7) + v9 * v7)) = *(_DWORD *)(this[2] + 4 * (HIDWORD(v7) + v4 * v7));
      LODWORD(v7) = this[1];
      ++HIDWORD(v7);
      if ( SHIDWORD(v7) >= (int)v7 )
        break;
      v4 = a2;
    }
  }
  return v7;
}

//----- (1000C810) --------------------------------------------------------
int __thiscall sub_1000C810(unsigned int *this, int a2)
{
  int result; // eax
  int v3; // esi

  result = this[5];
  this[5] = result + 1;
  if ( result > a2 )
  {
    do
    {
      v3 = result - 1;
      sub_1000C750(this, result - 1, result);
      result = v3;
    }
    while ( v3 > a2 );
  }
  return result;
}
// 1000C829: variable 'this' is possibly undefined

//----- (1000C840) --------------------------------------------------------
long double __thiscall sub_1000C840(_DWORD *this, int a2, float a3, int a4)
{
  long double v5; // st7
  int v6; // edx
  float *v7; // ecx
  float *v8; // eax
  double v9; // st6
  double v10; // st6

  sub_1000B310((int)this, *(float *)&a2, a3, this[9]);
  v5 = 0.0;
  v6 = this[1];
  if ( v6 > 0 )
  {
    v7 = (float *)this[9];
    v8 = (float *)(this[2] + 4 * a4 * v6);
    do
    {
      v9 = *v8++;
      v10 = v9 - *v7++;
      --v6;
      v5 = v5 + v10 * v10;
    }
    while ( v6 );
  }
  return sqrt(v5);
}

//----- (1000C890) --------------------------------------------------------
int __thiscall sub_1000C890(_DWORD *this, int a2)
{
  int v2; // edx
  int result; // eax

  v2 = this[10];
  result = this[12] + 4 * v2;
  this[10] = a2 + v2;
  return result;
}

//----- (1000C8B0) --------------------------------------------------------
void __thiscall sub_1000C8B0(_DWORD *this)
{
  this[10] = 0;
}

//----- (1000C8C0) --------------------------------------------------------
int __thiscall sub_1000C8C0(_DWORD *this, int a2, int a3, int a4)
{
  int result; // eax

  *this = a3;
  result = a4;
  this[1] = a2;
  this[2] = a4;
  return result;
}

//----- (1000C8E0) --------------------------------------------------------
float *__thiscall sub_1000C8E0(float **this, float *a2, float a3)
{
  float *result; // eax

  if ( *this == (float *)-1 )
  {
    result = a2;
    *this = a2;
    *this[2] = a3;
  }
  else
  {
    result = this[2];
    result[(char *)a2 - (char *)*this] = a3;
  }
  return result;
}

//----- (1000C910) --------------------------------------------------------
double __cdecl sub_1000C910(_DWORD *a1, _DWORD *a2)
{
  double result; // st7
  int v3; // eax
  int v4; // ecx
  int v5; // edx
  float *v6; // ecx
  int v7; // eax
  double v8; // st6

  result = 0.0;
  if ( *a1 > *a2 )
    return sub_1000C910(a2, a1);
  v3 = *a2 - *a1;
  v4 = a1[1];
  if ( v3 < v4 )
  {
    v5 = a2[1];
    if ( v5 + v3 > v4 )
      v5 = v4 - v3;
    if ( v5 > 0 )
    {
      v6 = (float *)a2[2];
      v7 = a1[2] + 4 * v3;
      do
      {
        v7 += 4;
        v8 = *v6++ * *(float *)(v7 - 4);
        --v5;
        result = result + v8;
      }
      while ( v5 );
    }
  }
  return result;
}

//----- (1000C980) --------------------------------------------------------
void __cdecl sub_1000C980(int a1, _DWORD *a2, int a3)
{
  float *v4; // esi
  _DWORD *v5; // edi
  int v6; // ebp
  double v7; // st7
  float *v8; // [esp+8h] [ebp-4h]
  _DWORD *v9; // [esp+10h] [ebp+4h]
  float v10; // [esp+14h] [ebp+8h]

  v4 = 0;
  v8 = 0;
  if ( a1 > 0 )
  {
    v5 = a2;
    v6 = 0;
    v9 = a2;
    do
    {
      do
      {
        v7 = sub_1000C910(v5, v9);
        if ( v7 == 0.0 )
          break;
        v10 = v7;
        sub_1000C8E0((float **)(a3 + v6), v4, v10);
        v4 = (float *)((char *)v4 + 1);
        v5 += 3;
      }
      while ( (int)v4 < a1 );
      v4 = (float *)((char *)v8 + 1);
      v5 = v9 + 3;
      v6 += 12;
      v8 = v4;
      v9 += 3;
    }
    while ( (int)v4 < a1 );
  }
}

//----- (1000CA00) --------------------------------------------------------
int __cdecl sub_1000CA00(int a1, int a2)
{
  int result; // eax
  float *v3; // ebp
  float **v4; // ebx
  float **v5; // edi
  float *v6; // ecx
  int v7; // eax
  double v8; // st7
  int v9; // eax
  float *v10; // esi
  float **v11; // ebx
  int v12; // edx
  double v13; // st7
  int v14; // eax
  double v15; // st6
  int v16; // eax
  long double v17; // st7
  long double v18; // st7
  int v19; // eax
  double v20; // st7
  float *v21; // ecx
  float v22; // [esp+0h] [ebp-1Ch]
  int v23; // [esp+14h] [ebp-8h]
  float **v24; // [esp+18h] [ebp-4h]
  float v25; // [esp+24h] [ebp+8h]
  float i; // [esp+24h] [ebp+8h]

  result = a1;
  v3 = 0;
  if ( a1 > 0 )
  {
    v4 = (float **)(a2 + 8);
    v24 = (float **)(a2 + 8);
    do
    {
      v23 = (int)v3 - 1;
      if ( (int)v3 - 1 >= 0 )
      {
        v5 = v4 - 5;
        do
        {
          v6 = *v5;
          v7 = (char *)v3 - (char *)*v5;
          if ( v7 < 0 || v7 >= (int)v5[1] )
            v8 = 0.0;
          else
            v8 = v5[2][v7];
          v25 = v8;
          if ( v8 == 0.0 )
            break;
          v9 = (int)v5[1];
          v10 = v3;
          if ( (int)v3 < (int)((char *)v6 + v9) )
          {
            v11 = v4 - 2;
            do
            {
              v12 = (char *)v10 - (char *)v6;
              if ( (char *)v10 - (char *)v6 < 0 || v12 >= v9 )
                v13 = 0.0;
              else
                v13 = v5[2][v12];
              v14 = (char *)v10 - (char *)*v11;
              if ( v14 < 0 || v14 >= (int)v11[1] )
                v15 = 0.0;
              else
                v15 = v11[2][v14];
              v22 = v15 - v13 * v25;
              sub_1000C8E0(v11, v10, v22);
              v9 = (int)v5[1];
              v6 = *v5;
              v10 = (float *)((char *)v10 + 1);
            }
            while ( (int)v10 < (int)((char *)*v5 + v9) );
            v4 = v24;
          }
          v5 -= 3;
          --v23;
        }
        while ( v23 >= 0 );
      }
      v16 = (char *)v3 - (char *)*(v4 - 2);
      if ( v16 < 0 || v16 >= (int)*(v4 - 1) )
        v17 = 0.0;
      else
        v17 = (*v4)[v16];
      v18 = sqrt(v17);
      **v4 = v18;
      if ( v18 != 0.0 )
      {
        v19 = 1;
        for ( i = 1.0 / v18; v19 < (int)*(v4 - 1); *v21 = v20 )
        {
          v20 = i * (*v4)[v19];
          v21 = &(*v4)[v19++];
        }
      }
      result = a1;
      v3 = (float *)((char *)v3 + 1);
      v4 += 3;
      v24 = v4;
    }
    while ( (int)v3 < a1 );
  }
  return result;
}
// 1002A170: using guessed type float flt_1002A170;

//----- (1000CB60) --------------------------------------------------------
float *__cdecl sub_1000CB60(int a1, int a2, int a3)
{
  float *result; // eax
  int v4; // ebx
  int v5; // edi
  int *v6; // ebp
  float *v7; // esi
  int v8; // ecx
  int *v9; // edx
  int v10; // eax
  double v11; // st7
  double v12; // st7
  int v13; // eax
  double v14; // st7
  int v15; // edi
  int *v16; // ecx
  int v17; // edx
  int v18; // esi
  double v19; // st7
  int v20; // edx
  double v21; // st7
  int *v22; // [esp+10h] [ebp-4h]

  result = (float *)a1;
  v4 = a3;
  v5 = 0;
  if ( a1 > 0 )
  {
    v6 = (int *)(a2 + 4);
    v22 = (int *)(a2 + 4);
    do
    {
      v7 = (float *)(*(_DWORD *)(a3 + 8) + 4 * v5);
      v8 = v5 - 1;
      if ( v5 - 1 >= 0 )
      {
        v9 = v6 - 2;
        do
        {
          v10 = v5 - *(v9 - 2);
          if ( v10 < 0 || v10 >= *(v9 - 1) )
          {
            v11 = 0.0;
          }
          else
          {
            v11 = *(float *)(*v9 + 4 * v10);
            v6 = v22;
          }
          if ( v11 == 0.0 )
            break;
          v12 = v11 * *(float *)(*(_DWORD *)(a3 + 8) + 4 * v8--);
          v9 -= 3;
          *v7 = *v7 - v12;
        }
        while ( v8 >= 0 );
      }
      v13 = v5 - *(v6 - 1);
      if ( v13 < 0 || v13 >= *v6 )
        v14 = 0.0;
      else
        v14 = *(float *)(v6[1] + 4 * v13);
      result = (float *)a1;
      ++v5;
      v6 += 3;
      v22 = v6;
      *v7 = *v7 / v14;
    }
    while ( v5 < a1 );
  }
  v15 = a1 - 1;
  if ( a1 - 1 >= 0 )
  {
    v16 = (int *)(a2 + 12 * v15 + 4);
    do
    {
      v17 = 1;
      result = (float *)(4 * v15 + *(_DWORD *)(v4 + 8));
      if ( *v16 > 1 )
      {
        v18 = 4 * v15 + 4;
        do
        {
          v19 = *(float *)(v16[1] + 4 * v17++) * *(float *)(v18 + *(_DWORD *)(v4 + 8));
          v18 += 4;
          *result = *result - v19;
          v4 = a3;
        }
        while ( v17 < *v16 );
      }
      v20 = v15 - *(v16 - 1);
      if ( v20 < 0 || v20 >= *v16 )
        v21 = 0.0;
      else
        v21 = *(float *)(v16[1] + 4 * v20);
      --v15;
      v16 -= 3;
      *result = *result / v21;
    }
    while ( v15 >= 0 );
  }
  return result;
}

//----- (1000CC90) --------------------------------------------------------
int __cdecl sub_1000CC90(float a1, int a2, char a3, int a4, _DWORD *a5, int a6, float a7, int a8, int a9)
{
  int v9; // eax
  int v10; // eax
  int v11; // ecx
  float *v13; // ebp
  float *v14; // edi
  float *v15; // edx
  int v16; // esi
  int v18[5]; // [esp+8h] [ebp-40h] BYREF
  int v19; // [esp+1Ch] [ebp-2Ch]
  float *v20; // [esp+20h] [ebp-28h]
  _DWORD *v21; // [esp+24h] [ebp-24h]
  float v22; // [esp+44h] [ebp-4h] BYREF
  int v23; // [esp+58h] [ebp+10h]

  v9 = a6;
  if ( a4 < a6 )
    v9 = a4 - 1;
  sub_1000B860(v18, a4, a2, v9, a3);
  sub_10019E30(a4 * a2, a5, v18[2]);
  sub_1000B290((float *)v18, a7);
  v10 = v19;
  v11 = 0;
  v23 = 0;
  if ( v19 > 0 )
  {
    v13 = v20;
    v14 = v20;
    do
    {
      if ( v10 && v11 >= v10 )
      {
        v15 = &v22;
        v22 = v13[v10 - 1];
      }
      else if ( v11 >= 0 )
      {
        v15 = v14;
      }
      else
      {
        v15 = &v22;
        v22 = (float)v23;
      }
      a8 += 4;
      ++v11;
      ++v14;
      *(float *)(a8 - 4) = a1 * *v15;
      v23 = v11;
    }
    while ( v11 < v10 );
  }
  sub_10019E30(a2 * v10, v21, a9);
  v16 = v19;
  sub_1000B9A0(v18);
  return v16;
}

//----- (1000CD70) --------------------------------------------------------
int __cdecl sub_1000CD70(int a1)
{
  *(_DWORD *)a1 = 1068121457;
  *(_DWORD *)(a1 + 4) = 1068121457;
  *(_DWORD *)(a1 + 8) = 1065353216;
  *(_DWORD *)(a1 + 16) = 1036831949;
  *(_DWORD *)(a1 + 20) = 1148846080;
  *(float *)(a1 + 12) = 3.1415927 * 0.33333334;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 1065353216;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  return sub_1000CEC0((float *)a1);
}

//----- (1000CDF0) --------------------------------------------------------
float *__cdecl sub_1000CDF0(float *a1, float a2, float a3, float a4, float a5, float a6)
{
  float *result; // eax

  result = a1;
  *a1 = a2;
  a1[1] = a3 / a4;
  a1[2] = a5 / a6;
  return result;
}

//----- (1000CE20) --------------------------------------------------------
float *__cdecl sub_1000CE20(float *a1, float a2, float a3, float a4)
{
  float *result; // eax

  result = a1;
  a1[10] = a2 * a1[35] + a1[10];
  a1[11] = a2 * a1[36] + a1[11];
  a1[12] = a2 * a1[37] + a1[12];
  a1[10] = a3 * a1[39] + a1[10];
  a1[11] = a3 * a1[40] + a1[11];
  a1[12] = a3 * a1[41] + a1[12];
  a1[10] = a4 * a1[43] + a1[10];
  a1[11] = a4 * a1[44] + a1[11];
  a1[12] = a4 * a1[45] + a1[12];
  return result;
}

//----- (1000CEC0) --------------------------------------------------------
int __cdecl sub_1000CEC0(float *a1)
{
  sub_1000CFE0(a1, (int)(a1 + 19), (int)(a1 + 35));
  return sub_1000CEF0(a1, (int)(a1 + 51), (int)(a1 + 67));
}

//----- (1000CEF0) --------------------------------------------------------
int __cdecl sub_1000CEF0(float *a1, int a2, int a3)
{
  int result; // eax
  long double v5; // st7
  long double v6; // st6
  double v7; // st7
  double v8; // st6
  double v9; // st7
  double v10; // st6
  double v11; // st7
  double v12; // st7
  double v13; // st7

  result = a2;
  v5 = sin(a1[3] * 0.5) / cos(a1[3] * 0.5);
  v6 = a1[1] / (a1[2] * *a1 * v5);
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  *(float *)a2 = v6;
  *(float *)(a2 + 20) = 1.0 / v5;
  v7 = a1[4] + a1[5];
  v8 = a1[4] - a1[5];
  *(_DWORD *)(a2 + 44) = -1082130432;
  *(_DWORD *)(a2 + 48) = 0;
  *(_DWORD *)(a2 + 52) = 0;
  *(float *)(a2 + 40) = v7 / v8;
  v9 = a1[4] * a1[5];
  v10 = a1[4] - a1[5];
  *(_DWORD *)(a2 + 60) = 0;
  *(float *)(a2 + 56) = (v9 + v9) / v10;
  v11 = 1.0 / *(float *)a2;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 12) = 0;
  *(_DWORD *)(a3 + 16) = 0;
  *(float *)a3 = v11;
  v12 = 1.0 / *(float *)(a2 + 20);
  *(_DWORD *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 28) = 0;
  *(_DWORD *)(a3 + 32) = 0;
  *(_DWORD *)(a3 + 36) = 0;
  *(_DWORD *)(a3 + 40) = 0;
  *(float *)(a3 + 20) = v12;
  v13 = 1.0 / *(float *)(a2 + 56);
  *(_DWORD *)(a3 + 48) = 0;
  *(_DWORD *)(a3 + 52) = 0;
  *(float *)(a3 + 44) = v13;
  *(float *)(a3 + 56) = 1.0 / *(float *)(a2 + 44);
  *(float *)(a3 + 60) = -(*(float *)(a2 + 40) / (*(float *)(a2 + 44) * *(float *)(a2 + 56)));
  return result;
}

//----- (1000CFE0) --------------------------------------------------------
int __cdecl sub_1000CFE0(float *a1, int a2, int a3)
{
  long double v4; // st7
  long double v5; // st7
  long double v6; // st7
  float v7; // ecx
  float v8; // edx
  double v9; // st7
  float v10; // ecx
  double v11; // st7
  double v12; // st7
  int result; // eax
  double v14; // st7
  double v15; // st6
  double v16; // st5
  float v17; // [esp+8h] [ebp-A0h]
  float v18; // [esp+8h] [ebp-A0h]
  float v19; // [esp+8h] [ebp-A0h]
  float v20; // [esp+Ch] [ebp-9Ch]
  float v21; // [esp+10h] [ebp-98h]
  float v22; // [esp+10h] [ebp-98h]
  float v23; // [esp+14h] [ebp-94h]
  float v24; // [esp+14h] [ebp-94h]
  float v25; // [esp+14h] [ebp-94h]
  float v26; // [esp+14h] [ebp-94h]
  float v27; // [esp+18h] [ebp-90h] BYREF
  float v28; // [esp+1Ch] [ebp-8Ch]
  float v29; // [esp+20h] [ebp-88h]
  float v30; // [esp+24h] [ebp-84h]
  float v31; // [esp+28h] [ebp-80h]
  float v32; // [esp+2Ch] [ebp-7Ch]
  float v33; // [esp+30h] [ebp-78h]
  float v34; // [esp+34h] [ebp-74h]
  float v35; // [esp+38h] [ebp-70h]
  float v36; // [esp+3Ch] [ebp-6Ch] BYREF
  float v37; // [esp+40h] [ebp-68h]
  float v38; // [esp+44h] [ebp-64h]
  float v39; // [esp+48h] [ebp-60h]
  float v40; // [esp+4Ch] [ebp-5Ch]
  float v41; // [esp+50h] [ebp-58h]
  float v42; // [esp+54h] [ebp-54h]
  float v43; // [esp+58h] [ebp-50h]
  float v44; // [esp+5Ch] [ebp-4Ch]
  float v45[9]; // [esp+60h] [ebp-48h] BYREF
  float v46[9]; // [esp+84h] [ebp-24h] BYREF

  sub_100189A0(v45, a1 + 6);
  v4 = a1[14];
  v37 = 0.0;
  v39 = 0.0;
  v40 = 1.0;
  v41 = 0.0;
  v43 = 0.0;
  v17 = sin(v4);
  v38 = v17;
  v36 = cos(v4);
  v42 = -v17;
  v44 = v36;
  sub_10018450(&v27, v45, &v36);
  v18 = a1[13];
  v5 = sin(v18);
  v36 = 1.0;
  v37 = 0.0;
  v38 = 0.0;
  v39 = 0.0;
  v42 = 0.0;
  v40 = cos(v18);
  v41 = -v5;
  v43 = v5;
  v44 = v40;
  sub_10018450(v46, &v27, &v36);
  v19 = a1[15];
  v38 = 0.0;
  v6 = sin(v19);
  v36 = cos(v19);
  v37 = -v6;
  v39 = v6;
  v40 = v36;
  v41 = 0.0;
  v42 = 0.0;
  v43 = 0.0;
  v44 = 1.0;
  sub_10018450(&v27, v46, &v36);
  v7 = v29;
  *(float *)a2 = v27;
  v8 = v28;
  v9 = v33;
  *(float *)(a2 + 8) = v7;
  *(float *)(a2 + 16) = v30;
  *(float *)(a2 + 20) = v31;
  *(float *)(a2 + 24) = v32;
  *(float *)(a2 + 32) = v33;
  v10 = v34;
  *(float *)(a2 + 4) = v8;
  *(float *)(a2 + 36) = v10;
  *(float *)(a2 + 40) = v35;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 44) = 0;
  v23 = v35 * a1[12] + v29 * a1[10] + v32 * a1[11];
  v20 = v9 * a1[12] + v27 * a1[10] + v30 * a1[11] + a1[16];
  v21 = v34 * a1[12] + v28 * a1[10] + v31 * a1[11] + a1[17];
  v24 = -(v23 + a1[18]);
  *(float *)(a2 + 48) = -v20;
  *(float *)(a2 + 52) = -v21;
  v11 = v27;
  *(float *)(a2 + 56) = v24;
  *(_DWORD *)(a2 + 60) = 1065353216;
  *(float *)a3 = v11;
  v12 = v28;
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a3 + 12) = 0;
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a3 + 20) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a3 + 28) = 0;
  *(_DWORD *)(a3 + 32) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a3 + 36) = *(_DWORD *)(a2 + 24);
  result = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a3 + 44) = 0;
  *(_DWORD *)(a3 + 40) = result;
  v22 = v31 * a1[17] + v30 * a1[16] + v32 * a1[18];
  v25 = v34 * a1[17] + v33 * a1[16] + v35 * a1[18];
  v14 = v12 * a1[17] + v27 * a1[16] + v29 * a1[18] + a1[10];
  v15 = v22 + a1[11];
  v16 = v25 + a1[12];
  *(_DWORD *)(a3 + 60) = 1065353216;
  v26 = v16;
  *(float *)(a3 + 56) = v26;
  *(float *)(a3 + 48) = v14;
  *(float *)(a3 + 52) = v15;
  return result;
}

//----- (1000D2F0) --------------------------------------------------------
int __cdecl sub_1000D2F0(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = a1[47];
  a2[1] = a1[48];
  result = a1[49];
  a2[2] = result;
  return result;
}

//----- (1000D320) --------------------------------------------------------
float *__cdecl sub_1000D320(float *a1, float *a2)
{
  float *result; // eax

  result = a1;
  *a2 = -a1[35];
  a2[1] = -a1[36];
  a2[2] = -a1[37];
  return result;
}

//----- (1000D350) --------------------------------------------------------
int __cdecl sub_1000D350(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = a1[35];
  a2[1] = a1[36];
  result = a1[37];
  a2[2] = result;
  return result;
}

//----- (1000D380) --------------------------------------------------------
int __cdecl sub_1000D380(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = a1[39];
  a2[1] = a1[40];
  result = a1[41];
  a2[2] = result;
  return result;
}

//----- (1000D3B0) --------------------------------------------------------
float *__cdecl sub_1000D3B0(float *a1, float *a2)
{
  float *result; // eax

  result = a1;
  *a2 = -a1[39];
  a2[1] = -a1[40];
  a2[2] = -a1[41];
  return result;
}

//----- (1000D3E0) --------------------------------------------------------
float *__cdecl sub_1000D3E0(float *a1, float *a2)
{
  float *result; // eax

  result = a1;
  *a2 = -a1[43];
  a2[1] = -a1[44];
  a2[2] = -a1[45];
  return result;
}

//----- (1000D410) --------------------------------------------------------
int __cdecl sub_1000D410(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = a1[43];
  a2[1] = a1[44];
  result = a1[45];
  a2[2] = result;
  return result;
}

//----- (1000D440) --------------------------------------------------------
float *__cdecl sub_1000D440(float *a1, float a2, float a3, float *a4, float *a5)
{
  double v5; // st7
  double v6; // st6
  double v7; // st7
  double v8; // st6
  double v9; // st4
  double v10; // st7
  float *result; // eax
  double v12; // st6
  float v13; // [esp+0h] [ebp-10h]
  float v14; // [esp+0h] [ebp-10h]
  float v15; // [esp+4h] [ebp-Ch]
  float v16; // [esp+8h] [ebp-8h]
  float v17; // [esp+Ch] [ebp-4h]
  float v18; // [esp+18h] [ebp+8h]
  float v19; // [esp+18h] [ebp+8h]
  float v20; // [esp+1Ch] [ebp+Ch]
  float v21; // [esp+1Ch] [ebp+Ch]
  float v22; // [esp+20h] [ebp+10h]

  v5 = (*a4 + *a4 - a2) / a2;
  v6 = (a4[1] + a4[1] - a3) / a3;
  v16 = (a4[2] + a4[2] - 1.0 - -1.0) * 0.5;
  v18 = v5;
  v20 = v6;
  v13 = v16 * a1[75] + v6 * a1[71] + v5 * a1[67] + a1[79];
  v7 = v18 * a1[68] + v16 * a1[76] + v6 * a1[72] + a1[80];
  v8 = v20 * a1[73] + v18 * a1[69] + v16 * a1[77] + a1[81];
  v9 = v18;
  v19 = v13;
  v17 = v16 * a1[78] + v20 * a1[74] + v9 * a1[70] + a1[82];
  v21 = v7;
  v22 = v8;
  v14 = v17 * a1[47] + v8 * a1[43] + v7 * a1[39] + v13 * a1[35];
  v15 = v19 * a1[36] + v17 * a1[48] + v8 * a1[44] + v7 * a1[40];
  v10 = v21 * a1[41] + v19 * a1[37] + v17 * a1[49] + v8 * a1[45];
  result = a5;
  v12 = 1.0 / (v22 * a1[46] + v21 * a1[42] + v19 * a1[38] + v17 * a1[50]);
  *a5 = v14 * v12;
  a5[1] = v15 * v12;
  a5[2] = v12 * v10;
  return result;
}

//----- (1000D630) --------------------------------------------------------
float *__cdecl sub_1000D630(float *a1, float a2, float a3, float *a4, float *a5)
{
  double v5; // st7
  double v6; // st6
  double v8; // st7
  double v9; // st6
  double v10; // st4
  double v11; // st7
  double v12; // st6
  double v13; // st5
  float *result; // eax
  double v15; // st6
  float v16; // [esp+0h] [ebp-14h]
  float v17; // [esp+4h] [ebp-10h]
  float v18; // [esp+4h] [ebp-10h]
  float v19; // [esp+4h] [ebp-10h]
  float v20; // [esp+8h] [ebp-Ch]
  float v21; // [esp+8h] [ebp-Ch]
  float v22; // [esp+Ch] [ebp-8h]
  float v23; // [esp+10h] [ebp-4h]
  float v24; // [esp+18h] [ebp+4h]
  float v25; // [esp+18h] [ebp+4h]
  float v26; // [esp+24h] [ebp+10h]
  float v27; // [esp+24h] [ebp+10h]

  v5 = *a4;
  v6 = a4[1];
  v22 = a4[2];
  v26 = *a4;
  v24 = v6;
  v17 = v22 * a1[27] + v6 * a1[23] + v5 * a1[19] + a1[31];
  v8 = v26 * a1[20] + v22 * a1[28] + v6 * a1[24] + a1[32];
  v9 = v24 * a1[25] + v26 * a1[21] + v22 * a1[29] + a1[33];
  v10 = v26;
  v27 = v17;
  v23 = v22 * a1[30] + v24 * a1[26] + v10 * a1[22] + a1[34];
  v25 = v8;
  v16 = v9;
  v18 = v23 * a1[63] + v9 * a1[59] + v8 * a1[55] + v17 * a1[51];
  v20 = v27 * a1[52] + v23 * a1[64] + v9 * a1[60] + v8 * a1[56];
  v11 = v25 * a1[57] + v27 * a1[53] + v23 * a1[65] + v9 * a1[61];
  v12 = v16 * a1[62] + v25 * a1[58] + v27 * a1[54];
  v13 = v23 * a1[66];
  result = a5;
  v15 = 1.0 / (v12 + v13);
  v19 = v18 * v15;
  v21 = v20 * v15;
  *a5 = (v19 + 1.0) * a2 * 0.5;
  a5[1] = (v21 + 1.0) * a3 * 0.5;
  a5[2] = (v11 * v15 + v11 * v15) * 0.5;
  return result;
}

//----- (1000D800) --------------------------------------------------------
float *__cdecl sub_1000D800(float *a1, float a2, float a3, int a4, int a5, int a6, float *a7)
{
  float *result; // eax
  double v8; // st7
  long double v9; // st4
  int v10[3]; // [esp+8h] [ebp-18h] BYREF
  int v11[3]; // [esp+14h] [ebp-Ch] BYREF

  sub_1000D2F0(a1, (_DWORD *)a6);
  v10[0] = a4;
  v10[1] = a5;
  v10[2] = -1082130432;
  sub_1000D440(a1, a2, a3, (float *)v10, (float *)v11);
  result = a7;
  *a7 = *(float *)v11 - *(float *)a6;
  a7[1] = *(float *)&v11[1] - *(float *)(a6 + 4);
  v8 = *(float *)&v11[2] - *(float *)(a6 + 8);
  a7[2] = v8;
  v9 = sqrt(*result * *result + result[1] * result[1] + v8 * v8);
  *a7 = 1.0 / v9 * *a7;
  a7[1] = 1.0 / v9 * a7[1];
  a7[2] = 1.0 / v9 * a7[2];
  return result;
}
// 1002A170: using guessed type float flt_1002A170;

//----- (1000D8B0) --------------------------------------------------------
void __cdecl sub_1000D8B0(_DWORD *a1, float a2, float *a3, float *a4, int a5, float *a6)
{
  double v6; // st7
  double v7; // st6
  double v8; // st5
  double v9; // st7
  double v10; // st6
  long double v11; // st7
  long double v12; // st7
  float v13; // [esp+8h] [ebp-24h]
  float v14; // [esp+Ch] [ebp-20h]
  float v15; // [esp+10h] [ebp-1Ch]
  float v16; // [esp+14h] [ebp-18h] BYREF
  float v17; // [esp+18h] [ebp-14h]
  float v18; // [esp+1Ch] [ebp-10h]
  float v19[3]; // [esp+20h] [ebp-Ch] BYREF
  float v20; // [esp+34h] [ebp+8h]
  float v21; // [esp+40h] [ebp+14h]

  sub_1000D350(a1, (_DWORD *)a5);
  if ( LOBYTE(a2) )
  {
    sub_1000D2F0(a1, v19);
    sub_1000D380(a1, &v16);
    v13 = *a4 - v19[0];
    v14 = a4[1] - v19[1];
    v15 = a4[2] - v19[2];
    v6 = v18 * v14 - v17 * v15;
    v7 = v15 * v16 - v18 * v13;
    v8 = v17 * v13 - v14 * v16;
  }
  else
  {
    v6 = *(float *)a5;
    v7 = *(float *)(a5 + 4);
    v8 = *(float *)(a5 + 8);
  }
  v20 = v6 * a3[2] - v8 * *a3;
  v21 = v7 * *a3 - v6 * a3[1];
  v9 = v8 * a3[1];
  v10 = v7 * a3[2];
  a6[2] = v21;
  a6[1] = v20;
  *a6 = v9 - v10;
  v11 = sqrt(*a6 * *a6 + v21 * v21 + v20 * v20);
  if ( v11 <= 0.0000099999997 )
  {
    a6[2] = 0.0;
    a6[1] = 0.0;
    *a6 = 0.0;
  }
  else
  {
    v12 = 1.0 / v11;
    *a6 = v12 * *a6;
    a6[1] = v20 * v12;
    a6[2] = v21 * v12;
  }
}
// 1002A170: using guessed type float flt_1002A170;

//----- (1000DA00) --------------------------------------------------------
double __cdecl sub_1000DA00(int a1, int a2)
{
  double v2; // st7

  v2 = (double)a1 / (double)a2;
  if ( v2 <= 1.4 )
    return 1.33;
  if ( v2 <= 1.6 )
    return 1.5599999;
  return 1.78;
}

//----- (1000DA50) --------------------------------------------------------
int __cdecl sub_1000DA50(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v5; // ebx
  unsigned int v6; // ebp
  int v7; // eax
  unsigned int v8; // edi
  int v9; // ebx
  int result; // eax
  int v11; // ecx
  unsigned int v12; // eax
  unsigned int v13; // ecx
  int v14; // ebp
  unsigned int v15; // edx
  int v16; // ebp
  int v17; // ecx
  bool v18; // zf
  int v19; // ecx
  unsigned int v20; // edx
  unsigned int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // ebp
  unsigned int v25; // ecx
  unsigned int v26; // eax
  unsigned int v27; // edx
  int v28; // ebp
  int v29; // ecx
  int v30; // ecx
  unsigned int v31; // eax
  unsigned int v32; // ecx
  int v33; // ecx
  int v34; // ecx
  int v35; // edx
  unsigned int v36; // [esp+18h] [ebp+4h]
  unsigned int v37; // [esp+24h] [ebp+10h]

  v5 = *(_DWORD *)(a1 + 20);
  v6 = *(_DWORD *)(a1 + 24);
  v7 = *(_DWORD *)(a1 + 16) - v5 + 1;
  v36 = v6;
  v8 = (a3 + a2) * (unsigned __int64)(unsigned int)v7 / a4 + v5 - 1;
  v9 = a2 * (unsigned __int64)(unsigned int)v7 / a4 + v5;
  result = v8 ^ v9;
  if ( ((v8 ^ v9) & 0x40000000) != 0 )
    goto LABEL_38;
  result = 0;
  if ( v6 )
  {
    if ( (v8 & 0x40000000) != 0 )
      *(_DWORD *)(a1 + 8) |= 1 << *(_DWORD *)(a1 + 12);
    v11 = *(_DWORD *)(a1 + 12) + 1;
    *(_DWORD *)(a1 + 12) = v11;
    if ( v11 == 32 )
    {
      **(_DWORD **)a1 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)a1 += 4;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 8) = 0;
    }
    v12 = -((~v8 & 0x40000000) != 0);
    if ( v6 > 0x20 )
    {
      v37 = ((v6 - 33) >> 5) + 1;
      do
      {
        v13 = *(_DWORD *)(a1 + 12);
        v14 = *(_DWORD *)(a1 + 8);
        v15 = v12 << v13;
        v13 += 32;
        *(_DWORD *)(a1 + 12) = v13;
        v16 = v15 | v14;
        *(_DWORD *)(a1 + 8) = v16;
        if ( v13 >= 0x20 )
        {
          **(_DWORD **)a1 = v16;
          v17 = *(_DWORD *)(a1 + 12);
          v18 = v17 == 32;
          v19 = v17 - 32;
          *(_DWORD *)a1 += 4;
          *(_DWORD *)(a1 + 12) = v19;
          if ( v18 )
            *(_DWORD *)(a1 + 8) = 0;
          else
            *(_DWORD *)(a1 + 8) = v12 >> (32 - v19);
        }
        v6 = v36 - 32;
        v18 = v37 == 1;
        v36 -= 32;
        --v37;
      }
      while ( !v18 );
    }
    v20 = v12 & dword_1002A3A8[v6];
    v21 = v6 + *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 8) |= v20 << *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 12) = v21;
    if ( v21 >= 0x20 )
    {
      **(_DWORD **)a1 = *(_DWORD *)(a1 + 8);
      v22 = *(_DWORD *)(a1 + 12);
      v18 = v22 == 32;
      v23 = v22 - 32;
      *(_DWORD *)a1 += 4;
      *(_DWORD *)(a1 + 12) = v23;
      if ( v18 )
        *(_DWORD *)(a1 + 8) = 0;
      else
        *(_DWORD *)(a1 + 8) = v20 >> (v6 - v23);
    }
    v6 = 0;
    v9 *= 2;
    v8 = (2 * v8) | 1;
    v36 = 0;
    result = 0;
  }
  if ( ((v8 ^ v9) & 0x7F800000) == 0 )
  {
    do
    {
      v24 = *(_DWORD *)(a1 + 8);
      v25 = *(_DWORD *)(a1 + 12);
      v26 = (unsigned __int8)byte_1002A4B4[(v8 >> 27) & 0xF] | (16 * (byte_1002A4B4[(v8 >> 23) & 0xF] & 0xF));
      v27 = v26 << v25;
      v25 += 8;
      *(_DWORD *)(a1 + 12) = v25;
      v28 = v27 | v24;
      *(_DWORD *)(a1 + 8) = v28;
      if ( v25 >= 0x20 )
      {
        **(_DWORD **)a1 = v28;
        v29 = *(_DWORD *)(a1 + 12);
        v18 = v29 == 32;
        v30 = v29 - 32;
        *(_DWORD *)a1 += 4;
        *(_DWORD *)(a1 + 12) = v30;
        if ( v18 )
          *(_DWORD *)(a1 + 8) = 0;
        else
          *(_DWORD *)(a1 + 8) = v26 >> (8 - v30);
      }
      v9 <<= 8;
      v8 = (v8 << 8) | 0xFF;
    }
    while ( ((v8 ^ v9) & 0x7F800000) == 0 );
    v6 = v36;
    result = 0;
  }
  if ( ((v8 ^ v9) & 0x78000000) == 0 )
  {
    v31 = byte_1002A4B4[(v8 >> 27) & 0xF] & 0xF;
    *(_DWORD *)(a1 + 8) |= v31 << *(_DWORD *)(a1 + 12);
    v32 = *(_DWORD *)(a1 + 12) + 4;
    *(_DWORD *)(a1 + 12) = v32;
    if ( v32 >= 0x20 )
    {
      **(_DWORD **)a1 = *(_DWORD *)(a1 + 8);
      v33 = *(_DWORD *)(a1 + 12);
      v18 = v33 == 32;
      v34 = v33 - 32;
      *(_DWORD *)a1 += 4;
      *(_DWORD *)(a1 + 12) = v34;
      if ( v18 )
      {
        result = 0;
        *(_DWORD *)(a1 + 8) = 0;
        goto LABEL_31;
      }
      *(_DWORD *)(a1 + 8) = v31 >> (4 - v34);
    }
    result = 0;
LABEL_31:
    v9 *= 16;
    v8 = (16 * v8) | 0xF;
  }
  for ( ; ((v8 ^ v9) & 0x40000000) == 0; v8 = (2 * v8) | 1 )
  {
    if ( (v8 & 0x40000000) != 0 )
      *(_DWORD *)(a1 + 8) |= 1 << *(_DWORD *)(a1 + 12);
    v35 = *(_DWORD *)(a1 + 12) + 1;
    *(_DWORD *)(a1 + 12) = v35;
    if ( v35 == 32 )
    {
      **(_DWORD **)a1 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)a1 += 4;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 8) = 0;
    }
    v9 *= 2;
  }
LABEL_38:
  while ( (v9 & 0x20000000) != 0 )
  {
    if ( (v8 & 0x20000000) != 0 )
      break;
    v9 = 2 * (v9 & 0x1FFFFFFF);
    ++v6;
    v8 = (2 * v8) | 0x40000001;
  }
  *(_DWORD *)(a1 + 16) = v8 & 0x7FFFFFFF;
  *(_DWORD *)(a1 + 20) = v9 & 0x7FFFFFFF;
  *(_DWORD *)(a1 + 24) = v6;
  return result;
}
// 1002A3A8: using guessed type int dword_1002A3A8[6];

//----- (1000DD90) --------------------------------------------------------
int __cdecl sub_1000DD90(int a1, unsigned int a2, unsigned int a3)
{
  return sub_1000DA50(a1, a2, 1, a3);
}

//----- (1000DDC0) --------------------------------------------------------
int __cdecl sub_1000DDC0(int *a1, unsigned int a2, int a3, unsigned int a4)
{
  int v5; // ebp
  _DWORD *v6; // edi
  int v7; // ebx
  int v8; // edi
  int result; // eax
  unsigned int v10; // edx
  unsigned int v11; // eax
  _DWORD *v12; // edx
  int v13; // ebp
  int v14; // ecx
  int v15; // ecx
  int v16; // edx
  unsigned int v17; // edx
  int v18; // eax
  int v19; // eax
  int v20; // ecx
  _DWORD *v21; // edx
  int v22; // ecx
  int v23; // eax
  unsigned int v24; // eax
  _DWORD *v25; // edx
  int v26; // ebp
  int v27; // ecx
  unsigned int v28; // eax
  int v29; // [esp+10h] [ebp-4h]
  int v30; // [esp+18h] [ebp+4h]
  unsigned int v31; // [esp+24h] [ebp+10h]

  v5 = a1[6];
  v6 = (_DWORD *)a1[5];
  v29 = v5;
  v30 = a1[4] - (_DWORD)v6 + 1;
  v7 = (int)v6 + (a3 + a2) * (unsigned __int64)(unsigned int)v30 / a4 - 1;
  v8 = (int)v6 + a2 * (unsigned __int64)(unsigned int)v30 / a4;
  result = v7 ^ v8;
  if ( ((v7 ^ v8) & 0x40000000) == 0 )
  {
    if ( (result & 0x7F800000) == 0 )
    {
      do
      {
        v10 = a1[3];
        v8 <<= 8;
        v7 = (v7 << 8) | 0xFF;
        if ( v10 < 8 )
        {
          v13 = *(_DWORD *)*a1 >> (8 - v10);
          v11 = (unsigned __int8)(*((_BYTE *)a1 + 8) | (*(_BYTE *)*a1 << v10));
          v12 = (_DWORD *)(v10 + 24);
          v14 = *a1 + 4;
          a1[2] = v13;
          v5 = v29;
          *a1 = v14;
        }
        else
        {
          v11 = (unsigned __int8)a1[2];
          a1[2] = (unsigned int)a1[2] >> 8;
          v12 = (_DWORD *)(v10 - 8);
        }
        a1[3] = (int)v12;
        v15 = (unsigned __int8)byte_1002A4B4[v11 & 0xF];
        v16 = (unsigned __int8)byte_1002A4B4[v11 >> 4];
        result = v7 ^ v8;
        v5 = v16 | (16 * ((16 * v5) | v15));
        v29 = v5;
      }
      while ( ((v7 ^ v8) & 0x7F800000) == 0 );
    }
    if ( ((v7 ^ v8) & 0x78000000) == 0 )
    {
      v17 = a1[3];
      v8 *= 16;
      v7 = (16 * v7) | 0xF;
      if ( v17 < 4 )
      {
        v31 = *(_DWORD *)*a1;
        v19 = a1[2] | (v31 << v17);
        a1[3] += 28;
        v18 = v19 & 0xF;
        v20 = *a1 + 4;
        a1[2] = v31 >> (4 - v17);
        *a1 = v20;
      }
      else
      {
        v18 = a1[2] & 0xF;
        a1[2] = (unsigned int)a1[2] >> 4;
        a1[3] = v17 - 4;
      }
      result = (unsigned __int8)byte_1002A4B4[v18];
      v5 = result | (16 * v5);
    }
    for ( ; ((v7 ^ v8) & 0x40000000) == 0; result = v7 ^ v8 )
    {
      v21 = (_DWORD *)a1[3];
      v8 *= 2;
      v7 = (2 * v7) | 1;
      if ( v21 )
      {
        v22 = a1[2] & 1;
        a1[2] = (unsigned int)a1[2] >> 1;
        a1[3] = (int)v21 - 1;
        v23 = v22;
      }
      else
      {
        v24 = *(_DWORD *)*a1;
        *a1 += 4;
        a1[2] = v24 >> 1;
        a1[3] = 31;
        v23 = v24 & 1;
      }
      v5 = v23 | (2 * v5);
    }
  }
  for ( ; (v8 & 0x20000000) != 0; v5 = result | (2 * v26) )
  {
    if ( (v7 & 0x20000000) != 0 )
      break;
    v25 = (_DWORD *)a1[3];
    v26 = v5 ^ 0x20000000;
    v8 = 2 * (v8 & 0x1FFFFFFF);
    v7 = (2 * v7) | 0x40000001;
    if ( v25 )
    {
      v27 = a1[2] & 1;
      a1[2] = (unsigned int)a1[2] >> 1;
      a1[3] = (int)v25 - 1;
      result = v27;
    }
    else
    {
      v28 = *(_DWORD *)*a1;
      *a1 += 4;
      a1[2] = v28 >> 1;
      a1[3] = 31;
      result = v28 & 1;
    }
  }
  a1[5] = v8 & 0x7FFFFFFF;
  a1[4] = v7 & 0x7FFFFFFF;
  a1[6] = v5 & 0x7FFFFFFF;
  return result;
}

//----- (1000E020) --------------------------------------------------------
unsigned int __cdecl sub_1000E020(int *a1, unsigned int a2)
{
  unsigned int v2; // edi

  v2 = (a2 * (unsigned __int64)(unsigned int)(a1[6] - a1[5] + 1) - 1) / (unsigned int)(a1[4] - a1[5] + 1);
  sub_1000DDC0(a1, v2, 1, a2);
  return v2;
}

//----- (1000E070) --------------------------------------------------------
unsigned int __cdecl sub_1000E070(int a1, int a2)
{
  return 2 * (((a2 + 5) & 0xFFFFFFFC) + ((a1 + 5) & 0xFFFFFFFC)) + 56;
}

//----- (1000E090) --------------------------------------------------------
unsigned int __cdecl sub_1000E090(int a1)
{
  return 4 * ((a1 + 5) & 0xFFFFFFFC) + 56;
}

//----- (1000E0B0) --------------------------------------------------------
unsigned int __cdecl sub_1000E0B0(int a1)
{
  return 2 * ((a1 + 5) & 0xFFFFFFFC);
}

//----- (1000E0C0) --------------------------------------------------------
int __cdecl sub_1000E0C0(int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax

  if ( a1 )
  {
    if ( a2 )
      v4 = sub_1000E070(a3, a4);
    else
      v4 = sub_1000E090(a4);
    sub_10019D80(a2, v4, 0, (char *)a1);
    *(_WORD *)(a1 + 44) = a4;
    *(_DWORD *)(a1 + 48) = a1 + 2 * ((a4 + 5) & 0xFFFFFFFC) + 56;
    *(_DWORD *)(a1 + 52) = a2;
    sub_1000E130((_WORD *)a1, a4 + 1);
    sub_1000E1C0(a1, 0, 196611);
  }
  return a1;
}

//----- (1000E130) --------------------------------------------------------
int __cdecl sub_1000E130(_WORD *a1, unsigned int a2)
{
  int result; // eax
  __int16 v3; // bx
  unsigned int v4; // ebp
  unsigned int i; // ecx
  unsigned int v6; // esi
  unsigned int v7; // eax
  unsigned int v8; // eax

  if ( a2 >= 6 )
  {
    v3 = (__int16)a1;
    v4 = -1;
    for ( i = 0; i < 0x10; ++i )
    {
      v6 = 1 << i;
      v7 = ((1 << i) + a2 - 1) / (1 << i);
      if ( v7 > 0x10 )
        v7 = 16;
      v8 = a2 - v6 * (v7 - 1);
      if ( v8 < v6 )
        v8 = 1 << i;
      if ( v8 < v4 )
      {
        v3 = i;
        v4 = v8;
      }
      if ( v6 > a2 )
        break;
    }
    a1[20] = 1 << v3;
    result = 15 * (1 << v3);
    a1[19] = v3;
    a1[18] = result;
  }
  else
  {
    result = (int)a1;
    a1[20] = 0;
    a1[19] = 15;
    a1[18] = 0;
  }
  return result;
}

//----- (1000E1C0) --------------------------------------------------------
int __cdecl sub_1000E1C0(int a1, unsigned int a2, int a3)
{
  int result; // eax
  unsigned int v4; // edx

  result = a1;
  if ( a2 < *(unsigned __int16 *)(a1 + 36) )
  {
    v4 = a2 >> *(_BYTE *)(a1 + 38);
    if ( (v4 & 1) != 0 )
      *(_WORD *)(a1 + 2 * v4++) += a3;
    switch ( v4 >> 1 )
    {
      case 0u:
        *(_DWORD *)a1 += a3;
        goto LABEL_7;
      case 1u:
LABEL_7:
        *(_DWORD *)(a1 + 4) += a3;
        goto LABEL_8;
      case 2u:
LABEL_8:
        *(_DWORD *)(a1 + 8) += a3;
        goto LABEL_9;
      case 3u:
LABEL_9:
        *(_DWORD *)(a1 + 12) += a3;
        goto LABEL_10;
      case 4u:
LABEL_10:
        *(_DWORD *)(a1 + 16) += a3;
        goto LABEL_11;
      case 5u:
LABEL_11:
        *(_DWORD *)(a1 + 20) += a3;
        goto LABEL_12;
      case 6u:
LABEL_12:
        *(_DWORD *)(a1 + 24) += a3;
        goto LABEL_13;
      case 7u:
LABEL_13:
        *(_DWORD *)(a1 + 28) += a3;
        break;
      default:
        break;
    }
    *(_WORD *)(a1 + 2 * a2 + 56) += a3;
  }
  else
  {
    *(_WORD *)(a1 + 30) += a3;
    *(_WORD *)(a1 + 2 * a2 + 56) += a3;
  }
  return result;
}

//----- (1000E250) --------------------------------------------------------
int __cdecl sub_1000E250(int a1)
{
  unsigned __int16 v1; // cx

  v1 = *(_WORD *)(a1 + 32);
  if ( v1 > *(_WORD *)(a1 + 42) )
    *(_WORD *)(a1 + 42) = v1;
  return *(unsigned __int16 *)(a1 + 42);
}

//----- (1000E270) --------------------------------------------------------
int __usercall sub_1000E270@<eax>(int a1@<ebx>, int a2, int a3, int a4)
{
  unsigned int v4; // edi
  unsigned int v5; // eax

  if ( *(_WORD *)(a2 + 30) >= 0x4000u )
    sub_1000E3E0(a1, a2);
  v4 = *(unsigned __int16 *)(*(_DWORD *)(a2 + 48) + 2 * a4);
  LOWORD(v5) = sub_1000E320(a2, v4);
  sub_1000DA40(a3, v5, *(unsigned __int16 *)(a2 + 2 * v4 + 56), *(unsigned __int16 *)(a2 + 30) - 1);
  ++*(_WORD *)(a2 + 2 * v4 + 56);
  if ( v4 )
    return a4;
  *(_WORD *)(*(_DWORD *)(a2 + 48) + 2 * a4) = ++*(_WORD *)(a2 + 32);
  sub_1000E1C0(a2, *(unsigned __int16 *)(a2 + 32), 131074);
  if ( *(_WORD *)(a2 + 32) == *(_WORD *)(a2 + 44) )
    sub_1000E1C0(a2, 0, (unsigned __int16)-*(_WORD *)(a2 + 56) | ((-*(unsigned __int16 *)(a2 + 56) - 1) << 16));
  return 0x20000;
}
// 1000E2B2: variable 'v5' is possibly undefined

//----- (1000E320) --------------------------------------------------------
__int16 __cdecl sub_1000E320(int a1, unsigned int a2)
{
  __int16 result; // ax
  unsigned int v3; // esi
  __int16 *v4; // ecx
  unsigned int v5; // edi
  __int16 v6; // dx
  __int16 v7; // cx
  unsigned int v8; // ebx

  if ( a2 >= *(unsigned __int16 *)(a1 + 40) )
  {
    v3 = *(unsigned __int16 *)(a1 + 36);
    if ( a2 < (unsigned __int16)v3 )
    {
      v7 = *(_WORD *)(a1 + 38);
      v8 = a2 >> v7;
      result = *(_WORD *)(a1 + 2 * (a2 >> v7) - 2);
      v3 = a2 >> v7 << v7;
      if ( ((a2 >> v7) & 1) != 0 )
        ++*(_WORD *)(a1 + 2 * v8++);
      switch ( v8 >> 1 )
      {
        case 0u:
          goto LABEL_3;
        case 1u:
          goto LABEL_4;
        case 2u:
          goto LABEL_5;
        case 3u:
          goto LABEL_6;
        case 4u:
          goto LABEL_7;
        case 5u:
          goto LABEL_8;
        case 6u:
          goto LABEL_9;
        case 7u:
          goto LABEL_10;
        default:
          break;
      }
    }
    else
    {
      result = *(_WORD *)(a1 + 28);
      ++*(_WORD *)(a1 + 30);
    }
  }
  else
  {
    result = 0;
    v3 = 0;
LABEL_3:
    *(_DWORD *)a1 += 65537;
LABEL_4:
    *(_DWORD *)(a1 + 4) += 65537;
LABEL_5:
    *(_DWORD *)(a1 + 8) += 65537;
LABEL_6:
    *(_DWORD *)(a1 + 12) += 65537;
LABEL_7:
    *(_DWORD *)(a1 + 16) += 65537;
LABEL_8:
    *(_DWORD *)(a1 + 20) += 65537;
LABEL_9:
    *(_DWORD *)(a1 + 24) += 65537;
LABEL_10:
    *(_DWORD *)(a1 + 28) += 65537;
  }
  if ( v3 < a2 )
  {
    v4 = (__int16 *)(a1 + 2 * v3 + 56);
    v5 = a2 - v3;
    do
    {
      v6 = *v4++;
      result += v6;
      --v5;
    }
    while ( v5 );
  }
  return result;
}

//----- (1000E3E0) --------------------------------------------------------
unsigned int __usercall sub_1000E3E0@<eax>(int a1@<ebx>, int a2)
{
  unsigned __int16 v3; // ax
  int v4; // ecx
  int v5; // eax
  int v6; // edi
  _WORD *i; // edx
  unsigned int v8; // edi
  _WORD *v9; // eax
  int v10; // ecx
  char *v11; // ecx
  unsigned int v12; // edx
  int v13; // ebx
  unsigned int v14; // ebp
  unsigned __int16 v15; // dx
  unsigned int v16; // edx
  unsigned __int16 v17; // di
  unsigned __int16 v18; // bx
  unsigned int v19; // ebp
  int v20; // eax
  int v21; // ebp
  int v22; // ecx
  int v23; // edi
  __int16 *v24; // edx
  __int16 v25; // ax
  unsigned int v27; // [esp+10h] [ebp-48h]
  _DWORD v28[16]; // [esp+18h] [ebp-40h] BYREF
  unsigned int v29; // [esp+5Ch] [ebp+4h]

  v3 = *(_WORD *)(a2 + 32);
  if ( v3 > *(_WORD *)(a2 + 42) )
    *(_WORD *)(a2 + 42) = v3;
  sub_1000E130((_WORD *)a2, v3 + 1);
  sub_10019D80(a1, 0x40u, 0, (char *)v28);
  *(_WORD *)(a2 + 56) >>= 1;
  v4 = *(unsigned __int16 *)(a2 + 32);
  v28[*(_WORD *)(a2 + 36) != 0 ? 0 : 15] = *(unsigned __int16 *)(a2 + 56);
  v5 = 0;
  v29 = 0;
  if ( (_WORD)v4 )
  {
    do
    {
      v6 = *(_DWORD *)(a2 + 48);
      for ( i = (_WORD *)(v6 + 2 * v5); !*i; ++v5 )
        ++i;
      *(_WORD *)(*(_DWORD *)(a2 + 52) + 2 * *(unsigned __int16 *)(v6 + 2 * v5)) = v5;
      ++v5;
      --v4;
    }
    while ( v4 );
  }
  v8 = 1;
  if ( *(_WORD *)(a2 + 32) )
  {
    v9 = (_WORD *)(a2 + 58);
    while ( *v9 > 1u )
    {
LABEL_12:
      *v9 >>= 1;
      v12 = (unsigned __int16)*v9;
      if ( v12 > v29 )
      {
        v29 = (unsigned __int16)*v9;
        v27 = v8;
      }
      if ( v8 >= *(unsigned __int16 *)(a2 + 36) )
        v13 = 15;
      else
        v13 = v8 >> *(_BYTE *)(a2 + 38);
      v14 = v12 + v28[v13];
      v15 = *(_WORD *)(a2 + 32);
      ++v8;
      ++v9;
      v28[v13] = v14;
      if ( v8 > v15 )
        goto LABEL_20;
    }
    while ( 1 )
    {
      v10 = *(unsigned __int16 *)(a2 + 32);
      if ( v8 >= (unsigned __int16)v10 )
        break;
      *v9 = *(_WORD *)(a2 + 2 * v10 + 56);
      v11 = (char *)v9 - 56 - a2;
      *(_WORD *)(a2 + 2 * *(unsigned __int16 *)(a2 + 32) + 56) = 0;
      *(_WORD *)(*(_DWORD *)(a2 + 48) + 2 * *(unsigned __int16 *)&v11[*(_DWORD *)(a2 + 52)]) = 0;
      *(_WORD *)(*(_DWORD *)(a2 + 48)
               + 2 * *(unsigned __int16 *)(*(_DWORD *)(a2 + 52) + 2 * *(unsigned __int16 *)(a2 + 32))) = v8;
      *(_WORD *)&v11[*(_DWORD *)(a2 + 52)] = *(_WORD *)(*(_DWORD *)(a2 + 52)
                                                      + 2 * (unsigned __int16)(*(_WORD *)(a2 + 32))--);
      if ( *v9 > 1u )
        goto LABEL_12;
    }
    *(_WORD *)(a2 + 2 * v8 + 56) = 0;
    *(_WORD *)(*(_DWORD *)(a2 + 48) + 2 * *(unsigned __int16 *)(*(_DWORD *)(a2 + 52) + 2 * v8)) = 0;
    --*(_WORD *)(a2 + 32);
LABEL_20:
    if ( v29 )
    {
      if ( *(_WORD *)(a2 + 32) >= *(_WORD *)(a2 + 36) )
        v16 = *(unsigned __int16 *)(a2 + 36);
      else
        v16 = *(unsigned __int16 *)(a2 + 32) >> *(_WORD *)(a2 + 38) << *(_WORD *)(a2 + 38);
      if ( !v16 )
        v16 = 1;
      if ( v27 != v16 )
      {
        v17 = *(_WORD *)(a2 + 2 * v27 + 56);
        v18 = *(_WORD *)(a2 + 2 * v16 + 56);
        HIWORD(v19) = 0;
        *(_WORD *)(a2 + 2 * v16 + 56) = v17;
        LOWORD(v19) = *(_WORD *)(a2 + 36);
        if ( v16 >= (unsigned __int16)v19 )
          v20 = 15;
        else
          v20 = v16 >> *(_BYTE *)(a2 + 38);
        v28[v20] += v17 - v18;
        if ( v27 >= v19 )
          v21 = 15;
        else
          v21 = v27 >> *(_BYTE *)(a2 + 38);
        v28[v21] += v18 - *(unsigned __int16 *)(a2 + 2 * v16 + 56);
        *(_WORD *)(a2 + 2 * v27 + 56) = v18;
        v22 = *(_DWORD *)(a2 + 52);
        v23 = *(_DWORD *)(a2 + 48);
        v24 = (__int16 *)(v23 + 2 * *(unsigned __int16 *)(v22 + 2 * v16));
        v25 = *v24;
        *v24 = *(_WORD *)(v23 + 2 * *(unsigned __int16 *)(v22 + 2 * v27));
        *(_WORD *)(*(_DWORD *)(a2 + 48) + 2 * *(unsigned __int16 *)(*(_DWORD *)(a2 + 52) + 2 * v27)) = v25;
      }
    }
  }
  **(_WORD **)(a2 + 52) = 0;
  return sub_1000E690((_WORD *)a2, v28);
}
// 1000E5C6: variable 'v27' is possibly undefined

//----- (1000E690) --------------------------------------------------------
unsigned int __cdecl sub_1000E690(_WORD *a1, _WORD *a2)
{
  bool v2; // cf
  unsigned int result; // eax
  __int16 v4; // si

  if ( a1[16] != a1[22] && !a1[28] )
  {
    v2 = a1[18] != 0;
    a1[28] = 2;
    *(_DWORD *)&a2[2 * (v2 ? 0 : 15)] += 2;
  }
  *a1 = *a2;
  for ( result = 1; result < 0x10; a1[result - 1] = v4 )
  {
    v4 = a2[2 * result] + a1[result - 1];
    ++result;
  }
  return result;
}

//----- (1000E6F0) --------------------------------------------------------
int __usercall sub_1000E6F0@<eax>(int a1@<ebx>, unsigned int a2, int a3)
{
  int v3; // esi
  int *v4; // ebx
  int v5; // eax
  unsigned __int16 v6; // dx
  int v7; // eax
  int v8; // edi

  v3 = a2;
  if ( *(_WORD *)(a2 + 30) >= 0x4000u )
    sub_1000EC30(a1, a2);
  v4 = (int *)a3;
  v5 = *(_DWORD *)(a3 + 20);
  v6 = *(_WORD *)(v3 + 30);
  a3 = *(_DWORD *)(a3 + 16) - v5 + 1;
  LOWORD(v7) = sub_1000E7F0(
                 (unsigned __int16 *)v3,
                 (v6 * (unsigned __int64)(unsigned int)(v4[6] - v5 + 1) - 1) / (unsigned int)a3,
                 &a2);
  v8 = v7;
  sub_1000DDB0(v4, a2, *(unsigned __int16 *)(v3 + 2 * v7 + 56), *(unsigned __int16 *)(v3 + 30) - 1);
  ++*(_WORD *)(v3 + 2 * v8 + 56);
  if ( v8 )
    return *(unsigned __int16 *)(*(_DWORD *)(v3 + 48) + 2 * v8);
  sub_1000E1C0(v3, (unsigned __int16)++*(_WORD *)(v3 + 32), 131074);
  if ( *(_WORD *)(v3 + 32) == *(_WORD *)(v3 + 44) )
    sub_1000E1C0(v3, 0, (unsigned __int16)-*(_WORD *)(v3 + 56) | ((-*(unsigned __int16 *)(v3 + 56) - 1) << 16));
  return *(_DWORD *)(v3 + 48) + 2 * *(unsigned __int16 *)(v3 + 32);
}
// 1000E756: variable 'v7' is possibly undefined

//----- (1000E7F0) --------------------------------------------------------
__int16 __cdecl sub_1000E7F0(unsigned __int16 *a1, unsigned int a2, unsigned int *a3)
{
  unsigned __int16 v4; // bp
  unsigned __int16 v5; // ax
  unsigned __int16 v6; // cx
  unsigned int v7; // esi
  int v8; // eax
  unsigned __int16 v9; // di
  char v10; // cl
  int v11; // ecx
  int v12; // ecx
  unsigned __int16 v13; // ax
  unsigned __int16 v14; // di
  char v15; // cl
  int v16; // ecx
  unsigned int v17; // edi
  unsigned __int16 v18; // di
  char v19; // cl
  int v20; // ecx
  unsigned __int16 *i; // edx
  unsigned int v22; // ecx
  unsigned __int16 v23; // si
  unsigned __int16 *v24; // edx
  unsigned __int16 v26; // [esp+14h] [ebp+4h]
  unsigned __int16 v27; // [esp+14h] [ebp+4h]

  v4 = a1[7];
  if ( (unsigned __int16)a2 >= v4 )
  {
    v13 = a1[11];
    v27 = v13;
    if ( (unsigned __int16)a2 >= v13 )
    {
      v18 = a1[13];
      if ( (unsigned __int16)a2 >= v18 )
      {
        if ( (unsigned __int16)a2 >= a1[14] )
        {
          v8 = a1[18];
          v7 = a1[14];
          ++a1[15];
        }
        else
        {
          v8 = 14 << *((_BYTE *)a1 + 38);
          v7 = a1[13];
          *((_DWORD *)a1 + 7) += 65537;
        }
      }
      else
      {
        v19 = *((_BYTE *)a1 + 38);
        if ( (unsigned __int16)a2 >= a1[12] )
        {
          v8 = 13 << v19;
          v7 = a1[12];
          v20 = *((_DWORD *)a1 + 7) + 65537;
          a1[13] = v18 + 1;
        }
        else
        {
          v7 = v13;
          v8 = 12 << v19;
          *((_DWORD *)a1 + 6) += 65537;
          v20 = *((_DWORD *)a1 + 7) + 65537;
        }
        *((_DWORD *)a1 + 7) = v20;
      }
    }
    else
    {
      v14 = a1[9];
      v15 = *((_BYTE *)a1 + 38);
      if ( (unsigned __int16)a2 >= v14 )
      {
        if ( (unsigned __int16)a2 >= a1[10] )
        {
          v8 = 11 << v15;
          v7 = a1[10];
          a1[11] = v27 + 1;
          *((_DWORD *)a1 + 6) += 65537;
        }
        else
        {
          v17 = a1[9];
          v8 = 10 << v15;
          *((_DWORD *)a1 + 5) += 65537;
          *((_DWORD *)a1 + 6) += 65537;
          v7 = v17;
        }
        *((_DWORD *)a1 + 7) += 65537;
      }
      else
      {
        LOWORD(v7) = a1[8];
        if ( (unsigned __int16)a2 >= (unsigned __int16)v7 )
        {
          v8 = 9 << v15;
          *((_DWORD *)a1 + 5) += 65537;
          *((_DWORD *)a1 + 6) += 65537;
          v7 = (unsigned __int16)v7;
          v16 = *((_DWORD *)a1 + 7) + 65537;
          a1[9] = v14 + 1;
        }
        else
        {
          v8 = 8 << v15;
          *((_DWORD *)a1 + 4) += 65537;
          *((_DWORD *)a1 + 5) += 65537;
          *((_DWORD *)a1 + 6) += 65537;
          v16 = *((_DWORD *)a1 + 7) + 65537;
          v7 = v4;
        }
        *((_DWORD *)a1 + 7) = v16;
      }
    }
  }
  else
  {
    v5 = a1[3];
    v26 = v5;
    if ( (unsigned __int16)a2 >= v5 )
    {
      v9 = a1[5];
      v10 = *((_BYTE *)a1 + 38);
      if ( (unsigned __int16)a2 >= v9 )
      {
        LOWORD(v7) = a1[6];
        if ( (unsigned __int16)a2 >= (unsigned __int16)v7 )
        {
          v8 = 7 << v10;
          *((_DWORD *)a1 + 4) += 65537;
          *((_DWORD *)a1 + 5) += 65537;
          *((_DWORD *)a1 + 6) += 65537;
          v7 = (unsigned __int16)v7;
          v12 = *((_DWORD *)a1 + 7) + 65537;
          a1[7] = v4 + 1;
        }
        else
        {
          v8 = 6 << v10;
          *((_DWORD *)a1 + 3) += 65537;
          *((_DWORD *)a1 + 4) += 65537;
          *((_DWORD *)a1 + 5) += 65537;
          *((_DWORD *)a1 + 6) += 65537;
          v12 = *((_DWORD *)a1 + 7) + 65537;
          v7 = v9;
        }
        *((_DWORD *)a1 + 7) = v12;
      }
      else
      {
        LOWORD(v7) = a1[4];
        if ( (unsigned __int16)a2 >= (unsigned __int16)v7 )
        {
          v8 = 5 << v10;
          *((_DWORD *)a1 + 3) += 65537;
          *((_DWORD *)a1 + 4) += 65537;
          *((_DWORD *)a1 + 5) += 65537;
          *((_DWORD *)a1 + 6) += 65537;
          v7 = (unsigned __int16)v7;
          v11 = *((_DWORD *)a1 + 7) + 65537;
          a1[5] = v9 + 1;
        }
        else
        {
          v7 = v5;
          v8 = 4 << v10;
          *((_DWORD *)a1 + 2) += 65537;
          *((_DWORD *)a1 + 3) += 65537;
          *((_DWORD *)a1 + 4) += 65537;
          *((_DWORD *)a1 + 5) += 65537;
          *((_DWORD *)a1 + 6) += 65537;
          v11 = *((_DWORD *)a1 + 7) + 65537;
        }
        *((_DWORD *)a1 + 7) = v11;
      }
    }
    else
    {
      v6 = a1[1];
      if ( (unsigned __int16)a2 >= v6 )
      {
        if ( (unsigned __int16)a2 >= a1[2] )
        {
          v8 = 3 << *((_BYTE *)a1 + 38);
          v7 = a1[2];
          a1[3] = v26 + 1;
        }
        else
        {
          v7 = a1[1];
          v8 = 2 << *((_BYTE *)a1 + 38);
          *((_DWORD *)a1 + 1) += 65537;
        }
        *((_DWORD *)a1 + 2) += 65537;
        *((_DWORD *)a1 + 3) += 65537;
        *((_DWORD *)a1 + 4) += 65537;
        *((_DWORD *)a1 + 5) += 65537;
        *((_DWORD *)a1 + 6) += 65537;
        *((_DWORD *)a1 + 7) += 65537;
      }
      else
      {
        if ( (unsigned __int16)a2 >= *a1 )
        {
          HIWORD(v8) = 0;
          v7 = *a1;
          a1[1] = v6 + 1;
          *((_DWORD *)a1 + 1) += 65537;
          *((_DWORD *)a1 + 2) += 65537;
          LOWORD(v8) = a1[20];
          *((_DWORD *)a1 + 3) += 65537;
          *((_DWORD *)a1 + 4) += 65537;
          *((_DWORD *)a1 + 5) += 65537;
          *((_DWORD *)a1 + 6) += 65537;
        }
        else
        {
          *(_DWORD *)a1 += 65537;
          *((_DWORD *)a1 + 1) += 65537;
          *((_DWORD *)a1 + 2) += 65537;
          *((_DWORD *)a1 + 3) += 65537;
          *((_DWORD *)a1 + 4) += 65537;
          *((_DWORD *)a1 + 5) += 65537;
          *((_DWORD *)a1 + 6) += 65537;
          v7 = 0;
          v8 = 0;
        }
        *((_DWORD *)a1 + 7) += 65537;
      }
    }
  }
  for ( i = &a1[v8 + 28]; ; i = v24 + 1 )
  {
    v22 = v7 + *i;
    if ( a2 < v22 )
    {
      *a3 = v7;
      return v8;
    }
    v23 = i[1];
    v24 = i + 1;
    ++v8;
    v7 = v22 + v23;
    if ( a2 < v7 )
      break;
    ++v8;
  }
  *a3 = v22;
  return v8;
}

//----- (1000EC30) --------------------------------------------------------
unsigned int __usercall sub_1000EC30@<eax>(int a1@<ebx>, unsigned int a2)
{
  _WORD *v2; // esi
  unsigned int v3; // edx
  bool v4; // cf
  _WORD *v5; // eax
  int v6; // ecx
  unsigned int v7; // edi
  int v8; // ebx
  unsigned int v9; // eax
  unsigned __int16 v10; // di
  unsigned __int16 v11; // bx
  unsigned int v12; // ebp
  int v13; // edx
  int v14; // ebp
  int v15; // ecx
  __int16 v16; // dx
  unsigned int v18; // [esp+10h] [ebp-44h]
  _DWORD v19[16]; // [esp+14h] [ebp-40h] BYREF

  v2 = (_WORD *)a2;
  v18 = 0;
  sub_1000E130((_WORD *)a2, *(unsigned __int16 *)(a2 + 32) + 1);
  sub_10019D80(a1, 0x40u, 0, (char *)v19);
  *(_WORD *)(a2 + 56) >>= 1;
  v3 = 1;
  v4 = *(_WORD *)(a2 + 32) == 0;
  v19[*(_WORD *)(a2 + 36) != 0 ? 0 : 15] = *(unsigned __int16 *)(a2 + 56);
  if ( !v4 )
  {
    v5 = (_WORD *)(a2 + 58);
    while ( *v5 > 1u )
    {
LABEL_6:
      *v5 >>= 1;
      v7 = (unsigned __int16)*v5;
      if ( v7 > v18 )
      {
        v18 = (unsigned __int16)*v5;
        a2 = v3;
      }
      if ( v3 >= (unsigned __int16)v2[18] )
        v8 = 15;
      else
        v8 = v3 >> *((_BYTE *)v2 + 38);
      v19[v8] += v7;
      ++v3;
      ++v5;
      if ( v3 > (unsigned __int16)v2[16] )
        goto LABEL_14;
    }
    while ( 1 )
    {
      v6 = (unsigned __int16)v2[16];
      if ( v3 >= (unsigned __int16)v6 )
        break;
      *v5 = v2[v6 + 28];
      v2[(unsigned __int16)v2[16] + 28] = 0;
      *(_WORD *)((char *)v5 + *((_DWORD *)v2 + 12) - (_DWORD)v2 - 56) = *(_WORD *)(*((_DWORD *)v2 + 12)
                                                                                 + 2 * (unsigned __int16)v2[16]--);
      if ( *v5 > 1u )
        goto LABEL_6;
    }
    v2[v3 + 28] = 0;
    --v2[16];
LABEL_14:
    if ( v18 )
    {
      if ( v2[16] >= v2[18] )
        v9 = (unsigned __int16)v2[18];
      else
        v9 = (unsigned __int16)v2[16] >> v2[19] << v2[19];
      if ( !v9 )
        v9 = 1;
      if ( a2 != v9 )
      {
        v10 = v2[a2 + 28];
        v11 = v2[v9 + 28];
        HIWORD(v12) = 0;
        v2[v9 + 28] = v10;
        LOWORD(v12) = v2[18];
        if ( v9 >= (unsigned __int16)v12 )
          v13 = 15;
        else
          v13 = v9 >> *((_BYTE *)v2 + 38);
        v19[v13] += v10 - v11;
        if ( a2 >= v12 )
          v14 = 15;
        else
          v14 = a2 >> *((_BYTE *)v2 + 38);
        v19[v14] += v11 - (unsigned __int16)v2[v9 + 28];
        v2[a2 + 28] = v11;
        v15 = *((_DWORD *)v2 + 12);
        v16 = *(_WORD *)(v15 + 2 * v9);
        *(_WORD *)(v15 + 2 * v9) = *(_WORD *)(v15 + 2 * a2);
        *(_WORD *)(*((_DWORD *)v2 + 12) + 2 * a2) = v16;
      }
    }
  }
  return sub_1000E690(v2, v19);
}

//----- (1000EE30) --------------------------------------------------------
int __cdecl sub_1000EE30(int a1, int a2, int a3)
{
  int result; // eax
  unsigned int v4; // ecx

  result = *(_DWORD *)(a1 + 48);
  v4 = *(unsigned __int16 *)(result + 2 * a2);
  if ( (_WORD)v4 )
  {
    if ( a3 < 0 )
      return sub_1000E1C0(a1, v4, (unsigned __int16)a3 | ((a3 - 1) << 16));
    else
      return sub_1000E1C0(a1, v4, a3 | (a3 << 16));
  }
  return result;
}

//----- (1000EE80) --------------------------------------------------------
double __cdecl sub_1000EE80(int a1, int a2, unsigned int a3)
{
  int v3; // eax
  long double v4; // st7

  v3 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 48) + 2 * a2);
  if ( (_WORD)v3 )
    v4 = __FYL2X__(
           (double)(*(unsigned __int16 *)(a1 + 2 * v3 + 56) + 1) / (double)(*(unsigned __int16 *)(a1 + 30) + 1),
           1.0);
  else
    v4 = __FYL2X__(1.0 / (double)a3, 1.0);
  return -v4;
}

//----- (1000EF40) --------------------------------------------------------
int sub_1000EF40()
{
  int result; // eax

  result = 2139095040;
  flt_10036110 = INFINITY;
  return result;
}
// 10036110: using guessed type float flt_10036110;

//----- (1000EF60) --------------------------------------------------------
int sub_1000EF60()
{
  int result; // eax

  result = -4194304;
  dword_10036114 = -4194304;
  return result;
}
// 10036114: using guessed type int dword_10036114;

//----- (1000EF80) --------------------------------------------------------
int sub_1000EF80()
{
  int result; // eax

  result = -8388608;
  dword_10036128 = -8388608;
  return result;
}
// 10036128: using guessed type int dword_10036128;

//----- (1000EFA0) --------------------------------------------------------
int sub_1000EFA0()
{
  int result; // eax

  result = 0;
  dword_10036120 = 0;
  dword_10036124 = 2146435072;
  return result;
}
// 10036120: using guessed type int dword_10036120;
// 10036124: using guessed type int dword_10036124;

//----- (1000EFD0) --------------------------------------------------------
int sub_1000EFD0()
{
  int result; // eax

  result = 0;
  dword_10036118 = 0;
  dword_1003611C = -524288;
  return result;
}
// 10036118: using guessed type int dword_10036118;
// 1003611C: using guessed type int dword_1003611C;

//----- (1000F000) --------------------------------------------------------
int sub_1000F000()
{
  int result; // eax

  result = 0;
  dword_10036108 = 0;
  dword_1003610C = -1048576;
  return result;
}
// 10036108: using guessed type int dword_10036108;
// 1003610C: using guessed type int dword_1003610C;

//----- (1000F020) --------------------------------------------------------
int __cdecl sub_1000F020(int a1)
{
  return a1;
}

//----- (1000F030) --------------------------------------------------------
_DWORD *__cdecl sub_1000F030(int a1, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  void *v4; // eax
  int v5; // ecx

  v2 = sub_10014D00(dword_1003102C);
  v3 = v2;
  if ( v2 )
  {
    sub_10001EC0(v2);
    v3[8] = a1;
    v3[9] = 0;
    v3[10] = 1065353216;
    v3[11] = a2;
    v3[12] = 0;
    v3[13] = 1;
    *((_BYTE *)v3 + 56) = 0;
    v3[15] = 0;
    *((_BYTE *)v3 + 64) = 0;
    *((_BYTE *)v3 + 65) = 1;
    v3[17] = 1065353216;
    *((_BYTE *)v3 + 72) = 0;
    *((_BYTE *)v3 + 100) = 0;
    v3[36] = *((_DWORD *)sub_1000F0D0() + 36);
    v4 = sub_1000F0D0();
    v5 = v3[36];
    v3[37] = v4;
    *(_DWORD *)(v5 + 148) = v3;
    *(_DWORD *)(v3[37] + 144) = v3;
  }
  return v3;
}
// 1003102C: using guessed type _DWORD dword_1003102C[7];

//----- (1000F0D0) --------------------------------------------------------
void *sub_1000F0D0()
{
  void *result; // eax

  result = &unk_10036130;
  if ( !dword_100361C0 )
  {
    dword_100361C4 = (int)&unk_10036130;
    dword_100361C0 = (int)&unk_10036130;
  }
  return result;
}
// 100361C0: using guessed type int dword_100361C0;
// 100361C4: using guessed type int dword_100361C4;

//----- (1000F0F0) --------------------------------------------------------
void __cdecl sub_1000F0F0(unsigned int a1)
{
  int v1; // ecx
  int v2; // eax

  if ( a1 )
  {
    v1 = *(_DWORD *)(a1 + 148);
    *(_BYTE *)(a1 + 65) = 0;
    *(_BYTE *)(a1 + 56) = 0;
    *(_BYTE *)(a1 + 64) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 144) + 148) = v1;
    *(_DWORD *)(*(_DWORD *)(a1 + 148) + 144) = *(_DWORD *)(a1 + 144);
    v2 = sub_1000F020(a1);
    sub_100020A0(v2);
    sub_10014E60(dword_1003102C, a1);
  }
}
// 1003102C: using guessed type _DWORD dword_1003102C[7];

//----- (1000F150) --------------------------------------------------------
char __cdecl sub_1000F150(int a1)
{
  *(_BYTE *)(a1 + 64) = 1;
  return sub_1000F3D0(a1);
}

//----- (1000F170) --------------------------------------------------------
int __cdecl sub_1000F170(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 56) = 1;
  *(_DWORD *)(a1 + 60) = a2;
  return result;
}

//----- (1000F180) --------------------------------------------------------
double __cdecl sub_1000F180(int a1)
{
  return *(float *)(a1 + 32);
}

//----- (1000F190) --------------------------------------------------------
void __cdecl sub_1000F190(int a1, float a2)
{
  float v3; // eax
  double v4; // st7
  double v5; // st7
  int v6; // eax
  float v7; // edx
  double v8; // st7
  double v9; // st7
  float v10; // [esp+0h] [ebp-14h]
  float v11; // [esp+4h] [ebp-10h]
  float v12; // [esp+4h] [ebp-10h]
  float v13; // [esp+8h] [ebp-Ch]
  float v14; // [esp+10h] [ebp-4h]
  float v15; // [esp+10h] [ebp-4h]
  float v16; // [esp+18h] [ebp+4h]

  v16 = (a2 - *(float *)(a1 + 32)) * *(float *)(a1 + 40) + *(float *)(a1 + 36);
  *(float *)(a1 + 36) = v16;
  if ( v16 >= 0.0 )
  {
    if ( v16 > (double)*(float *)(a1 + 44) )
    {
      v6 = *(_DWORD *)(a1 + 52);
      if ( !v6 || *(_DWORD *)(a1 + 48) < v6 - 1 )
      {
        v14 = v16 / *(float *)(a1 + 44);
        v7 = *(float *)(a1 + 36);
        *(_DWORD *)(a1 + 48) += (int)v14;
        v12 = *(float *)(a1 + 44);
        v15 = v7 / v12;
        v8 = v7 - (double)(int)v15 * v12;
        *(float *)(a1 + 36) = v8;
        if ( v8 < 0.0 )
        {
          v9 = v8 + *(float *)(a1 + 44);
          *(float *)(a1 + 32) = a2;
          *(float *)(a1 + 36) = v9;
          return;
        }
      }
    }
  }
  else if ( !*(_DWORD *)(a1 + 52) || *(int *)(a1 + 48) > 0 )
  {
    v11 = v16 / *(float *)(a1 + 44);
    v3 = *(float *)(a1 + 36);
    *(_DWORD *)(a1 + 48) += (int)v11;
    v10 = *(float *)(a1 + 44);
    v13 = v3 / v10;
    v4 = v3 - (double)(int)v13 * v10;
    *(float *)(a1 + 36) = v4;
    if ( v4 < 0.0 )
    {
      v5 = v4 + *(float *)(a1 + 44);
      *(float *)(a1 + 32) = a2;
      *(float *)(a1 + 36) = v5;
      return;
    }
  }
  *(float *)(a1 + 32) = a2;
}

//----- (1000F360) --------------------------------------------------------
int __cdecl sub_1000F360(int a1, float a2)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 32) = a2;
  return result;
}

//----- (1000F370) --------------------------------------------------------
BOOL __cdecl sub_1000F370(int a1)
{
  return *(_BYTE *)(a1 + 56) && *(float *)(a1 + 32) >= (double)*(float *)(a1 + 60);
}

//----- (1000F3A0) --------------------------------------------------------
char __cdecl sub_1000F3A0(int a1)
{
  unsigned int v1; // edx

  if ( !a1 || !sub_1000F370(a1) )
    return 0;
  sub_1000F0F0(v1);
  return 1;
}
// 1000F3B9: variable 'v1' is possibly undefined

//----- (1000F3D0) --------------------------------------------------------
char __cdecl sub_1000F3D0(int a1)
{
  char v1; // dl
  int v2; // eax
  unsigned int v3; // ecx

  v1 = 0;
  if ( !a1 )
    return v1;
  v2 = sub_1000F020(a1);
  if ( !*(_BYTE *)(v3 + 64) || v2 != *(_DWORD *)(v2 + 8) )
    return v1;
  sub_1000F0F0(v3);
  return 1;
}
// 1000F3E1: variable 'v3' is possibly undefined
// 1000F3FD: variable 'v1' is possibly undefined

//----- (1000F410) --------------------------------------------------------
double __cdecl sub_1000F410(int a1)
{
  return *(float *)(a1 + 68);
}

//----- (1000F420) --------------------------------------------------------
double __cdecl sub_1000F420(int a1)
{
  double result; // st7

  result = 1.0;
  if ( *(float *)(a1 + 76) >= (double)*(float *)(a1 + 104) )
  {
    if ( !*(_BYTE *)(a1 + 100) )
      goto LABEL_13;
    if ( *(_BYTE *)(a1 + 72) )
    {
      if ( *(float *)(a1 + 32) <= (double)*(float *)(a1 + 108) )
        return sub_1000F540(*(float *)(a1 + 104), *(float *)(a1 + 32), *(float *)(a1 + 108), (float *)(a1 + 112));
      if ( *(float *)(a1 + 32) <= (double)*(float *)(a1 + 76) )
        return (1.0 - (*(float *)(a1 + 32) - *(float *)(a1 + 108)) / (*(float *)(a1 + 76) - *(float *)(a1 + 108)))
             * *(float *)(a1 + 124)
             + (*(float *)(a1 + 32) - *(float *)(a1 + 108))
             / (*(float *)(a1 + 76) - *(float *)(a1 + 108))
             * *(float *)(a1 + 84);
      if ( *(float *)(a1 + 32) <= (double)*(float *)(a1 + 80) )
        return sub_1000F540(*(float *)(a1 + 76), *(float *)(a1 + 32), *(float *)(a1 + 80), (float *)(a1 + 84));
      return result;
    }
  }
  if ( *(_BYTE *)(a1 + 100) && *(float *)(a1 + 32) >= (double)*(float *)(a1 + 104) )
    result = sub_1000F540(*(float *)(a1 + 104), *(float *)(a1 + 32), *(float *)(a1 + 108), (float *)(a1 + 112));
LABEL_13:
  if ( *(_BYTE *)(a1 + 72) && *(float *)(a1 + 32) <= (double)*(float *)(a1 + 80) )
    return sub_1000F540(*(float *)(a1 + 76), *(float *)(a1 + 32), *(float *)(a1 + 80), (float *)(a1 + 84));
  return result;
}

//----- (1000F540) --------------------------------------------------------
double __cdecl sub_1000F540(float a1, float a2, float a3, float *a4)
{
  double v4; // st7

  v4 = (a2 - a1) / (a3 - a1);
  if ( v4 >= 0.0 )
  {
    if ( v4 > 1.0 )
      v4 = 1.0;
  }
  else
  {
    v4 = 0.0;
  }
  return ((1.0 - v4) * a4[1] + v4 * a4[2]) * (1.0 - v4) * v4 * 3.0
       + v4 * a4[3] * v4 * v4
       + (1.0 - v4) * *a4 * (1.0 - v4) * (1.0 - v4);
}

//----- (1000F5C0) --------------------------------------------------------
double __cdecl sub_1000F5C0(int a1)
{
  return sub_1000F420(a1) * *(float *)(a1 + 68);
}

//----- (1000F5E0) --------------------------------------------------------
int __cdecl sub_1000F5E0(int a1, float a2)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 68) = a2;
  return result;
}

//----- (1000F5F0) --------------------------------------------------------
int __cdecl sub_1000F5F0(int a1)
{
  return *(_DWORD *)(a1 + 52);
}

//----- (1000F600) --------------------------------------------------------
int __cdecl sub_1000F600(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 52) = a2;
  return result;
}

//----- (1000F610) --------------------------------------------------------
bool __cdecl sub_1000F610(int a1, bool *a2, bool *a3)
{
  bool result; // al

  if ( *(_DWORD *)(a1 + 52) )
  {
    *a2 = *(_DWORD *)(a1 + 48) > 0;
    result = *(_DWORD *)(a1 + 48) < *(_DWORD *)(a1 + 52) - 1;
    *a3 = result;
  }
  else
  {
    result = (char)a2;
    *a2 = 1;
    *a3 = 1;
  }
  return result;
}

//----- (1000F650) --------------------------------------------------------
int __cdecl sub_1000F650(int a1)
{
  return *(_DWORD *)(a1 + 48);
}

//----- (1000F660) --------------------------------------------------------
int __cdecl sub_1000F660(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 48) = a2;
  return result;
}

//----- (1000F670) --------------------------------------------------------
double __cdecl sub_1000F670(int a1)
{
  return *(float *)(a1 + 40);
}

//----- (1000F680) --------------------------------------------------------
int __cdecl sub_1000F680(int a1, float a2)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 40) = a2;
  return result;
}

//----- (1000F690) --------------------------------------------------------
double __cdecl sub_1000F690(int a1)
{
  double result; // st7
  int v3; // [esp+4h] [ebp+4h]

  result = flt_10036110;
  v3 = *(_DWORD *)(a1 + 52);
  if ( v3 )
  {
    if ( *(float *)(a1 + 40) != 0.0 )
      return *(float *)(a1 + 44) / *(float *)(a1 + 40) * (double)v3;
  }
  return result;
}
// 10036110: using guessed type float flt_10036110;

//----- (1000F6D0) --------------------------------------------------------
double __cdecl sub_1000F6D0(float a1)
{
  int v1; // ecx
  int v3; // esi

  v1 = *(_DWORD *)(LODWORD(a1) + 52);
  if ( !v1 )
    return flt_10036110;
  v3 = *(_DWORD *)(LODWORD(a1) + 48);
  if ( v3 >= v1 )
    return 0.0;
  if ( *(float *)(LODWORD(a1) + 40) == 0.0 )
    return a1;
  return (double)(v1 - v3 - 1) * (1.0 / *(float *)(LODWORD(a1) + 40) * *(float *)(LODWORD(a1) + 44))
       + (*(float *)(LODWORD(a1) + 44) - *(float *)(LODWORD(a1) + 36)) * (1.0 / *(float *)(LODWORD(a1) + 40));
}
// 10036110: using guessed type float flt_10036110;

//----- (1000F740) --------------------------------------------------------
char __cdecl sub_1000F740(int a1)
{
  return *(_BYTE *)(a1 + 65);
}

//----- (1000F750) --------------------------------------------------------
char __cdecl sub_1000F750(int a1, char a2)
{
  char result; // al

  result = a2;
  *(_BYTE *)(a1 + 65) = a2;
  return result;
}

//----- (1000F760) --------------------------------------------------------
double __cdecl sub_1000F760(int a1)
{
  double result; // st7

  result = *(float *)(a1 + 36);
  if ( result < 0.0 )
    return 0.0;
  if ( result > *(float *)(a1 + 44) )
    return *(float *)(a1 + 44);
  return result;
}

//----- (1000F790) --------------------------------------------------------
double __cdecl sub_1000F790(int a1)
{
  return *(float *)(a1 + 44);
}

//----- (1000F7A0) --------------------------------------------------------
char __cdecl sub_1000F7A0(int a1, char a2)
{
  char result; // al

  result = a2;
  *(_BYTE *)(a1 + 72) = a2;
  return result;
}

//----- (1000F7B0) --------------------------------------------------------
int __cdecl sub_1000F7B0(int a1, float a2, int a3, int a4, int a5, int a6, int a7)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 76) = a2;
  *(_DWORD *)(a1 + 80) = a3;
  *(_DWORD *)(a1 + 84) = a4;
  *(_DWORD *)(a1 + 88) = a5;
  *(_DWORD *)(a1 + 92) = a6;
  *(_DWORD *)(a1 + 96) = a7;
  return result;
}

//----- (1000F7E0) --------------------------------------------------------
char __cdecl sub_1000F7E0(int a1, char a2)
{
  char result; // al

  result = a2;
  *(_BYTE *)(a1 + 100) = a2;
  return result;
}

//----- (1000F7F0) --------------------------------------------------------
int __cdecl sub_1000F7F0(int a1, float a2, int a3, int a4, int a5, int a6, int a7)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 104) = a2;
  *(_DWORD *)(a1 + 108) = a3;
  *(_DWORD *)(a1 + 112) = a4;
  *(_DWORD *)(a1 + 116) = a5;
  *(_DWORD *)(a1 + 120) = a6;
  *(_DWORD *)(a1 + 124) = a7;
  return result;
}

//----- (1000F820) --------------------------------------------------------
double __cdecl sub_1000F820(int a1)
{
  return *(float *)(a1 + 36);
}

//----- (1000F830) --------------------------------------------------------
int __cdecl sub_1000F830(int a1, float a2)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 36) = a2;
  return result;
}

//----- (1000F840) --------------------------------------------------------
double __cdecl sub_1000F840(int a1, float a2, char a3)
{
  float v5; // [esp+4h] [ebp-4h]
  float v6; // [esp+Ch] [ebp+4h]
  int v7; // [esp+14h] [ebp+Ch]

  v5 = sub_1000F180(a1);
  v6 = 0.0;
  if ( a3 )
    v6 = sub_1000F420(a1);
  sub_1000F7A0(a1, 1);
  sub_1000F7E0(a1, 0);
  *(float *)&v7 = v5 + a2;
  sub_1000F7B0(a1, v5, v7, SLODWORD(v6), SLODWORD(v6), 1065353216, 1065353216);
  return *(float *)&v7;
}

//----- (1000F8C0) --------------------------------------------------------
double __cdecl sub_1000F8C0(int a1, int a2)
{
  int v4; // [esp+4h] [ebp-4h]
  float v5; // [esp+Ch] [ebp+4h]
  int v6; // [esp+10h] [ebp+8h]

  v5 = sub_1000F180(a1);
  *(float *)&v4 = sub_1000F420(a1);
  sub_1000F7A0(a1, 0);
  sub_1000F7E0(a1, 1);
  *(float *)&v6 = v5 + *(float *)&a2;
  sub_1000F7F0(a1, v5, v6, v4, v4, 0, 0);
  return *(float *)&v6;
}

//----- (1000F920) --------------------------------------------------------
int __cdecl sub_1000F920(int a1)
{
  return a1 + 128;
}

//----- (1000F930) --------------------------------------------------------
float *__cdecl sub_1000F930(float a1)
{
  float *result; // eax
  float *v2; // ecx

  sub_1000F0D0();
  for ( result = (float *)sub_1000F0D0(); v2 != result; result = (float *)sub_1000F0D0() )
  {
    v2[8] = a1 + v2[8];
    v2[15] = a1 + v2[15];
    v2[19] = a1 + v2[19];
    v2[20] = a1 + v2[20];
    v2[26] = a1 + v2[26];
    v2[27] = a1 + v2[27];
  }
  return result;
}
// 1000F942: variable 'v2' is possibly undefined

//----- (1000F990) --------------------------------------------------------
int __cdecl sub_1000F990(int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // edi
  int v5; // eax
  int result; // eax

  v4 = a4[1];
  v5 = sub_10019B90(a1, 28, 28);
  sub_10019B10(v5 + 16, 20 * *(_DWORD *)(v4 + 12));
  result = a4[4];
  if ( a4[3] != result )
    return sub_10019A60(a4 + 8, 68 * *(_DWORD *)(v4 + 12));
  return result;
}

//----- (1000F9E0) --------------------------------------------------------
char __cdecl sub_1000F9E0(int a1, int a2)
{
  int v3; // edi
  int v4; // eax
  int v5; // ecx
  int v6; // esi
  char *v7; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  bool v11; // cc
  int v13; // [esp+8h] [ebp-1Ch]
  int v14; // [esp+Ch] [ebp-18h]
  int v15; // [esp+10h] [ebp-14h]
  int v16; // [esp+14h] [ebp-10h]
  int v17; // [esp+1Ch] [ebp-8h] BYREF
  int v18; // [esp+20h] [ebp-4h] BYREF
  char v19; // [esp+28h] [ebp+4h]
  int v20; // [esp+2Ch] [ebp+8h]

  v3 = *(_DWORD *)(a1 + 28);
  v4 = *(_DWORD *)(a2 + 4);
  *(_BYTE *)(v3 + 8) = *(_BYTE *)(a2 + 8);
  *(_DWORD *)(v3 + 4) = v4;
  *(_DWORD *)v3 = *(_DWORD *)a2;
  v16 = v4;
  *(_DWORD *)(v3 + 12) = *(_DWORD *)(v4 + 12);
  *(_DWORD *)(v3 + 20) = *(_DWORD *)(a2 + 24);
  v5 = *(_DWORD *)(v3 + 12);
  *(_DWORD *)(v3 + 24) = *(_DWORD *)(a2 + 28);
  v14 = *(_DWORD *)(a2 + 32);
  v19 = 0;
  v15 = 0;
  if ( v5 > 0 )
  {
    v20 = 0;
    v13 = 0;
    do
    {
      v6 = v13 + *(_DWORD *)(v3 + 16);
      v7 = *(char **)(v20 + *(_DWORD *)(*(_DWORD *)(v3 + 4) + 16));
      v8 = sub_100021D0(*(_DWORD *)(a2 + 20));
      sub_10021080(v8, v7, (int *)v6);
      *(_DWORD *)(v6 + 8) = 0;
      *(_DWORD *)(v6 + 12) = 0;
      *(_DWORD *)(v6 + 16) = 0;
      *(_DWORD *)(v6 + 4) = 0;
      v9 = *(_DWORD *)(a2 + 12);
      if ( v9
        && *(_DWORD *)(a2 + 16)
        && sub_10021080(*(_DWORD *)(v9 + 4), v7, &v17)
        && sub_10021080(*(_DWORD *)(*(_DWORD *)(a2 + 16) + 4), v7, &v18) )
      {
        v10 = 156 * v17;
        *(_DWORD *)(v6 + 4) = v14;
        v14 += 68;
        sub_10001690(*(int **)(v6 + 4), (float *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 12) + 4) + 8) + v10 + 8));
        sub_100014D0(*(void **)(v6 + 4), *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 16) + 4) + 8) + 156 * v18 + 8);
      }
      if ( sub_10024000(v20 + *(_DWORD *)(v16 + 16)) )
        v19 = 1;
      v11 = ++v15 < *(_DWORD *)(v3 + 12);
      v13 += 20;
      v20 += 64;
    }
    while ( v11 );
    if ( v19 )
      sub_10017FE0(
        2,
        18,
        "%s(%d): The track group \"%s\" has uncompressed animation tracks, which are meant for preprocessing only.  They "
        "will be ignored during playback.",
        aWPublicGrannyR_10,
        241,
        *(const char **)v16);
  }
  return 1;
}

//----- (1000FEF0) --------------------------------------------------------
void __cdecl sub_1000FEF0(char a1, char a2, int a3, int a4, int a5, int a6, int *a7, int a8)
{
  unsigned int *v8; // esi
  int v9; // eax
  int v10; // ebx
  int v11; // eax

  v8 = (unsigned int *)a5;
  v9 = *(_DWORD *)(a5 + 4);
  if ( v9 <= 1 )
  {
    sub_10019E30(a4, *(_DWORD **)(a5 + 16), a8);
  }
  else
  {
    v10 = a6;
    v11 = sub_1000ADC0(v9, *(_DWORD *)(a5 + 8), *(float *)&a6);
    *a7 = v11;
    if ( sub_1000AEB0(
           a4,
           a1 != 0 ? v8 : 0,
           v8,
           a2 != 0 ? (unsigned int)v8 : 0,
           v11,
           dword_100361C8,
           (int)flt_100361E0,
           &a6,
           &a5) )
    {
      if ( a4 == 4 )
        sub_10018D90(*v8 + 1, flt_100361E0);
    }
    sub_1000AD10(*v8, a4, a6, a5, v10, a8);
  }
}
// 100361C8: using guessed type _DWORD dword_100361C8[6];
// 100361E0: using guessed type float flt_100361E0[54];

//----- (1000FFB0) --------------------------------------------------------
void __cdecl sub_1000FFB0(int *a1, float a2, float *a3, float *a4, float *a5)
{
  int v5; // edi
  double v6; // st7
  int v7; // ecx
  float *v8; // esi
  float *v9; // eax
  double v10; // st7
  double v11; // st7
  int v12[3]; // [esp+8h] [ebp-18h] BYREF
  int v13[3]; // [esp+14h] [ebp-Ch] BYREF
  int v14; // [esp+24h] [ebp+4h]
  float v15; // [esp+28h] [ebp+8h]

  v5 = a1[7];
  if ( *(_BYTE *)(v5 + 8) )
  {
    v15 = sub_1000F670(*a1) * a2;
    v6 = sub_1000F5C0(*a1);
    *(float *)&v14 = v6;
    if ( v6 > 0.001 )
    {
      v7 = *(_DWORD *)(v5 + 4);
      v8 = *(float **)(v7 + 112);
      if ( v8 )
      {
        sub_1001D650(v8, v15, (float *)v12);
        *a4 = *(float *)v12 * *(float *)&v14 + *a4;
        a4[1] = *(float *)&v12[1] * *(float *)&v14 + a4[1];
        a4[2] = *(float *)&v12[2] * *(float *)&v14 + a4[2];
        sub_1001D6D0(v8, v15, (float *)v13);
        v9 = a5;
        *a5 = *(float *)v13 * *(float *)&v14 + *a5;
        a5[1] = *(float *)&v13[1] * *(float *)&v14 + a5[1];
        v10 = *(float *)&v13[2] * *(float *)&v14;
      }
      else
      {
        v9 = a4;
        v11 = v15 / *(float *)(*(_DWORD *)v5 + 4) * *(float *)&v14;
        *a4 = v11 * *(float *)(v7 + 100) + *a4;
        a4[1] = v11 * *(float *)(v7 + 104) + a4[1];
        v10 = v11 * *(float *)(v7 + 108);
      }
      v9[2] = v10 + v9[2];
      *a3 = *(float *)&v14 + *a3;
    }
  }
}

//----- (100100C0) --------------------------------------------------------
_DWORD *__cdecl sub_100100C0(float a1, int a2, int a3)
{
  int v3; // edi
  char **v4; // eax
  int v5; // eax
  int *v6; // esi

  v3 = a3;
  v4 = (char **)sub_100043A0(a3);
  if ( !sub_10003EE0(a2, *v4, &a3) )
    return 0;
  v5 = sub_10010120(a1, a2);
  v6 = (int *)v5;
  if ( !v5 )
    return 0;
  sub_10010280(v5, a3, v3);
  return sub_100101C0(v6);
}

//----- (10010120) --------------------------------------------------------
int __cdecl sub_10010120(float a1, int a2)
{
  bool v2; // zf
  int result; // eax
  int v4; // ecx
  int v5; // ebp
  int v6; // eax
  int v7; // edx
  int v8; // [esp+8h] [ebp-4h] BYREF

  sub_10019A60(&v8, 16);
  sub_10019BC0(v8, 8, 12, *(_DWORD *)(a2 + 12), 36);
  v2 = sub_10019C60((int)aWPublicGrannyR_10, 491) == 0;
  result = v8;
  if ( !v2 )
  {
    *(float *)v8 = a1;
    *(_DWORD *)(v8 + 4) = a2;
    result = v8;
    v4 = 0;
    if ( *(int *)(v8 + 8) > 0 )
    {
      v5 = 0;
      do
      {
        v6 = v5 + *(_DWORD *)(result + 12);
        *(_DWORD *)v6 = a2;
        v7 = *(_DWORD *)(*(_DWORD *)(a2 + 16) + 4 * v4);
        *(_DWORD *)(v6 + 4) = v7;
        *(_DWORD *)(v6 + 12) = 0;
        *(_DWORD *)(v6 + 16) = 0;
        *(_DWORD *)(v6 + 20) = 0;
        *(_DWORD *)(v6 + 24) = 0;
        *(_DWORD *)(v6 + 28) = 0;
        *(_BYTE *)(v6 + 8) = *(_BYTE *)(v7 + 96) & 1;
        result = v8;
        ++v4;
        v5 += 36;
      }
      while ( v4 < *(_DWORD *)(v8 + 8) );
    }
  }
  return result;
}

//----- (100101C0) --------------------------------------------------------
_DWORD *__cdecl sub_100101C0(int *a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // ebp
  int v3; // ebx
  int v4; // edi
  int v5; // eax
  int v6; // ecx
  int v7; // eax

  result = 0;
  if ( a1 )
  {
    v2 = sub_1000F030(*a1, *(_DWORD *)(a1[1] + 4));
    if ( v2 )
    {
      v3 = 0;
      if ( a1[2] > 0 )
      {
        v4 = 0;
        do
        {
          v5 = a1[3];
          v6 = *(_DWORD *)(v5 + v4 + 20);
          v7 = v4 + v5;
          if ( v6 )
          {
            if ( !sub_10001EE0((int)&off_10031048, (int)v2, v6, v7) )
              sub_10017FE0(3, 36, "%s(%d): Unable to bind track group", aWPublicGrannyR_10, 546);
          }
          ++v3;
          v4 += 36;
        }
        while ( v3 < a1[2] );
      }
    }
    else
    {
      sub_10017FE0(3, 36, "%s(%d): Unable to create control", aWPublicGrannyR_10, 554);
    }
    off_10033624((int)aWPublicGrannyR_10, 557, (int)a1);
    return v2;
  }
  return result;
}
// 10031048: using guessed type int (__cdecl *off_10031048)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10010280) --------------------------------------------------------
void __cdecl sub_10010280(int a1, int a2, int a3)
{
  if ( a2 < 0 || a2 >= *(_DWORD *)(a1 + 8) )
    sub_10017FE0(
      3,
      36,
      "%s(%d): TrackGroupIndex %d is out of range [0, %d)",
      aWPublicGrannyR_10,
      567,
      a2,
      *(_DWORD *)(a1 + 8));
  else
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 36 * a2 + 20) = a3;
}

//----- (100102D0) --------------------------------------------------------
void __cdecl sub_100102D0(int a1, int a2, int a3, int a4)
{
  int v4; // eax

  if ( a2 < 0 || a2 >= *(_DWORD *)(a1 + 8) )
  {
    sub_10017FE0(
      3,
      36,
      "%s(%d): TrackGroupIndex %d is out of range [0, %d)",
      aWPublicGrannyR_10,
      577,
      a2,
      *(_DWORD *)(a1 + 8));
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 12) + 36 * a2;
    *(_DWORD *)(v4 + 12) = a3;
    *(_DWORD *)(v4 + 16) = a4;
  }
}

//----- (10010320) --------------------------------------------------------
void __cdecl sub_10010320(int a1, int a2, int a3)
{
  if ( a2 < 0 || a2 >= *(_DWORD *)(a1 + 8) )
    sub_10017FE0(
      3,
      36,
      "%s(%d): TrackGroupIndex %d is out of range [0, %d)",
      aWPublicGrannyR_10,
      588,
      a2,
      *(_DWORD *)(a1 + 8));
  else
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 36 * a2 + 24) = a3;
}

//----- (10010370) --------------------------------------------------------
void __cdecl sub_10010370(int a1, int a2, int a3)
{
  if ( a2 < 0 || a2 >= *(_DWORD *)(a1 + 8) )
    sub_10017FE0(
      3,
      36,
      "%s(%d): TrackGroupIndex %d is out of range [0, %d)",
      aWPublicGrannyR_10,
      598,
      a2,
      *(_DWORD *)(a1 + 8));
  else
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 36 * a2 + 28) = a3;
}

//----- (100103C0) --------------------------------------------------------
void __cdecl sub_100103C0(int a1, int a2, char a3)
{
  if ( a2 < 0 || a2 >= *(_DWORD *)(a1 + 8) )
    sub_10017FE0(
      3,
      36,
      "%s(%d): TrackGroupIndex %d is out of range [0, %d)",
      aWPublicGrannyR_10,
      609,
      a2,
      *(_DWORD *)(a1 + 8));
  else
    *(_BYTE *)(*(_DWORD *)(a1 + 12) + 36 * a2 + 8) = a3;
}

//----- (10010430) --------------------------------------------------------
char __cdecl sub_10010430(int a1, _DWORD *a2)
{
  _DWORD *v2; // eax

  v2 = *(_DWORD **)(a1 + 28);
  *v2 = *a2;
  v2[1] = a2[1];
  return 1;
}

//----- (10010450) --------------------------------------------------------
void __cdecl sub_10010450(int *a1, int a2, int a3, int a4)
{
  int *v4; // edi
  double v5; // st7
  int v6; // eax
  int v7; // esi
  int v8; // ebx
  _DWORD *v9; // eax
  float *v10; // eax
  float v11; // [esp+Ch] [ebp-4h]
  float v12; // [esp+14h] [ebp+4h]

  v4 = (int *)a1[7];
  v5 = sub_1000F5C0(*a1);
  v11 = v5;
  if ( v5 > 0.001 )
  {
    v6 = sub_100043A0(*v4);
    v7 = a2;
    v8 = a2 + a3;
    if ( a2 < v6 )
    {
      if ( v8 > v6 )
        v8 = v6;
      if ( a2 < v8 )
      {
        do
        {
          v12 = v11;
          v9 = (_DWORD *)v4[1];
          if ( v9 )
            v12 = sub_10024A30(v9, v7) * v11;
          if ( v12 > 0.001 )
          {
            v10 = (float *)sub_10017830((int *)*v4, v7);
            sub_10017880(a4, v7, v12, v10);
          }
          ++v7;
        }
        while ( v7 < v8 );
      }
    }
  }
}

//----- (10010500) --------------------------------------------------------
_DWORD *__cdecl sub_10010500(int a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // esi
  _DWORD v7[2]; // [esp+4h] [ebp-8h] BYREF

  v5 = sub_1000F030(a1, a2);
  if ( v5 )
  {
    v7[0] = a3;
    v7[1] = a5;
    if ( !sub_10001EE0((int)&off_100311BC, (int)v5, a4, (int)v7) )
    {
      sub_1000F0F0((unsigned int)v5);
      sub_10017FE0(3, 36, "%s(%d): Unable to bind track group", aWPublicGrannyR_11, 164);
      return 0;
    }
  }
  else
  {
    sub_10017FE0(3, 36, "%s(%d): Unable to create control", aWPublicGrannyR_11, 170);
  }
  return v5;
}
// 100311BC: using guessed type _UNKNOWN *off_100311BC;

//----- (100105A0) --------------------------------------------------------
_DWORD *__cdecl sub_100105A0(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = -1;
  return result;
}

//----- (100105B0) --------------------------------------------------------
unsigned int __cdecl sub_100105B0(int *a1, int a2, unsigned __int8 *a3)
{
  int i; // edi
  unsigned int result; // eax
  int v6; // edx

  for ( i = a2; i; *a1 = v6 )
  {
    result = (unsigned int)*a1 >> 8;
    v6 = result ^ dword_10031200[*a3++ ^ (unsigned __int8)*a1];
    --i;
  }
  return result;
}
// 10031200: using guessed type int dword_10031200[256];

//----- (100105F0) --------------------------------------------------------
int *__cdecl sub_100105F0(int *a1)
{
  int *result; // eax

  result = a1;
  *a1 = ~*a1;
  return result;
}

//----- (10010600) --------------------------------------------------------
int __cdecl sub_10010600(int a1, int a2, char *a3)
{
  int v3; // esi

  v3 = a1;
  if ( a1 )
  {
    while ( *(_DWORD *)v3 )
    {
      if ( sub_10021AC0(*(char **)(v3 + 4), a3) )
        return v3;
      a2 += sub_10001990(v3);
      v3 += 32;
      if ( !v3 )
        return 0;
    }
  }
  return 0;
}

//----- (10010650) --------------------------------------------------------
char *__usercall sub_10010650@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, char *a6)
{
  _BYTE v7[16]; // [esp+0h] [ebp-10h] BYREF

  sub_10010690((int)v7, 0);
  return sub_100106C0(a1, a2, (int)v7, a3, a4, a5, a6);
}

//----- (10010690) --------------------------------------------------------
int __cdecl sub_10010690(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 4) = 1;
  *(_BYTE *)(a1 + 5) = a2 != 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = a2;
  return result;
}

//----- (100106C0) --------------------------------------------------------
char *__usercall sub_100106C0@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, int a6, char *a7)
{
  int i; // esi
  int *v9; // eax
  char **v10; // edx

  for ( i = a6; i; i += 32 )
  {
    if ( !*(_DWORD *)i )
      break;
    if ( *(_BYTE *)(a3 + 4) )
      sub_10001B10(a1, i, a7);
    a1 = sub_10001990(i);
    v9 = (int *)sub_10010600(a4, a5, *(char **)(i + 4));
    if ( v10 )
    {
      if ( *v9 == 1 )
        sub_100106C0(a3, v9[2], v10, *(_DWORD *)(i + 8), a7);
      else
        sub_10010740(a2, a3, v9, v10, (_DWORD *)i, a7);
    }
    a7 += a1;
  }
  return a7;
}
// 1001070A: variable 'v10' is possibly undefined

//----- (10010740) --------------------------------------------------------
void __usercall sub_10010740(double a1@<st0>, int a2, int *a3, char **a4, _DWORD *a5, char *a6)
{
  int v6; // edi
  int v7; // eax
  float *v8; // edi
  int v9; // ebp
  char **v10; // esi
  float v11; // [esp+0h] [ebp-18h]
  float v12; // [esp+0h] [ebp-18h]
  int v13; // [esp+4h] [ebp-14h]
  int v14; // [esp+4h] [ebp-14h]
  int i; // [esp+1Ch] [ebp+4h]
  int v16; // [esp+2Ch] [ebp+14h]

  v6 = sub_10001990((int)a5);
  if ( *a5 == *a3 )
  {
    v7 = sub_10001990((int)a3);
    if ( v7 > v6 )
      v7 = v6;
    sub_10019E10(v7, a4, (int)a6);
  }
  else
  {
    switch ( *a5 )
    {
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 9:
        if ( *(_BYTE *)(a2 + 4) )
          sub_10001B10((int)a3, (int)a5, a6);
        break;
      case 8:
        *(_DWORD *)a6 = sub_10010BF0(a1, a2, *a3, a4);
        break;
      default:
        v8 = (float *)a6;
        if ( *(_BYTE *)(a2 + 4) )
          sub_10001B10((int)a3, (int)a5, a6);
        v9 = sub_10001B90((int)a3);
        if ( v9 > sub_10001B90((int)a5) )
          v9 = sub_10001B90((int)a5);
        v16 = sub_10001980(a3);
        v10 = a4;
        for ( i = sub_10001980(a5); v9; --v9 )
        {
          switch ( *a5 )
          {
            case 0xA:
              a1 = sub_10010AB0(*a3, v10);
              *v8 = a1;
              break;
            case 0xB:
            case 0xC:
              *(_BYTE *)v8 = (unsigned __int8)sub_10010970(a1, *a3, v10);
              break;
            case 0xD:
              v13 = 127;
              a1 = sub_10010AB0(*a3, v10);
              goto LABEL_20;
            case 0xE:
              v13 = 255;
              a1 = sub_10010AB0(*a3, v10);
LABEL_20:
              v11 = a1;
              *(_BYTE *)v8 = sub_10010D40(v11, v13);
              break;
            case 0xF:
            case 0x10:
              *(_WORD *)v8 = (unsigned __int16)sub_10010970(a1, *a3, v10);
              break;
            case 0x11:
              v14 = 0x7FFF;
              a1 = sub_10010AB0(*a3, v10);
              goto LABEL_23;
            case 0x12:
              v14 = 0xFFFF;
              a1 = sub_10010AB0(*a3, v10);
LABEL_23:
              v12 = a1;
              *(_WORD *)v8 = sub_10010D40(v12, v14);
              break;
            case 0x13:
            case 0x14:
              *(_DWORD *)v8 = sub_10010970(a1, *a3, v10);
              break;
            default:
              break;
          }
          v10 = (char **)((char *)v10 + v16);
          v8 = (float *)((char *)v8 + i);
        }
        break;
    }
  }
}

//----- (10010970) --------------------------------------------------------
char *__usercall sub_10010970@<eax>(double a1@<st0>, int a2, char **a3)
{
  char *result; // eax

  result = 0;
  switch ( a2 )
  {
    case 8:
      if ( *a3 )
        result = (char *)sub_10021BC0(a1, *a3);
      break;
    case 10:
      result = (char *)(int)*(float *)a3;
      break;
    case 11:
      result = (char *)*(char *)a3;
      break;
    case 12:
      result = (char *)*(unsigned __int8 *)a3;
      break;
    case 13:
      result = (char *)sub_10010A80(*(char *)a3, 127);
      break;
    case 14:
      result = (char *)sub_10010A80(*(unsigned __int8 *)a3, 255);
      break;
    case 15:
      result = (char *)*(__int16 *)a3;
      break;
    case 16:
      result = (char *)*(unsigned __int16 *)a3;
      break;
    case 17:
      result = (char *)sub_10010A80(*(__int16 *)a3, 0x7FFF);
      break;
    case 18:
      result = (char *)sub_10010A80(*(unsigned __int16 *)a3, 0xFFFF);
      break;
    case 19:
      result = *a3;
      break;
    case 20:
      result = *a3;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (10010A80) --------------------------------------------------------
int __cdecl sub_10010A80(int a1, int a2)
{
  if ( a1 <= a2 / 2 )
    return (a1 >= a2 / -2) - 1;
  else
    return 1;
}

//----- (10010AB0) --------------------------------------------------------
double __cdecl sub_10010AB0(int a1, char **a2)
{
  double result; // st7

  result = 0.0;
  switch ( a1 )
  {
    case 8:
      if ( *a2 )
        sub_10021C20(*a2, 1);
      break;
    case 10:
      result = *(float *)a2;
      break;
    case 11:
      result = (double)*(unsigned __int8 *)a2;
      break;
    case 12:
      result = (double)*(unsigned __int8 *)a2;
      break;
    case 13:
      result = (double)*(char *)a2 * 0.0078740157;
      break;
    case 14:
      result = (double)*(unsigned __int8 *)a2 * 0.0039215689;
      break;
    case 15:
      result = (double)*(__int16 *)a2;
      break;
    case 16:
      result = (double)*(unsigned __int16 *)a2;
      break;
    case 17:
      result = (double)*(__int16 *)a2 * 0.000030518509;
      break;
    case 18:
      result = (double)*(unsigned __int16 *)a2 * 0.000015259022;
      break;
    case 19:
      result = (double)(int)*a2;
      break;
    default:
      result = 0.0;
      break;
  }
  return result;
}

//----- (10010BF0) --------------------------------------------------------
int __usercall sub_10010BF0@<eax>(double a1@<st0>, int a2, int a3, char **a4)
{
  int v4; // edi
  char *v5; // esi
  char *v6; // eax
  int v7; // eax
  double v8; // st7
  char v10; // [esp+24h] [ebp-100h] BYREF

  v4 = sub_10010D00(a2);
  v5 = (char *)v4;
  if ( !v4 )
    v5 = &v10;
  switch ( a3 )
  {
    case 8:
      if ( *(_BYTE *)(a2 + 5) )
        v7 = sub_10021B90(*a4, v5);
      else
        v7 = sub_10021A00(*a4) + 1;
      break;
    case 10:
    case 13:
    case 14:
    case 17:
    case 18:
      v8 = sub_10010AB0(a3, a4);
      v7 = sub_10021FA0(v4, 256, v5, v8, 10.0, 6, "0123456789abcdefghijklmnopqrstuvwxyz");
      break;
    case 11:
    case 12:
    case 15:
    case 16:
    case 19:
    case 20:
      v6 = sub_10010970(a1, a3, a4);
      v7 = sub_10021EC0(0x100u, v5, (int)v6, 0xAu, "0123456789abcdefghijklmnopqrstuvwxyz");
      break;
    default:
      v7 = 1;
      v10 = 0;
      break;
  }
  sub_10010D20(a2, (v7 + 3) & 0xFFFFFFFC);
  return v4;
}

//----- (10010D00) --------------------------------------------------------
int __cdecl sub_10010D00(int a1)
{
  int result; // eax

  result = 0;
  if ( *(_BYTE *)(a1 + 5) )
    return *(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 12);
  return result;
}

//----- (10010D20) --------------------------------------------------------
int __cdecl sub_10010D20(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 8) += a2;
  return result;
}

//----- (10010D40) --------------------------------------------------------
int __cdecl sub_10010D40(float a1, int a2)
{
  return (int)(float)((double)a2 * a1);
}

//----- (10010D60) --------------------------------------------------------
char *__usercall sub_10010D60@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, char *a6)
{
  _BYTE v7[16]; // [esp+0h] [ebp-10h] BYREF

  sub_10010690((int)v7, 0);
  v7[4] = 0;
  return sub_100106C0(a1, a2, (int)v7, a3, a4, a5, a6);
}

//----- (10010DA0) --------------------------------------------------------
int __usercall sub_10010DA0@<eax>(double a1@<st0>, int a2, unsigned int a3, int *a4)
{
  int v4; // eax
  int v5; // eax
  int v6; // esi

  v4 = sub_10010DF0(a1, a2, a3, a4);
  v5 = off_10033620((int)aWPublicGrannyR_12, 935, 4, v4);
  v6 = v5;
  if ( v5 )
    sub_10011290(a1, a2, a3, a4, v5);
  return v6;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (10010DF0) --------------------------------------------------------
int __usercall sub_10010DF0@<eax>(double a1@<st0>, int a2, unsigned int a3, int *a4)
{
  int v5[4]; // [esp+0h] [ebp-10h] BYREF

  sub_10010690((int)v5, 0);
  v5[0] = (int)sub_1001D790(0x10000);
  sub_10010E40(a1, (int)v5, a2, a3, a4, 0);
  sub_1001D810(v5[0]);
  return v5[2];
}

//----- (10010E40) --------------------------------------------------------
char *__usercall sub_10010E40@<eax>(double a1@<st0>, int a2, int a3, unsigned int a4, int *a5, char *a6)
{
  char *v6; // esi
  int v7; // eax
  int v9; // [esp+8h] [ebp-4h] BYREF

  v9 = 0;
  if ( !a4 || sub_1001D940(*(unsigned int **)a2, a4, &v9) )
    return (char *)v9;
  v6 = a6;
  if ( !a6 )
  {
    v7 = sub_100019C0(a5);
    v6 = (char *)sub_10010ED0(a2, v7);
    sub_1001D8F0(*(unsigned int **)a2, a4, (int)v6);
  }
  if ( *(_BYTE *)(a2 + 5) )
    sub_100106C0(a4, a1, a2, a3, a4, (int)a5, v6);
  sub_10010F00(a2, a3, a4, a5, v6);
  return v6;
}

//----- (10010ED0) --------------------------------------------------------
int __cdecl sub_10010ED0(int a1, int a2)
{
  int v2; // edi

  v2 = sub_10010D00(a1);
  sub_10010D20(a1, a2);
  return v2;
}

//----- (10010F00) --------------------------------------------------------
char __cdecl sub_10010F00(int a1, int a2, int a3, int *a4, char *a5)
{
  int v5; // eax
  int *v6; // ebp
  int *v8; // edx
  int *v9; // esi
  int v10; // edi
  int v11; // esi
  _DWORD *v12; // eax
  int v13; // ebp
  _DWORD *v14; // edi
  int v15; // ebp
  int v16; // esi
  int v17; // esi
  _DWORD *v18; // eax
  int i; // ebp
  int v20; // ebp
  _DWORD *v21; // esi
  _DWORD *v22; // eax
  int j; // ebp
  int v24; // eax
  bool v25; // zf
  char *v27; // [esp+10h] [ebp-1Ch]
  int v28; // [esp+14h] [ebp-18h]
  int v29; // [esp+18h] [ebp-14h]
  int v30; // [esp+18h] [ebp-14h]
  int v31; // [esp+1Ch] [ebp-10h]
  int v32; // [esp+1Ch] [ebp-10h]
  int v33; // [esp+1Ch] [ebp-10h]
  int v34; // [esp+20h] [ebp-Ch]
  int v35; // [esp+24h] [ebp-8h]
  int v36; // [esp+24h] [ebp-8h]
  int v37; // [esp+28h] [ebp-4h]
  _DWORD *v38; // [esp+30h] [ebp+4h]
  _DWORD *v39; // [esp+30h] [ebp+4h]
  int v40; // [esp+30h] [ebp+4h]
  _DWORD *v41; // [esp+30h] [ebp+4h]
  int *v42; // [esp+40h] [ebp+14h]

  LOBYTE(v5) = (_BYTE)a5;
  v6 = a4;
  v27 = a5;
  if ( a4 )
  {
    v42 = a4 + 2;
    do
    {
      if ( !*v6 )
        break;
      v37 = sub_10001990((int)v6);
      v5 = sub_10010600(a2, a3, (char *)*(v42 - 1));
      v9 = v8;
      v10 = v5;
      if ( v8 )
      {
        v5 = *v6;
        if ( *(_DWORD *)v10 == *v6 )
        {
          switch ( --v5 )
          {
            case 0:
              LOBYTE(v5) = sub_10001BF0(*(_DWORD **)(v10 + 8), *v42);
              if ( !(_BYTE)v5 )
                LOBYTE(v5) = sub_10010F00(a1, *(_DWORD *)(v10 + 8), v9, *v42, v27);
              break;
            case 1:
              v11 = *v8;
              v38 = sub_10011270(a1, v27);
              LOBYTE(v5) = sub_10001BF0(*(_DWORD **)(v10 + 8), *v42);
              if ( !(_BYTE)v5 )
              {
                v5 = sub_10010E40(a1, *(_DWORD *)(v10 + 8), v11, *v42, 0);
                *v38 = v5;
              }
              break;
            case 2:
              LOBYTE(v5) = sub_10001BF0(*(_DWORD **)(v10 + 8), *v42);
              if ( !(_BYTE)v5 )
              {
                v29 = sub_10001B90(v10);
                v5 = sub_10001B90((int)a4);
                v15 = *v9;
                v16 = v9[1];
                v28 = v5;
                v40 = v16;
                if ( v15 )
                {
                  if ( v16 )
                  {
                    v35 = sub_100019C0(*(_DWORD **)(v10 + 8));
                    v34 = sub_100019C0((_DWORD *)*v42);
                    v17 = sub_10010ED0(a1, v28 * v15 * v34);
                    v18 = sub_10011270(a1, v27);
                    *v18 = v15;
                    v18[1] = v17;
                    v32 = v15;
                    do
                    {
                      LOBYTE(v5) = v29;
                      for ( i = 0; i < v29; ++i )
                      {
                        if ( i < v28 )
                        {
                          sub_10010E40(a1, *(_DWORD *)(v10 + 8), v40, *v42, v17);
                          v17 += v34;
                        }
                        v40 += v35;
                        LOBYTE(v5) = v29;
                      }
                      --v32;
                    }
                    while ( v32 );
                  }
                }
              }
              break;
            case 3:
              LOBYTE(v5) = sub_10001BF0(*(_DWORD **)(v10 + 8), *v42);
              if ( !(_BYTE)v5 )
              {
                v33 = sub_10001B90(v10);
                v5 = sub_10001B90((int)a4);
                v20 = *v9;
                v21 = (_DWORD *)v9[1];
                v36 = v5;
                if ( v20 )
                {
                  if ( v21 )
                  {
                    v41 = (_DWORD *)sub_10010ED0(a1, 4 * v5 * v20);
                    v22 = sub_10011270(a1, v27);
                    *v22 = v20;
                    v22[1] = v41;
                    v30 = v20;
                    do
                    {
                      LOBYTE(v5) = v33;
                      for ( j = 0; j < v33; ++j )
                      {
                        if ( j < v36 )
                        {
                          v24 = 0;
                          if ( *v21 )
                            v24 = sub_10010E40(a1, *(_DWORD *)(v10 + 8), *v21, *v42, 0);
                          if ( *(_BYTE *)(a1 + 5) )
                            *v41 = v24;
                          ++v41;
                        }
                        LOBYTE(v5) = v33;
                        ++v21;
                      }
                      --v30;
                    }
                    while ( v30 );
                  }
                }
              }
              break;
            case 5:
              v12 = sub_10011270(a1, v27);
              v13 = *v9;
              v39 = v12;
              v14 = *(_DWORD **)(sub_10001BB0((_DWORD *)v10) + 4 * v13);
              v31 = *(_DWORD *)(sub_10001BB0(a4) + 4 * v13);
              *v39 = v13;
              LOBYTE(v5) = sub_10001BF0(v14, v31);
              if ( !(_BYTE)v5 )
              {
                v5 = sub_10010E40(a1, v14, v9[1], v31, 0);
                v39[1] = v5;
              }
              break;
            default:
              break;
          }
        }
      }
      v6 = a4 + 8;
      v25 = a4 + 8 == 0;
      v27 += v37;
      a4 += 8;
      v42 += 8;
    }
    while ( !v25 );
  }
  return v5;
}
// 10010F51: variable 'v8' is possibly undefined
// 10010E40: using guessed type _DWORD __cdecl sub_10010E40(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10011270) --------------------------------------------------------
void *__cdecl sub_10011270(int a1, void *a2)
{
  void *result; // eax

  result = a2;
  if ( !*(_BYTE *)(a1 + 5) )
    return &unk_100362C0;
  return result;
}

//----- (10011290) --------------------------------------------------------
char *__usercall sub_10011290@<eax>(double a1@<st0>, int a2, unsigned int a3, int *a4, int a5)
{
  char *v5; // esi
  unsigned int *v7[4]; // [esp+8h] [ebp-48h] BYREF
  _DWORD v8[14]; // [esp+18h] [ebp-38h] BYREF

  sub_10010690((int)v7, a5);
  v7[0] = sub_1001D790(0x10000);
  v5 = sub_10010E40(a1, (int)v7, a2, a3, a4, 0);
  if ( v7[0] )
  {
    sub_10019420((int)a4, (int)v5, v8);
    sub_10011310(v7[0], (int)v8);
  }
  sub_1001D810((int)v7[0]);
  return v5;
}

//----- (10011310) --------------------------------------------------------
char __cdecl sub_10011310(unsigned int *a1, int a2)
{
  char result; // al
  int v3[14]; // [esp+4h] [ebp-150h] BYREF
  int v4[14]; // [esp+3Ch] [ebp-118h] BYREF
  _DWORD v5[14]; // [esp+74h] [ebp-E0h] BYREF
  _DWORD v6[14]; // [esp+ACh] [ebp-A8h] BYREF
  _DWORD v7[14]; // [esp+E4h] [ebp-70h] BYREF
  _DWORD v8[14]; // [esp+11Ch] [ebp-38h] BYREF

  result = sub_10001A70(*(_DWORD **)(a2 + 4));
  if ( result )
  {
    for ( result = sub_100195B0((_DWORD *)a2); result; result = sub_100195B0((_DWORD *)a2) )
    {
      switch ( *(_DWORD *)(a2 + 16) )
      {
        case 1:
          sub_10019620(a2, v8);
          sub_10011310(a1, v8);
          break;
        case 2:
        case 5:
        case 6:
          sub_100114D0(a1, *(unsigned int **)(a2 + 44));
          sub_10019620(a2, v5);
          sub_10011310(a1, v5);
          break;
        case 3:
        case 7:
          sub_10019680(a2, v3);
          if ( sub_10001A70((_DWORD *)v3[1]) && sub_100195B0(v3) )
          {
            do
            {
              sub_10019710((int)v3, v7);
              sub_10011310(a1, v7);
              sub_100195E0(v3);
            }
            while ( sub_100195B0(v3) );
          }
          break;
        case 4:
          sub_10019680(a2, v4);
          while ( sub_100195B0(v4) )
          {
            sub_10019710((int)v4, v6);
            sub_100114D0(a1, (unsigned int *)v4[11]);
            sub_10011310(a1, v6);
            sub_100195E0(v4);
          }
          break;
        default:
          break;
      }
      sub_100195E0((int *)a2);
    }
  }
  return result;
}

//----- (100114D0) --------------------------------------------------------
char __cdecl sub_100114D0(unsigned int *a1, unsigned int *a2)
{
  _DWORD *v2; // esi
  unsigned int v3; // eax

  v2 = a2;
  v3 = *a2;
  if ( *a2 )
  {
    a2 = 0;
    LOBYTE(v3) = sub_1001D940(a1, v3, &a2);
    if ( (_BYTE)v3 )
    {
      LOBYTE(v3) = (_BYTE)a2;
      *v2 = a2;
    }
  }
  return v3;
}

//----- (10011510) --------------------------------------------------------
int __cdecl sub_10011510(int a1, int a2, int a3)
{
  unsigned int *v3; // edi
  int v4; // ecx
  _DWORD *v5; // eax
  int v7; // [esp+8h] [ebp-4h] BYREF

  v3 = sub_1001D790(0x40000);
  sub_10019A60(&v7, 52);
  sub_10019BC0(v7, 20, 28, 0x20000, 24);
  sub_10019BC0(v7, 36, 40, 0x40000, 8);
  sub_10019BC0(v7, 44, 48, 1024, 4);
  if ( sub_10019C60((int)aWPublicGrannyR_15, 146) && v3 )
  {
    *(_DWORD *)v7 = a1;
    *(_DWORD *)(v7 + 4) = a2;
    *(_DWORD *)(v7 + 8) = 0;
    *(_DWORD *)(v7 + 12) = 0;
    *(_DWORD *)(v7 + 16) = a3;
    *(_DWORD *)(v7 + 24) = 0;
    *(_DWORD *)(v7 + 32) = v3;
    v4 = *(_DWORD *)(v7 + 24);
    v5 = (_DWORD *)(*(_DWORD *)(v7 + 28) + 24 * v4);
    *(_DWORD *)(v7 + 24) = v4 + 1;
    *v5 = 0;
    v5[1] = *(_DWORD *)(v7 + 16);
    v5[2] = 0;
    v5[3] = 0;
    v5[5] = *(_DWORD *)(v7 + 16);
    sub_1001D830(*(unsigned int **)(v7 + 32), 0, (int)v5);
    return v7;
  }
  else
  {
    off_10033624((int)aWPublicGrannyR_15, 170, (int)v3);
    off_10033624((int)aWPublicGrannyR_15, 171, v7);
    return v7;
  }
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10011650) --------------------------------------------------------
int __cdecl sub_10011650(int a1)
{
  int result; // eax

  if ( a1 )
  {
    off_10033624((int)aWPublicGrannyR_15, 182, *(_DWORD *)(a1 + 32));
    return off_10033624((int)aWPublicGrannyR_15, 183, a1);
  }
  return result;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10011690) --------------------------------------------------------
int __cdecl sub_10011690(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 12) = a2;
  return result;
}

//----- (100116A0) --------------------------------------------------------
int __cdecl sub_100116A0(int a1, unsigned int a2, int a3)
{
  int result; // eax

  result = sub_100116C0(a1, 0, a2);
  *(_DWORD *)(result + 20) = a3;
  return result;
}

//----- (100116C0) --------------------------------------------------------
int __cdecl sub_100116C0(int a1, int a2, unsigned int a3)
{
  unsigned int *v3; // ecx
  int v5; // eax
  int v6; // esi
  int v7; // [esp+Ch] [ebp-4h] BYREF

  v3 = *(unsigned int **)(a1 + 32);
  v7 = 0;
  if ( sub_1001D940(v3, a3, &v7) )
    return v7;
  v5 = *(_DWORD *)(a1 + 24);
  v6 = *(_DWORD *)(a1 + 28) + 24 * v5;
  *(_DWORD *)(a1 + 24) = v5 + 1;
  *(_BYTE *)(v6 + 16) = 0;
  *(_DWORD *)v6 = 0;
  *(_DWORD *)(v6 + 4) = *(_DWORD *)(sub_100116C0(a1, 0, a2) + 20);
  *(_DWORD *)(v6 + 12) = 0;
  *(_DWORD *)(v6 + 8) = 0;
  *(_DWORD *)(v6 + 20) = *(_DWORD *)(a1 + 16);
  sub_1001D830(*(unsigned int **)(a1 + 32), a3, v6);
  return v6;
}

//----- (10011740) --------------------------------------------------------
int __cdecl sub_10011740(int a1, unsigned int a2, int a3)
{
  int result; // eax

  result = sub_100116C0(a1, 0, a2);
  *(_DWORD *)(result + 4) = a3;
  *(_BYTE *)(result + 16) = 1;
  return result;
}

//----- (10011760) --------------------------------------------------------
char __cdecl sub_10011760(int a1, _DWORD *a2)
{
  int *v3; // edi
  int v4; // ecx
  int v5; // edx
  _DWORD **v6; // eax
  unsigned __int8 *v7; // ecx
  int *v8; // edx
  int *v9; // eax
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // edi
  int v12; // eax
  int v13; // esi
  _DWORD *v14; // ebp
  int v15; // eax
  _DWORD *v16; // eax
  _DWORD *v17; // edx
  _DWORD **v18; // esi
  _DWORD *v20; // [esp+10h] [ebp-3Ch]
  _DWORD v21[3]; // [esp+14h] [ebp-38h] BYREF
  int v22[3]; // [esp+20h] [ebp-2Ch] BYREF
  int v23; // [esp+2Ch] [ebp-20h] BYREF
  _DWORD *v24; // [esp+30h] [ebp-1Ch]
  int *v25; // [esp+34h] [ebp-18h]
  int v26; // [esp+38h] [ebp-14h]
  int v27; // [esp+3Ch] [ebp-10h]
  int v28; // [esp+40h] [ebp-Ch]
  int v29; // [esp+44h] [ebp-8h]
  _DWORD **v30; // [esp+48h] [ebp-4h]
  _DWORD *v31; // [esp+50h] [ebp+4h]
  _DWORD *v32; // [esp+54h] [ebp+8h]

  ++*(_DWORD *)(a1 + 8);
  v3 = (int *)sub_100226C0(0, 0x10000, 0x40000);
  if ( !v3 )
  {
    sub_10017FE0(3, 8, "%s(%d): Unable to create file string table builder", aWPublicGrannyR_15, 747);
    return 0;
  }
  v4 = *(_DWORD *)(a1 + 32);
  v5 = *(_DWORD *)(a1 + 40);
  v24 = a2;
  v6 = *(_DWORD ***)(a1 + 48);
  v26 = v4;
  v7 = *(unsigned __int8 **)(a1 + 4);
  v28 = v5;
  v8 = *(int **)a1;
  v30 = v6;
  v23 = a1;
  v25 = v3;
  v27 = 0;
  v29 = 0;
  v32 = sub_10011B70(&v23, v8, v7);
  v9 = (int *)&unk_100360AC;
  if ( (*(_BYTE *)(a1 + 12) & 1) == 0 )
    v9 = *(int **)a1;
  v20 = sub_10011950((int)&v23, v9);
  v10 = (unsigned __int8 *)sub_10022770(v3);
  v11 = v10;
  if ( !v10 )
  {
    sub_10017FE0(3, 8, "%s(%d): Unable to complete string table", aWPublicGrannyR_15, 741);
    return 0;
  }
  v31 = sub_10011B70(&v23, &dword_100345B8, v10);
  v12 = sub_100116C0(a1, 0, *((_DWORD *)v11 + 3));
  v13 = v28;
  if ( v27 )
  {
    v14 = (_DWORD *)(v12 + 4);
    do
    {
      --v27;
      v15 = sub_100226A0(v11, *(_DWORD *)(v13 + 4));
      v16 = sub_10013E00(v22, (int)v24, v14, v15);
      v21[0] = *v16;
      v21[1] = v16[1];
      v17 = *(_DWORD **)v13;
      v21[2] = v16[2];
      sub_10013F50((int)v24, v17, v21);
      v13 += 8;
    }
    while ( v27 );
  }
  v18 = v30;
  --v27;
  for ( ; v29; ++v18 )
  {
    --v29;
    sub_10013F50((int)v24, *v18, v31 + 1);
  }
  --v29;
  sub_10014080(v24, v20 + 1, v32 + 1);
  off_10033624((int)aWPublicGrannyR_15, 734, (int)v11);
  return 1;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);
// 100345B8: using guessed type int dword_100345B8;

//----- (10011950) --------------------------------------------------------
_DWORD *__cdecl sub_10011950(int a1, int *a2)
{
  _DWORD *v4; // edi
  DWORD v5; // eax
  int v6; // ecx
  unsigned int *v7; // edi
  int *v8; // eax
  unsigned int v9; // ecx
  int v10; // edx
  int v11; // eax
  int v12; // ebp
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  unsigned __int8 *v17; // eax
  _DWORD *v18; // eax
  int v19; // eax
  int v21; // [esp+10h] [ebp-10h]
  int v22[3]; // [esp+14h] [ebp-Ch] BYREF
  _DWORD *v23; // [esp+24h] [ebp+4h]
  _DWORD *v24; // [esp+28h] [ebp+8h]

  v4 = (_DWORD *)sub_100116C0(*(_DWORD *)a1, 0, (unsigned int)a2);
  v24 = v4;
  if ( !sub_10011A90(a1, v4) )
    return v4;
  v5 = sub_100019F0(a2);
  v6 = v4[1];
  v7 = v4 + 1;
  v8 = sub_10013C10(v22, *(_DWORD *)(a1 + 4), v6, 4, v5, (unsigned __int8 *)a2);
  v9 = *v8;
  v10 = v8[1];
  v11 = v8[2];
  *v7 = v9;
  v7[1] = v10;
  v7[2] = v11;
  if ( a2 )
  {
    v12 = 2;
    do
    {
      if ( !a2[v12 - 2] )
        break;
      v13 = sub_100228F0(*(int **)(a1 + 8), (_BYTE *)a2[v12 - 1]);
      v14 = *(_DWORD *)(a1 + 20);
      v21 = v13;
      v15 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 16) = v15 + 1;
      v23 = (_DWORD *)(v14 + 8 * v15);
      *v23 = sub_10013E30(*(_DWORD **)(a1 + 4), v7, v12 * 4 - 4, v7);
      v23[1] = v21;
      v16 = a2[v12 - 2];
      if ( v16 > 0 )
      {
        if ( v16 <= 4 )
        {
          v19 = sub_10011950(a1, a2[v12]);
          sub_10013E30(*(_DWORD **)(a1 + 4), v7, v12 * 4, (unsigned int *)(v19 + 4));
        }
        else if ( v16 == 6 )
        {
          v17 = (unsigned __int8 *)sub_10001BB0(&a2[v12 - 2]);
          v18 = sub_10011AB0((int *)a1, v17);
          sub_10013E30(*(_DWORD **)(a1 + 4), v7, v12 * 4, v18 + 1);
        }
      }
      v12 += 8;
    }
    while ( &a2[v12] != (int *)8 );
  }
  return v24;
}

//----- (10011A90) --------------------------------------------------------
char __cdecl sub_10011A90(int a1, _DWORD *a2)
{
  int v2; // eax

  v2 = *(_DWORD *)(*(_DWORD *)a1 + 8);
  if ( *a2 == v2 )
    return 0;
  *a2 = v2;
  return 1;
}

//----- (10011AB0) --------------------------------------------------------
_DWORD *__cdecl sub_10011AB0(int *a1, unsigned __int8 *a2)
{
  _DWORD *v3; // ebx
  int v4; // eax
  int v5; // edx
  int v6; // edi
  unsigned int *v7; // ebx
  int *v8; // eax
  unsigned int v9; // ecx
  int v10; // edx
  int v11; // eax
  int i; // esi
  int v13; // eax
  int v15[3]; // [esp+10h] [ebp-Ch] BYREF
  _DWORD *v16; // [esp+20h] [ebp+4h]

  v3 = (_DWORD *)sub_100116C0(*a1, 0, (unsigned int)a2);
  v16 = v3;
  if ( !sub_10011A90((int)a1, v3) )
    return v3;
  v4 = sub_10001BD0(a2);
  v5 = v3[1];
  v6 = v4;
  v7 = v3 + 1;
  v8 = sub_10013C10(v15, a1[1], v5, 4, 4 * v4 + 4, a2);
  v9 = *v8;
  v10 = v8[1];
  v11 = v8[2];
  *v7 = v9;
  v7[1] = v10;
  v7[2] = v11;
  for ( i = 0; i < v6; ++i )
  {
    v13 = sub_10011950(a1, *(_DWORD *)&a2[4 * i]);
    sub_10013E30((_DWORD *)a1[1], v7, 4 * i, (unsigned int *)(v13 + 4));
  }
  return v16;
}
// 10011950: using guessed type _DWORD __cdecl sub_10011950(_DWORD, _DWORD);

//----- (10011B70) --------------------------------------------------------
_DWORD *__cdecl sub_10011B70(int *a1, int *a2, unsigned __int8 *a3)
{
  _DWORD *v5; // esi
  int v6; // eax
  int v7; // ecx
  int v8; // ebx
  unsigned int *v9; // esi
  int *v10; // eax
  unsigned int v11; // ecx
  int v12; // edx
  unsigned int v13; // ecx
  _DWORD *v14; // eax
  int v16; // [esp+Ch] [ebp-Ch] BYREF
  int v17; // [esp+14h] [ebp-4h]
  _DWORD *v18; // [esp+1Ch] [ebp+4h]
  DWORD v19; // [esp+20h] [ebp+8h]

  v5 = (_DWORD *)sub_100116C0(*a1, (int)a2, (unsigned int)a3);
  v18 = v5;
  if ( !sub_10011A90((int)a1, v5) )
    return v5;
  v19 = sub_100019C0(a2);
  v6 = sub_10001AD0(a2);
  v7 = v5[1];
  v8 = v6;
  v9 = v5 + 1;
  v10 = sub_10013C10(&v16, a1[1], v7, v6, v19, a3);
  v11 = *v10;
  v12 = v10[1];
  v17 = v10[2];
  *v9 = v11;
  v13 = v17;
  v9[1] = v12;
  v9[2] = v13;
  if ( sub_10001B00(v8) )
  {
    v14 = sub_10011950((int)a1, a2);
    sub_10013F70((_DWORD *)a1[1], v14 + 1, v9, 1);
  }
  sub_10011C40((int)a1, a2, v9, (int *)a3);
  return v18;
}

//----- (10011C40) --------------------------------------------------------
unsigned int __cdecl sub_10011C40(int a1, _DWORD *a2, unsigned int *a3, int *a4)
{
  unsigned int v4; // edx
  unsigned int result; // eax
  _DWORD *v7; // esi
  int v8; // edi
  unsigned int *v9; // eax
  unsigned int v10; // ecx
  unsigned int v11; // edx
  bool v12; // zf
  unsigned int v13; // [esp+10h] [ebp-18h] BYREF
  unsigned int v14; // [esp+14h] [ebp-14h]
  unsigned int v15; // [esp+18h] [ebp-10h]
  int v16[3]; // [esp+1Ch] [ebp-Ch] BYREF

  v4 = a3[1];
  result = a3[2];
  v7 = a2;
  v13 = *a3;
  v14 = v4;
  v15 = result;
  if ( a2 )
  {
    do
    {
      if ( !*v7 )
        break;
      v8 = sub_10001990((int)v7);
      sub_10011CD0(a1, (int)v7, &v13, a4);
      a4 = (int *)((char *)a4 + v8);
      v9 = sub_10013E00(v16, *(_DWORD *)(a1 + 4), &v13, v8);
      v10 = *v9;
      v11 = v9[1];
      result = v9[2];
      v12 = v7 + 8 == 0;
      v7 += 8;
      v13 = v10;
      v14 = v11;
      v15 = result;
    }
    while ( !v12 );
  }
  return result;
}

//----- (10011CD0) --------------------------------------------------------
int __cdecl sub_10011CD0(int a1, int a2, unsigned int *a3, int *a4)
{
  int result; // eax
  int v5; // ecx
  int *v6; // esi
  int v7; // eax
  _BYTE *v8; // esi
  int v9; // ebx
  int v10; // eax
  int v11; // eax
  int v12; // ebx
  int *v13; // eax
  _DWORD *v14; // eax
  int v15; // eax
  _DWORD *v17; // eax
  unsigned __int8 *v18; // ebp
  int v19; // eax
  int v20; // eax
  int v21; // esi
  int v22; // esi
  int *v23; // ebp
  int *v24; // eax
  unsigned int v25; // ecx
  unsigned int v26; // edx
  int v27; // eax
  int v28; // eax
  _DWORD *v29; // edx
  int v30; // ebx
  int v31; // eax
  int *v32; // edi
  unsigned int v33[3]; // [esp+10h] [ebp-18h] BYREF
  int v34[3]; // [esp+1Ch] [ebp-Ch] BYREF
  int v35; // [esp+34h] [ebp+Ch]
  int *v36; // [esp+38h] [ebp+10h]

  result = *(_DWORD *)a2 - 1;
  switch ( *(_DWORD *)a2 )
  {
    case 1:
      result = sub_10011C40(a1, *(_DWORD *)(a2 + 8), a3, a4);
      break;
    case 2:
      if ( sub_10021A20(*(_BYTE **)(a2 + 4), aGrannyfilestri) )
      {
        v5 = *(_DWORD *)(a1 + 24);
        v6 = (int *)(*(_DWORD *)(a1 + 28) + 4 * v5);
        *(_DWORD *)(a1 + 24) = v5 + 1;
        result = (int)sub_10013E30(*(_DWORD **)(a1 + 4), a3, 0, a3);
        *v6 = result;
      }
      else
      {
        result = *a4;
        if ( *a4 )
        {
          v7 = sub_10011B70(a1, *(_DWORD *)(a2 + 8), *a4);
          result = (int)sub_10013E30(*(_DWORD **)(a1 + 4), a3, 0, (unsigned int *)(v7 + 4));
        }
      }
      break;
    case 3:
      result = *a4 * sub_10001B90(a2);
      if ( result && a4[1] )
      {
        v20 = sub_10012050((int *)a1, a2, *(int **)(a2 + 8), *a3, result, (unsigned __int8 *)a4[1]);
        result = (int)sub_10013E30(*(_DWORD **)(a1 + 4), a3, 4, (unsigned int *)(v20 + 4));
      }
      break;
    case 4:
      v21 = sub_10001B90(a2);
      result = (int)a4;
      v22 = *a4 * v21;
      v23 = (int *)a4[1];
      if ( v22 && v23 )
      {
        v24 = sub_10013C10(v34, *(_DWORD *)(a1 + 4), *a3, 0, 4 * v22, (unsigned __int8 *)a4[1]);
        v25 = *v24;
        v26 = v24[1];
        v33[2] = v24[2];
        v33[0] = v25;
        v33[1] = v26;
        sub_10013E30(*(_DWORD **)(a1 + 4), a3, 4, v33);
        v35 = 0;
        do
        {
          result = *v23;
          if ( *v23 )
          {
            v27 = sub_10011B70(a1, *(_DWORD *)(a2 + 8), *v23);
            result = (int)sub_10013E30(*(_DWORD **)(a1 + 4), v33, v35, (unsigned int *)(v27 + 4));
          }
          ++v23;
          --v22;
          v35 += 4;
        }
        while ( v22 );
      }
      break;
    case 5:
      v12 = *a4;
      if ( *a4 )
      {
        v13 = (int *)&unk_100360AC;
        if ( (*(_BYTE *)(*(_DWORD *)a1 + 12) & 4) == 0 )
          v13 = (int *)*a4;
        v14 = sub_10011950(a1, v13);
        sub_10013E30(*(_DWORD **)(a1 + 4), a3, 0, v14 + 1);
        result = a4[1];
        if ( result )
        {
          v15 = sub_10011B70(a1, v12, a4[1]);
          result = (int)sub_10013E30(*(_DWORD **)(a1 + 4), a3, 4, (unsigned int *)(v15 + 4));
        }
      }
      break;
    case 6:
      result = (int)a4;
      v8 = (_BYTE *)a4[1];
      v9 = *a4;
      if ( v8 )
      {
        v10 = sub_10001BB0((_DWORD *)a2);
        v11 = sub_10011B70(a1, *(_DWORD *)(v10 + 4 * v9), v8);
        result = (int)sub_10013E30(*(_DWORD **)(a1 + 4), a3, 4, (unsigned int *)(v11 + 4));
      }
      break;
    case 7:
      result = *a4;
      v36 = (int *)*a4;
      if ( v36 )
      {
        if ( (*(_BYTE *)(*(_DWORD *)a1 + 12) & 4) != 0 )
          result = (int)&unk_100360AC;
        v17 = sub_10011950(a1, (int *)result);
        sub_10013E30(*(_DWORD **)(a1 + 4), a3, 0, v17 + 1);
        result = a4[1] * sub_10001B90(a2);
        v18 = (unsigned __int8 *)a4[2];
        if ( result && v18 )
        {
          v19 = sub_10012050((int *)a1, a2, v36, *a3, result, v18);
          result = (int)sub_10013E30(*(_DWORD **)(a1 + 4), a3, 8, (unsigned int *)(v19 + 4));
        }
      }
      break;
    case 8:
      v28 = sub_100228F0(*(int **)(a1 + 8), (_BYTE *)*a4);
      v29 = *(_DWORD **)(a1 + 4);
      v30 = v28;
      v31 = *(_DWORD *)(a1 + 16);
      v32 = (int *)(*(_DWORD *)(a1 + 20) + 8 * v31);
      *(_DWORD *)(a1 + 16) = v31 + 1;
      result = (int)sub_10013E30(v29, a3, 0, a3);
      v32[1] = v30;
      *v32 = result;
      break;
    default:
      return result;
  }
  return result;
}
// 10011B70: using guessed type _DWORD __cdecl sub_10011B70(_DWORD, _DWORD, _DWORD);
// 10011C40: using guessed type _DWORD __cdecl sub_10011C40(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10012050) --------------------------------------------------------
int __cdecl sub_10012050(int *a1, int a2, int *a3, int a4, int a5, unsigned __int8 *a6)
{
  int v7; // edi
  int v8; // ebx
  int v9; // eax
  int v10; // edx
  int v11; // ebp
  unsigned int *v12; // edi
  int *v13; // eax
  unsigned int v14; // ecx
  int v15; // edx
  unsigned int v16; // ecx
  _DWORD *v17; // eax
  int v18; // ebp
  int *v19; // eax
  int v20; // ecx
  int v21; // edx
  int v22; // eax
  bool v23; // zf
  int v25[2]; // [esp+10h] [ebp-18h] BYREF
  int v26; // [esp+18h] [ebp-10h]
  int v27[3]; // [esp+1Ch] [ebp-Ch] BYREF
  int v28; // [esp+2Ch] [ebp+4h]

  v7 = sub_100116C0(*a1, 0, (unsigned int)a6);
  v28 = v7;
  if ( !sub_10011A90((int)a1, (_DWORD *)v7) )
    return v7;
  if ( !*(_BYTE *)(v7 + 16) )
    *(_DWORD *)(v7 + 4) = a4;
  v8 = sub_100019C0(a3);
  v9 = sub_10001AD0(a3);
  v10 = *(_DWORD *)(v7 + 4);
  v11 = v9;
  v12 = (unsigned int *)(v7 + 4);
  v13 = sub_10013C10(v25, a1[1], v10, v9, a5 * v8, a6);
  v14 = *v13;
  v15 = v13[1];
  v26 = v13[2];
  *v12 = v14;
  v16 = v26;
  v12[1] = v15;
  v12[2] = v16;
  if ( sub_10001B00(v11) )
  {
    v17 = sub_10011950((int)a1, a3);
    sub_10013F70((_DWORD *)a1[1], v17 + 1, v12, a5);
  }
  if ( sub_10001A70(a3) )
  {
    v18 = 0;
    if ( a5 )
    {
      do
      {
        v19 = sub_10013E00(v27, a1[1], v12, v18);
        v20 = *v19;
        v21 = v19[1];
        v22 = v19[2];
        v25[0] = v20;
        v25[1] = v21;
        v26 = v22;
        sub_10011C40(a1, a3, v25, a6);
        v18 += v8;
        v23 = a5 == 1;
        a6 += v8;
        --a5;
      }
      while ( !v23 );
    }
  }
  return v28;
}
// 10011C40: using guessed type _DWORD __cdecl sub_10011C40(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100121A0) --------------------------------------------------------
char __cdecl sub_100121A0(int a1, int a2, const CHAR *a3, int a4)
{
  char v4; // bl
  _DWORD *v5; // eax
  int v6; // esi

  v4 = 0;
  v5 = sub_10013200(0, a4, a2, asc_10031764, aWritedatatreet);
  v6 = (int)v5;
  if ( v5 )
  {
    v4 = 1;
    if ( !sub_10011760(a1, v5) )
    {
      v4 = 0;
      sub_10017FE0(3, 8, "%s(%d): Unable to write tree contents to file buffer", aWPublicGrannyR_15, 771);
    }
    if ( !sub_100135C0(v6, a3) )
    {
      sub_10017FE0(3, 8, "%s(%d): Unable to write buffer to file", aWPublicGrannyR_15, 778);
      return 0;
    }
  }
  else
  {
    sub_10017FE0(3, 8, "%s(%d): Unable to create file writing buffer", aWPublicGrannyR_15, 784);
  }
  return v4;
}

//----- (10012250) --------------------------------------------------------
char __cdecl sub_10012250(_DWORD *a1, _DWORD *a2, int a3, _DWORD *a4)
{
  _DWORD *i; // ebp
  char *v5; // esi
  _DWORD *v6; // ebx
  _DWORD *v7; // eax
  int v8; // edi
  int v9; // eax
  _DWORD *v11; // [esp-14h] [ebp-1Ch]
  int v12; // [esp+0h] [ebp-8h]
  int v13; // [esp+4h] [ebp-4h]

  if ( !dword_100368D0 )
  {
    sub_10003DE0();
    sub_10016080();
  }
  v12 = 0;
  if ( dword_100368D0 <= 0 )
    return 0;
  for ( i = &unk_100362DC; ; i += 6 )
  {
    v11 = (_DWORD *)*i;
    v5 = (char *)(i - 3);
    if ( i[2] )
      break;
    if ( sub_10001BF0(a1, (int)v11) && sub_10001BF0(a2, i[1]) )
    {
      qmemcpy(a4, v5, 0x18u);
      return 1;
    }
LABEL_15:
    if ( ++v12 >= dword_100368D0 )
      return 0;
  }
  v6 = sub_10001CD0(a1, v11);
  v7 = sub_10001CD0(a2, (_DWORD *)i[1]);
  v13 = (int)v7;
  if ( !v6 )
    goto LABEL_15;
  if ( !v7 )
    goto LABEL_15;
  v8 = sub_100019C0(v7);
  if ( sub_100019C0(v6) != v8 )
    goto LABEL_15;
  qmemcpy(a4, v5, 0x18u);
  v9 = sub_100019C0(v6);
  a4[5] = v9;
  if ( v9 % 4 )
    goto LABEL_15;
  a4[5] = v9 / 4;
  if ( !sub_10001BF0(v6, v13) )
    sub_10017FE0(
      2,
      41,
      "%s(%d): Using deformer whose tail copy size matches, but whose layout may not be correct.",
      aWPublicGrannyR_36,
      85);
  return 1;
}
// 100368D0: using guessed type int dword_100368D0;

//----- (100123B0) --------------------------------------------------------
int __cdecl sub_100123B0(const void *a1)
{
  int v1; // eax
  int result; // eax

  v1 = dword_100368D0;
  qmemcpy((char *)&unk_100362D0 + 24 * dword_100368D0, a1, 0x18u);
  result = v1 + 1;
  dword_100368D0 = result;
  return result;
}
// 100368D0: using guessed type int dword_100368D0;

//----- (100123E0) --------------------------------------------------------
int __cdecl sub_100123E0(int a1, const void *a2)
{
  int v2; // esi
  const void *v3; // edx
  int result; // eax

  v2 = a1;
  if ( a1 )
  {
    v3 = a2;
    do
    {
      result = sub_100123B0(v3);
      --v2;
    }
    while ( v2 );
  }
  return result;
}
// 100123F6: variable 'v3' is possibly undefined

//----- (10012410) --------------------------------------------------------
int __cdecl sub_10012410(int a1, __int16 a2)
{
  int result; // eax
  long double v3; // st3

  result = a1;
  if ( (a2 & 7) == 0 )
  {
    *(_DWORD *)a1 &= ~1u;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 4) = 0;
LABEL_9:
    *(_DWORD *)(a1 + 12) = 0;
    goto LABEL_10;
  }
  if ( (a2 & 1) == 0 )
    *(_DWORD *)(a1 + 4) = 0;
  if ( (a2 & 2) == 0 )
    *(_DWORD *)(a1 + 8) = 0;
  if ( (a2 & 4) == 0 )
    goto LABEL_9;
LABEL_10:
  if ( (a2 & 0x38) != 0 )
  {
    if ( (a2 & 8) == 0 )
      *(_DWORD *)(a1 + 16) = 0;
    if ( (a2 & 0x10) == 0 )
      *(_DWORD *)(a1 + 20) = 0;
    if ( (a2 & 0x20) == 0 )
      *(_DWORD *)(a1 + 24) = 0;
    v3 = sqrt(
           *(float *)(a1 + 16) * *(float *)(a1 + 16)
         + *(float *)(a1 + 20) * *(float *)(a1 + 20)
         + *(float *)(a1 + 24) * *(float *)(a1 + 24)
         + *(float *)(a1 + 28) * *(float *)(a1 + 28));
    *(float *)(a1 + 16) = 1.0 / v3 * *(float *)(a1 + 16);
    *(float *)(a1 + 20) = 1.0 / v3 * *(float *)(a1 + 20);
    *(float *)(a1 + 24) = 1.0 / v3 * *(float *)(a1 + 24);
    *(float *)(a1 + 28) = 1.0 / v3 * *(float *)(a1 + 28);
  }
  else
  {
    *(_DWORD *)a1 &= ~2u;
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 28) = 1065353216;
  }
  if ( (a2 & 0x1C0) != 0 )
  {
    if ( (a2 & 0x40) == 0 )
    {
      *(_DWORD *)(a1 + 32) = 1065353216;
      *(_DWORD *)(a1 + 44) = 0;
      *(_DWORD *)(a1 + 56) = 0;
    }
    if ( (a2 & 0x80u) == 0 )
    {
      *(_DWORD *)(a1 + 36) = 0;
      *(_DWORD *)(a1 + 48) = 1065353216;
      *(_DWORD *)(a1 + 60) = 0;
    }
    if ( (a2 & 0x100) == 0 )
    {
      *(_DWORD *)(a1 + 40) = 0;
      *(_DWORD *)(a1 + 52) = 0;
      *(_DWORD *)(a1 + 64) = 1065353216;
    }
  }
  else
  {
    *(_DWORD *)a1 &= ~4u;
    *(_DWORD *)(a1 + 32) = 1065353216;
    *(_DWORD *)(a1 + 36) = 0;
    *(_DWORD *)(a1 + 44) = 0;
    *(_DWORD *)(a1 + 48) = 1065353216;
    *(_DWORD *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 60) = 0;
    *(_DWORD *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 52) = 0;
    *(_DWORD *)(a1 + 64) = 1065353216;
  }
  return result;
}

//----- (10012520) --------------------------------------------------------
int __cdecl sub_10012520(int a1, int a2, int a3)
{
  void *v3; // edi
  int v5; // ebp
  int *v6; // esi
  int v7; // eax
  unsigned int *v8; // ebp
  _DWORD *v9; // eax
  __int64 v10; // rcx
  int v11; // esi
  int v12; // esi
  int v13; // eax
  int result; // eax
  unsigned __int64 v15; // [esp+10h] [ebp-10h]
  unsigned __int64 v16; // [esp+18h] [ebp-8h]
  int v17; // [esp+28h] [ebp+8h]

  if ( (byte_100368D8 & 1) == 0 )
  {
    byte_100368D8 |= 1u;
    dword_100368E4 = (int)sub_100218A0((int)aReadfilesectio);
  }
  v3 = off_1003440C;
  off_1003440C = (_UNKNOWN *)dword_100368E4;
  v15 = __rdtsc();
  if ( *(_DWORD *)(a2 + 4) )
  {
    v5 = a3;
    if ( a3 < 0 || a3 >= *(_DWORD *)(a2 + 8) )
    {
      sub_10017FE0(
        3,
        9,
        "%s(%d): SectionIndex %d is out of range [0, %d)",
        aWPublicGrannyR_23,
        87,
        a3,
        *(_DWORD *)(a2 + 8));
      v16 = __rdtsc();
    }
    else
    {
      if ( *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4 * a3) )
      {
        sub_10017FE0(
          2,
          9,
          "%s(%d): Ignored request to read already populated file section %d",
          aWPublicGrannyR_23,
          149,
          a3);
      }
      else
      {
        v6 = (int *)(44 * a3 + sub_100144F0(*(_DWORD *)(a2 + 4)));
        if ( v6[3] )
        {
          sub_10019A50(v6[4]);
          sub_10019A60((_DWORD *)(4 * a3 + *(_DWORD *)(a2 + 12)), v6[3]);
          if ( sub_10019C60((int)aWPublicGrannyR_23, 100) )
          {
            v17 = *v6;
            if ( *v6 )
            {
              v7 = sub_100140C0(*v6);
              v8 = (unsigned int *)off_10033620((int)aWPublicGrannyR_23, 118, 4, v6[2] + v7);
              if ( v8 && *(_DWORD *)(4 * a3 + *(_DWORD *)(a2 + 12)) )
              {
                sub_100127B0(v6[1], a1, *(_BYTE *)a2, v6[2], v8);
                sub_100140D0(v17, v6[2], v8, v6[5], v6[6], v6[3], *(_BYTE **)(4 * a3 + *(_DWORD *)(a2 + 12)));
              }
              off_10033624((int)aWPublicGrannyR_23, 131, (int)v8);
              v5 = a3;
            }
            else if ( *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4 * a3) )
            {
              sub_100127B0(v6[1], a1, 0, v6[2], *(unsigned int **)(*(_DWORD *)(a2 + 12) + 4 * a3));
            }
            if ( *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4 * v5) && *(_BYTE *)a2 )
              sub_10014500(v6[5], v6[6], v6[3], *(unsigned int **)(*(_DWORD *)(a2 + 12) + 4 * v5));
            *(_BYTE *)(*(_DWORD *)(a2 + 16) + v5) = *(_BYTE *)a2 == 0;
          }
        }
      }
      v16 = __rdtsc();
    }
  }
  else
  {
    sub_10017FE0(3, 9, "%s(%d): File.Header is not allowed to be 0", aWPublicGrannyR_23, 86);
    v16 = __rdtsc();
  }
  v9 = off_1003440C;
  LODWORD(v10) = v16 - v15;
  HIDWORD(v10) = *((_DWORD *)off_1003440C + 3);
  v11 = *((_DWORD *)off_1003440C + 1) + 1;
  *((_QWORD *)off_1003440C + 1) = v10 + __PAIR64__((v16 - v15) >> 32, *((_DWORD *)off_1003440C + 2));
  v9[1] = v11;
  off_1003440C = v3;
  v12 = *((_DWORD *)v3 + 4);
  v13 = *((_DWORD *)v3 + 5);
  *((_DWORD *)v3 + 4) = v16 - v15 + v12;
  result = ((v16 - v15) >> 32) + __CFADD__(v16 - v15, v12) + v13;
  *((_DWORD *)v3 + 5) = result;
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);
// 1003440C: using guessed type _UNKNOWN *off_1003440C;
// 100368D8: using guessed type char byte_100368D8;
// 100368E4: using guessed type int dword_100368E4;

//----- (100127B0) --------------------------------------------------------
char __cdecl sub_100127B0(int a1, int a2, char a3, int a4, unsigned int *a5)
{
  if ( (*(int (__cdecl **)(char *, int, int, int, int, unsigned int *))(a2 + 12))(
         aWPublicGrannyR_23,
         68,
         a2,
         a1,
         a4,
         a5) != a4 )
    return 0;
  if ( a3 )
    sub_10019E80(a4, a5);
  return 1;
}

//----- (10012800) --------------------------------------------------------
int __cdecl sub_10012800(int a1, int a2, int a3)
{
  void *v3; // ebx
  int *v5; // esi
  int v6; // eax
  unsigned int *v7; // eax
  int v8; // eax
  unsigned int *v9; // eax
  _DWORD *v10; // eax
  int v11; // esi
  int v12; // esi
  int v13; // eax
  int result; // eax
  unsigned __int64 v15; // [esp+10h] [ebp-10h]
  unsigned __int64 v16; // [esp+18h] [ebp-8h]
  int *v17; // [esp+28h] [ebp+8h]
  unsigned int *v18; // [esp+28h] [ebp+8h]

  if ( (byte_100368DB & 1) == 0 )
  {
    byte_100368DB |= 1u;
    dword_100368E0 = (int)sub_100218A0((int)aFixupfilesecti);
  }
  v3 = off_1003440C;
  off_1003440C = (_UNKNOWN *)dword_100368E0;
  v15 = __rdtsc();
  if ( *(_DWORD *)(a2 + 4) )
  {
    if ( a3 < 0 || a3 >= *(_DWORD *)(a2 + 8) )
    {
      sub_10017FE0(
        3,
        9,
        "%s(%d): SectionIndex %d is out of range [0, %d)",
        aWPublicGrannyR_23,
        159,
        a3,
        *(_DWORD *)(a2 + 8));
      v16 = __rdtsc();
    }
    else
    {
      v5 = (int *)(44 * a3 + sub_100144F0(*(_DWORD *)(a2 + 4)));
      if ( *(_BYTE *)a2 )
      {
        v6 = v5[10];
        if ( v6 )
        {
          if ( !*(_BYTE *)(*(_DWORD *)(a2 + 16) + a3) )
          {
            v7 = (unsigned int *)off_10033620((int)aWPublicGrannyR_23, 172, 4, 16 * v6);
            v17 = (int *)v7;
            if ( v7 )
            {
              sub_100127B0(v5[9], a1, *(_BYTE *)a2, 16 * v5[10], v7);
              sub_10014580(v5[10], v17, *(_DWORD *)(a2 + 12), *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4 * a3));
              *(_BYTE *)(*(_DWORD *)(a2 + 16) + a3) = 1;
              off_10033624((int)aWPublicGrannyR_23, 185, (int)v17);
            }
          }
        }
      }
      v8 = v5[8];
      if ( v8 )
      {
        v9 = (unsigned int *)off_10033620((int)aWPublicGrannyR_23, 192, 4, 12 * v8);
        v18 = v9;
        if ( v9 )
        {
          sub_100127B0(v5[7], a1, *(_BYTE *)a2, 12 * v5[8], v9);
          sub_10014530((_DWORD *)v5[8], v18, *(_DWORD *)(a2 + 12), *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4 * a3));
          off_10033624((int)aWPublicGrannyR_23, 204, (int)v18);
        }
      }
      v16 = __rdtsc();
    }
  }
  else
  {
    sub_10017FE0(3, 9, "%s(%d): File.Header is not allowed to be 0", aWPublicGrannyR_23, 158);
    v16 = __rdtsc();
  }
  v10 = off_1003440C;
  v11 = *((_DWORD *)off_1003440C + 1) + 1;
  *((_QWORD *)off_1003440C + 1) += v16 - v15;
  v10[1] = v11;
  off_1003440C = v3;
  v12 = *((_DWORD *)v3 + 4);
  v13 = *((_DWORD *)v3 + 5);
  *((_DWORD *)v3 + 4) = v16 - v15 + v12;
  result = ((v16 - v15) >> 32) + __CFADD__(v16 - v15, v12) + v13;
  *((_DWORD *)v3 + 5) = result;
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);
// 1003440C: using guessed type _UNKNOWN *off_1003440C;
// 100368DB: using guessed type char byte_100368DB;
// 100368E0: using guessed type int dword_100368E0;

//----- (10012A30) --------------------------------------------------------
bool __cdecl sub_10012A30(LPCSTR lpFileName)
{
  const char *v1; // esi
  int v3; // edi
  int v4; // eax
  int v5; // esi
  int v6; // ebp
  int v7; // eax
  unsigned __int8 *v8; // ebx
  int i; // esi
  bool v10; // [esp+7h] [ebp-9h]
  int v11; // [esp+8h] [ebp-8h] BYREF
  int v12; // [esp+Ch] [ebp-4h]

  v1 = lpFileName;
  v10 = 0;
  if ( lpFileName )
  {
    v3 = off_10032074((int)aWPublicGrannyR_23, 270, lpFileName);
    if ( v3 )
    {
      LOBYTE(lpFileName) = 0;
      v4 = sub_10012BB0(v3, 0, (char *)&lpFileName);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        v6 = *(_DWORD *)(v4 + 12) + 32;
        sub_100105A0(&v11);
        v7 = off_10033620((int)aWPublicGrannyR_23, 283, 4, 0x10000);
        v8 = (unsigned __int8 *)v7;
        if ( v7 )
        {
          for ( i = (*(int (__cdecl **)(char *, int, int, int, int, int))(v3 + 12))(
                      aWPublicGrannyR_23,
                      288,
                      v3,
                      v6,
                      0x10000,
                      v7);
                i;
                i = (*(int (__cdecl **)(char *, int, int, int, int, unsigned __int8 *))(v3 + 12))(
                      aWPublicGrannyR_23,
                      288,
                      v3,
                      v6,
                      0x10000,
                      v8) )
          {
            sub_100105B0(&v11, i, v8);
            v6 += i;
          }
          sub_100105F0(&v11);
          v10 = *(_DWORD *)(v12 + 8) == v11;
          v5 = v12;
        }
        off_10033624((int)aWPublicGrannyR_23, 297, (int)v8);
      }
      off_10033624((int)aWPublicGrannyR_23, 300, v5);
      (*(void (__cdecl **)(char *, int, int))(v3 + 8))(aWPublicGrannyR_23, 301, v3);
      return v10;
    }
    else
    {
      sub_10017FE0(3, 9, "%s(%d): Unable to open %s for reading", aWPublicGrannyR_23, 306, v1);
      return 0;
    }
  }
  else
  {
    sub_10017FE0(3, 9, "%s(%d): FileName is not allowed to be 0", aWPublicGrannyR_23, 268);
    return 0;
  }
}
// 10032074: using guessed type int (__cdecl *off_10032074)(int, int, LPCSTR lpFileName);
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10012BB0) --------------------------------------------------------
int __cdecl sub_10012BB0(int a1, int a2, char *a3)
{
  int v3; // ebx
  char *v4; // ebp
  unsigned int *v5; // eax
  int v6; // esi
  _BYTE v8[20]; // [esp+10h] [ebp-20h] BYREF
  int v9; // [esp+24h] [ebp-Ch]

  v3 = a2;
  if ( (*(int (__cdecl **)(char *, int, int, int, int, _BYTE *))(a1 + 12))(aWPublicGrannyR_23, 213, a1, a2, 32, v8) != 32 )
  {
    sub_10017FE0(3, 9, "%s(%d): Unable to read magic value", aWPublicGrannyR_23, 258);
    return 0;
  }
  v4 = a3;
  if ( !sub_10014460((int)v8, (unsigned int *)&a2, a3) )
  {
    sub_10017FE0(3, 9, "%s(%d): File is not a Granny file", aWPublicGrannyR_23, 252);
    return 0;
  }
  if ( v9 )
  {
    sub_10017FE0(3, 9, "%s(%d): File has an unrecognized header format (%d)", aWPublicGrannyR_23, 246, v9);
    return 0;
  }
  v5 = (unsigned int *)off_10033620((int)aWPublicGrannyR_23, 224, 4, a2);
  v6 = (int)v5;
  if ( !v5 )
    return 0;
  if ( sub_100127B0(v3 + 32, a1, *v4, a2, v5) )
    return v6;
  sub_10017FE0(3, 9, "%s(%d): Unable to read file header", aWPublicGrannyR_23, 236);
  off_10033624((int)aWPublicGrannyR_23, 239, v6);
  return 0;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10012CF0) --------------------------------------------------------
int __cdecl sub_10012CF0(LPCSTR lpFileName)
{
  void *v1; // esi
  int v2; // ebx
  unsigned __int64 v3; // kr00_8
  _DWORD *v4; // eax
  int v5; // edi
  int v6; // ebx
  int v8; // eax
  int v9; // edi
  unsigned __int64 v10; // kr08_8
  _QWORD *v11; // eax
  unsigned __int64 v12; // [esp+Ch] [ebp-10h]

  if ( (byte_100368DA & 1) == 0 )
  {
    byte_100368DA |= 1u;
    dword_100368DC = (int)sub_100218A0((int)aReadentirefile);
  }
  v1 = off_1003440C;
  off_1003440C = (_UNKNOWN *)dword_100368DC;
  v12 = __rdtsc();
  v2 = 0;
  if ( lpFileName )
  {
    v8 = off_10032074((int)aWPublicGrannyR_23, 320, lpFileName);
    v9 = v8;
    if ( v8 )
    {
      v2 = sub_10012E90(v8);
      (*(void (__cdecl **)(char *, int, int))(v9 + 8))(aWPublicGrannyR_23, 324, v9);
    }
    v10 = __rdtsc() - v12;
    v11 = off_1003440C;
    ++*((_DWORD *)off_1003440C + 1);
    v11[1] += v10;
    off_1003440C = v1;
    *((_QWORD *)v1 + 2) += v10;
    return v2;
  }
  else
  {
    sub_10017FE0(3, 9, "%s(%d): FileName is not allowed to be 0", aWPublicGrannyR_23, 318);
    v3 = __rdtsc() - v12;
    v4 = off_1003440C;
    v5 = *((_DWORD *)off_1003440C + 2);
    ++*((_DWORD *)off_1003440C + 1);
    v6 = v4[3];
    v4[2] = v3 + v5;
    v4[3] = HIDWORD(v3) + __CFADD__((_DWORD)v3, v5) + v6;
    off_1003440C = v1;
    *((_QWORD *)v1 + 2) += v3;
    return 0;
  }
}
// 10032074: using guessed type int (__cdecl *off_10032074)(int, int, LPCSTR lpFileName);
// 1003440C: using guessed type _UNKNOWN *off_1003440C;
// 100368DA: using guessed type char byte_100368DA;
// 100368DC: using guessed type int dword_100368DC;

//----- (10012E40) --------------------------------------------------------
int __cdecl sub_10012E40(int a1, int a2)
{
  int v2; // edi
  _DWORD *v3; // eax
  _DWORD *v4; // esi

  v2 = 0;
  v3 = sub_1001A090((int)aWPublicGrannyR_23, 335, 0, a1, a2);
  v4 = v3;
  if ( v3 )
  {
    v2 = sub_10012E90((int)v3);
    ((void (__cdecl *)(char *, int, _DWORD *))v4[2])(aWPublicGrannyR_23, 340, v4);
  }
  return v2;
}

//----- (10012E90) --------------------------------------------------------
int __cdecl sub_10012E90(int a1)
{
  void *v1; // ebx
  int v2; // eax
  int v3; // esi
  int v4; // edi
  int i; // edi
  unsigned __int64 v6; // kr00_8
  _DWORD *v7; // eax
  int v8; // edi
  int v9; // ebp
  unsigned __int64 v11; // [esp+18h] [ebp-8h]

  if ( (byte_100368D9 & 1) == 0 )
  {
    byte_100368D9 |= 1u;
    dword_100368D4 = (int)sub_100218A0((int)aReadentirefile_0);
  }
  v1 = off_1003440C;
  off_1003440C = (_UNKNOWN *)dword_100368D4;
  v11 = __rdtsc();
  v2 = sub_10012F90((int)v1, a1);
  v3 = v2;
  if ( v2 )
  {
    v4 = 0;
    if ( *(int *)(v2 + 8) > 0 )
    {
      do
      {
        *(_DWORD *)(*(_DWORD *)(v3 + 12) + 4 * v4) = 0;
        sub_10012520(a1, v3, v4++);
      }
      while ( v4 < *(_DWORD *)(v3 + 8) );
    }
    for ( i = 0; i < *(_DWORD *)(v3 + 8); ++i )
      sub_10012800(a1, v3, i);
  }
  v6 = __rdtsc() - v11;
  v7 = off_1003440C;
  v8 = *((_DWORD *)off_1003440C + 2);
  ++*((_DWORD *)off_1003440C + 1);
  v9 = v7[3];
  v7[2] = v6 + v8;
  v7[3] = HIDWORD(v6) + __CFADD__((_DWORD)v6, v8) + v9;
  off_1003440C = v1;
  *((_QWORD *)v1 + 2) += v6;
  return v3;
}
// 1003440C: using guessed type _UNKNOWN *off_1003440C;
// 100368D4: using guessed type int dword_100368D4;
// 100368D9: using guessed type char byte_100368D9;

//----- (10012F90) --------------------------------------------------------
int __usercall sub_10012F90@<eax>(int a1@<ebx>, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  int v4; // eax
  char v6; // [esp+7h] [ebp-5h] BYREF
  int v7; // [esp+8h] [ebp-4h] BYREF

  v7 = 0;
  v6 = 0;
  v2 = (_DWORD *)sub_10012BB0(a2, 0, &v6);
  v3 = v2;
  if ( v2 )
  {
    v4 = *v2;
    if ( *v3 != 6 )
      sub_10017FE0(
        2,
        9,
        "%s(%d): File is file format revision %d (current version is %d)",
        aWPublicGrannyR_23,
        389,
        v4,
        6);
    sub_10019A60(&v7, 24);
    sub_10019BC0(v7, 8, 12, v3[4], 4);
    sub_10019BC0(v7, 8, 16, v3[4], 1);
    if ( sub_10019C60((int)aWPublicGrannyR_23, 397) )
    {
      *(_BYTE *)v7 = v6;
      *(_DWORD *)(v7 + 4) = v3;
      *(_DWORD *)(v7 + 20) = 0;
      sub_10019D80(a1, 4 * *(_DWORD *)(v7 + 8), 0, *(char **)(v7 + 12));
      sub_10019D80(a1, *(_DWORD *)(v7 + 8), 0, *(char **)(v7 + 16));
      return v7;
    }
    off_10033624((int)aWPublicGrannyR_23, 408, (int)v3);
  }
  return v7;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (100130A0) --------------------------------------------------------
void __cdecl sub_100130A0(_DWORD *a1, int a2)
{
  if ( a2 < 0 || a2 >= a1[2] )
  {
    sub_10017FE0(3, 9, "%s(%d): SectionIndex %d is out of range [0, %d)", aWPublicGrannyR_23, 418, a2, a1[2]);
  }
  else if ( *(_DWORD *)(a1[3] + 4 * a2) )
  {
    off_10033624((int)aWPublicGrannyR_23, 422, *(_DWORD *)(a1[3] + 4 * a2));
    *(_BYTE *)(a2 + a1[4]) = 0;
    *(_DWORD *)(a1[3] + 4 * a2) = 0;
  }
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10013110) --------------------------------------------------------
int __cdecl sub_10013110(_DWORD *a1)
{
  int result; // eax
  int i; // esi

  result = a1[2];
  for ( i = 0; i < result; ++i )
  {
    sub_100130A0(a1, i);
    result = a1[2];
  }
  return result;
}

//----- (10013140) --------------------------------------------------------
int __cdecl sub_10013140(_DWORD *a1)
{
  int result; // eax

  if ( a1 )
  {
    sub_10013110(a1);
    off_10033624((int)aWPublicGrannyR_23, 445, a1[1]);
    off_10033624((int)aWPublicGrannyR_23, 446, a1[5]);
    return off_10033624((int)aWPublicGrannyR_23, 447, (int)a1);
  }
  return result;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10013190) --------------------------------------------------------
int __cdecl sub_10013190(int a1)
{
  int v1; // edi

  v1 = sub_100145D0(*(_DWORD *)(a1 + 12), (_DWORD *)(*(_DWORD *)(a1 + 4) + 20));
  sub_100145D0(*(_DWORD *)(a1 + 12), (_DWORD *)(*(_DWORD *)(a1 + 4) + 28));
  return v1;
}

//----- (100131D0) --------------------------------------------------------
int __cdecl sub_100131D0(int a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 4);
  if ( v1 )
    return *(_DWORD *)(v1 + 36);
  sub_10017FE0(3, 9, "%s(%d): File.Header is not allowed to be 0", aWPublicGrannyR_23, 468);
  return 0;
}

//----- (10013200) --------------------------------------------------------
_DWORD *__usercall sub_10013200@<eax>(int a1@<ebx>, int a2, int a3, _BYTE *a4, _BYTE *a5)
{
  int v5; // edi
  int v6; // esi
  _DWORD *v8; // [esp+4h] [ebp-4h] BYREF

  sub_10019A60(&v8, 1096);
  v5 = a2;
  sub_10019BC0((int)v8, 1084, 1088, a2, 84);
  if ( !sub_10019C60((int)aWPublicGrannyR_16, 500) )
    return v8;
  sub_100214A0(v8, 28, 256);
  sub_100214A0(v8 + 4, 32, 256);
  v8[8] = a3;
  sub_10021B20((_BYTE *)v8 + 36, 512, a4);
  sub_10021B20((_BYTE *)v8 + 548, 512, a5);
  sub_100133A0(v8 + 265);
  sub_100133A0(v8 + 268);
  if ( a2 > 0 )
  {
    v6 = 0;
    do
    {
      sub_10013340(a1, v6 + v8[272]);
      v6 += 84;
      --v5;
    }
    while ( v5 );
  }
  if ( sub_100133B0((int)v8) )
  {
    *((_BYTE *)v8 + 1092) = 1;
    return v8;
  }
  sub_10013480((int)v8);
  sub_10013510((int)v8);
  off_10033624((int)aWPublicGrannyR_16, 534, (int)v8);
  return 0;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10013340) --------------------------------------------------------
void __usercall sub_10013340(int a1@<ebx>, int a2)
{
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 4;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  sub_10019D80(a1, 0xCu, 0, (char *)(a2 + 44));
  sub_10019D80(a1, 0xCu, 0, (char *)(a2 + 56));
  *(_DWORD *)(a2 + 72) = 0;
  *(_DWORD *)(a2 + 68) = 0;
  *(_DWORD *)(a2 + 80) = 0;
  *(_DWORD *)(a2 + 76) = 0;
}

//----- (100133A0) --------------------------------------------------------
_DWORD *__cdecl sub_100133A0(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return result;
}

//----- (100133B0) --------------------------------------------------------
bool __cdecl sub_100133B0(int a1)
{
  int v1; // ebp
  bool result; // al
  int v3; // esi
  int *v4; // edi
  int v5; // eax
  int v6; // [esp+10h] [ebp-204h]
  CHAR FileName[512]; // [esp+14h] [ebp-200h] BYREF

  v1 = 0;
  result = 1;
  if ( *(int *)(a1 + 1084) > 0 )
  {
    v6 = 0;
    do
    {
      if ( !result )
        break;
      v3 = 0;
      v4 = (int *)(v6 + *(_DWORD *)(a1 + 1088) + 56);
      do
      {
        if ( !result )
          break;
        sub_10013440(a1, v1, v3, 512, (int)FileName);
        v5 = sub_10014B00(FileName, 1);
        *v4 = v5;
        result = v5 != 0;
        ++v3;
        ++v4;
      }
      while ( v3 < 3 );
      ++v1;
      v6 += 84;
    }
    while ( v1 < *(_DWORD *)(a1 + 1084) );
  }
  return result;
}

//----- (10013440) --------------------------------------------------------
int __cdecl sub_10013440(char a1, int a2, int a3, int a4, int a5)
{
  return sub_10022670(a4, a5, (int)aSSDDUtf, a1 + 36);
}

//----- (10013480) --------------------------------------------------------
int __cdecl sub_10013480(int a1)
{
  int result; // eax
  int v2; // ebp
  int v3; // esi
  int v4; // eax
  int v5; // edx
  _DWORD *v6; // esi
  HANDLE **v7; // edi
  int v8; // ebx
  int v9; // ecx
  int i; // [esp+4h] [ebp-4h]

  result = a1;
  v2 = 0;
  for ( i = 0; i < *(_DWORD *)(a1 + 1084); ++i )
  {
    v3 = *(_DWORD *)(a1 + 1088);
    v4 = *(_DWORD *)(v3 + v2 + 44);
    v5 = *(_DWORD *)(v3 + v2 + 48);
    v6 = (_DWORD *)(v2 + v3);
    v6[5] = v4;
    v6[6] = v4 + v5;
    v7 = (HANDLE **)(v6 + 14);
    v8 = 3;
    do
    {
      sub_10014B80(*v7);
      v9 = (int)*(v7 - 3);
      *v7++ = 0;
      --v8;
      v6[3] += v9;
    }
    while ( v8 );
    result = i + 1;
    v2 += 84;
  }
  return result;
}

//----- (10013510) --------------------------------------------------------
int __cdecl sub_10013510(int a1)
{
  int result; // eax
  int i; // edi
  int j; // esi
  CHAR FileName[512]; // [esp+8h] [ebp-200h] BYREF

  result = *(_DWORD *)(a1 + 1084);
  for ( i = 0; i < result; ++i )
  {
    sub_10013590(a1, i, 512, (int)FileName);
    sub_10014700(FileName);
    for ( j = 0; j < 3; ++j )
    {
      sub_10013440(a1, i, j, 512, (int)FileName);
      sub_10014700(FileName);
    }
    result = *(_DWORD *)(a1 + 1084);
  }
  return result;
}

//----- (10013590) --------------------------------------------------------
int __cdecl sub_10013590(char a1, int a2, int a3, int a4)
{
  return sub_10022670(a3, a4, (int)aSSDCtf, a1 + 36);
}

//----- (100135C0) --------------------------------------------------------
char __cdecl sub_100135C0(int a1, LPCSTR lpFileName)
{
  HANDLE *v2; // eax
  HANDLE *v3; // esi
  char v4; // bl

  v2 = (HANDLE *)sub_10014B00(lpFileName, 1);
  v3 = v2;
  if ( v2 )
  {
    v4 = sub_10013610(a1, v2);
    sub_10014B80(v3);
    return v4;
  }
  else
  {
    sub_10013B70(a1);
    return 0;
  }
}

//----- (10013610) --------------------------------------------------------
char __cdecl sub_10013610(int a1, HANDLE *a2)
{
  char result; // al
  char v3; // bl

  result = 0;
  if ( a1 )
  {
    sub_10013480(a1);
    v3 = sub_10013660(a1, a2);
    sub_10013510(a1);
    sub_100214C0(a1);
    sub_100214C0(a1 + 16);
    off_10033624((int)aWPublicGrannyR_16, 575, a1);
    return v3;
  }
  return result;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10013660) --------------------------------------------------------
char __cdecl sub_10013660(int a1, HANDLE *NumberOfBytesWritten)
{
  char v2; // bl
  int v3; // eax
  unsigned __int8 *v4; // edi
  int i; // esi
  int v6; // esi
  int v7; // eax
  int v8; // edx
  int v9; // ebx
  int v10; // eax
  int v11; // ecx
  int v12; // esi
  int v13; // esi
  bool v14; // cc
  int v15; // eax
  int *v16; // esi
  int v17; // edx
  int v18; // edx
  char v19; // al
  _DWORD *k; // esi
  int v21; // eax
  int v22; // edx
  int v23; // edx
  char v24; // al
  bool v25; // bl
  int v26; // eax
  int v27; // eax
  int v28; // edx
  int v29; // eax
  int v30; // edx
  LONG v32; // [esp-10h] [ebp-2B4h]
  int v33; // [esp+Ch] [ebp-298h]
  int v34; // [esp+Ch] [ebp-298h]
  int v35; // [esp+10h] [ebp-294h]
  int v36; // [esp+10h] [ebp-294h]
  int j; // [esp+14h] [ebp-290h]
  int v38; // [esp+14h] [ebp-290h]
  unsigned __int8 *v39; // [esp+18h] [ebp-28Ch]
  DWORD v40; // [esp+1Ch] [ebp-288h]
  DWORD v41; // [esp+1Ch] [ebp-288h]
  int v42; // [esp+20h] [ebp-284h]
  _DWORD Buffer[3]; // [esp+24h] [ebp-280h] BYREF
  _DWORD v44[4]; // [esp+30h] [ebp-274h] BYREF
  int v45; // [esp+40h] [ebp-264h] BYREF
  int v46; // [esp+44h] [ebp-260h]
  _DWORD v47[10]; // [esp+4Ch] [ebp-258h] BYREF
  char v48[16]; // [esp+74h] [ebp-230h] BYREF
  _DWORD v49[8]; // [esp+84h] [ebp-220h] BYREF
  CHAR v50[512]; // [esp+A4h] [ebp-200h] BYREF

  v2 = *(_BYTE *)(a1 + 1092);
  v3 = off_10033620((int)aWPublicGrannyR_16, 363, 4, 0x10000);
  v4 = (unsigned __int8 *)v3;
  v39 = (unsigned __int8 *)v3;
  if ( v2 && v3 )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 1084); ++i )
      v2 = v2 && sub_10013A50(a1, i, 0x10000, v4);
    v40 = sub_10014BC0(NumberOfBytesWritten);
    sub_10014C20(NumberOfBytesWritten, 88);
    v6 = 44 * (*(_DWORD *)(a1 + 1084) + 2);
    v42 = v6;
    sub_10014CB0((int)NumberOfBytesWritten);
    v35 = 0;
    if ( *(int *)(a1 + 1084) > 0 )
    {
      v33 = 0;
      do
      {
        if ( !v2 )
          break;
        v7 = *(_DWORD *)(a1 + 1088);
        v8 = *(_DWORD *)(v7 + v33 + 40);
        v9 = *(_DWORD *)(v7 + v33 + 8);
        v10 = v33 + v7;
        v11 = *(_DWORD *)(v10 + 32);
        *(_DWORD *)(v10 + 28) = v6;
        v12 = v6 + 12 * v11;
        *(_DWORD *)(v10 + 36) = v12;
        v13 = 16 * v8 + v12;
        *(_DWORD *)(v10 + 4) = v13;
        v6 = v9 + v13;
        v2 = sub_10014C40((DWORD)NumberOfBytesWritten, 0x2Cu, (unsigned __int8 *)v10) != 0;
        v14 = ++v35 < *(_DWORD *)(a1 + 1084);
        v33 += 84;
      }
      while ( v14 );
    }
    v34 = 0;
    if ( *(int *)(a1 + 1084) > 0 )
    {
      v36 = 0;
      do
      {
        if ( !v2 )
          break;
        v15 = *(_DWORD *)(a1 + 1088);
        v16 = *(int **)(v15 + v36 + 68);
        for ( j = v36 + v15; v16; v2 = v19 != 0 )
        {
          if ( !v2 )
            break;
          v46 = sub_10013A10(a1, v16);
          Buffer[0] = v17;
          Buffer[1] = sub_10013A10(a1, v16 + 3);
          Buffer[2] = v18;
          v19 = sub_10014C40((DWORD)NumberOfBytesWritten, 0xCu, (unsigned __int8 *)Buffer);
          v16 = (int *)v16[6];
        }
        for ( k = *(_DWORD **)(j + 76); k; v2 = v24 != 0 )
        {
          if ( !v2 )
            break;
          v44[0] = *k;
          v21 = sub_10013A10(a1, k + 4);
          v44[1] = v22;
          v46 = v21;
          v44[2] = sub_10013A10(a1, k + 1);
          v44[3] = v23;
          v24 = sub_10014C40((DWORD)NumberOfBytesWritten, 0x10u, (unsigned __int8 *)v44);
          k = (_DWORD *)k[7];
        }
        if ( *(_DWORD *)(j + 8) )
        {
          sub_10013590(a1, v34, 512, (int)v50);
          v2 = v2 && sub_10014660((DWORD)NumberOfBytesWritten, v50, 0x10000, v39, &v45);
        }
        v14 = ++v34 < *(_DWORD *)(a1 + 1084);
        v36 += 84;
      }
      while ( v14 );
    }
    v38 = sub_10014CE0((int)NumberOfBytesWritten);
    v32 = v40;
    v41 = sub_10014BC0(NumberOfBytesWritten) - v40;
    sub_10014BE0(NumberOfBytesWritten, v32);
    qmemcpy(v49, &unk_1002A50C, sizeof(v49));
    v49[4] = v42;
    memset(&v49[5], 0, 12);
    v25 = v2 && sub_10014C40((DWORD)NumberOfBytesWritten, 0x20u, (unsigned __int8 *)v49);
    v26 = *(_DWORD *)(a1 + 1084);
    v47[1] = v41;
    v47[0] = 6;
    v47[2] = v38;
    v47[3] = 56;
    v47[4] = v26;
    v27 = sub_10013A10(a1, (int *)(a1 + 1060));
    v47[8] = v28;
    v47[7] = v27;
    v47[5] = sub_10013A10(a1, (int *)(a1 + 1072));
    v29 = *(_DWORD *)(a1 + 32);
    v47[6] = v30;
    v47[9] = v29;
    sub_10019DC0(4u, 0, v48);
    v2 = v25 && sub_10014C40((DWORD)NumberOfBytesWritten, 0x38u, (unsigned __int8 *)v47);
    v4 = v39;
  }
  off_10033624((int)aWPublicGrannyR_16, 487, (int)v4);
  return v2;
}
// 100137D4: variable 'v17' is possibly undefined
// 100137E9: variable 'v18' is possibly undefined
// 10013824: variable 'v22' is possibly undefined
// 10013842: variable 'v23' is possibly undefined
// 10013988: variable 'v28' is possibly undefined
// 100139AF: variable 'v30' is possibly undefined
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10013A10) --------------------------------------------------------
int __cdecl sub_10013A10(int a1, int *a2)
{
  int result; // eax
  int v3; // edx
  int v4; // esi
  _DWORD *v5; // ecx

  result = *a2;
  v3 = a2[2];
  v4 = a2[1];
  if ( v4 )
  {
    v5 = (_DWORD *)(*(_DWORD *)(a1 + 1088) + 84 * *a2 + 44);
    do
    {
      v3 += *v5++;
      --v4;
    }
    while ( v4 );
  }
  return result;
}

//----- (10013A50) --------------------------------------------------------
char __cdecl sub_10013A50(int a1, int a2, int a3, unsigned __int8 *a4)
{
  int v4; // ebp
  char v5; // bl
  int v6; // eax
  HANDLE *v7; // esi
  bool v8; // al
  unsigned int v9; // esi
  unsigned int *v10; // edi
  unsigned int v11; // ebx
  HANDLE *v13; // [esp+Ch] [ebp-208h]
  _DWORD *v14; // [esp+10h] [ebp-204h]
  CHAR FileName[512]; // [esp+14h] [ebp-200h] BYREF

  v4 = *(_DWORD *)(a1 + 1088) + 84 * a2;
  v5 = 0;
  if ( *(_DWORD *)(v4 + 12) )
  {
    sub_10013590(a1, a2, 512, (int)FileName);
    v6 = sub_10014B00(FileName, 1);
    v7 = (HANDLE *)v6;
    v13 = (HANDLE *)v6;
    if ( v6 )
    {
      v14 = sub_100141D0(0, *(_DWORD *)(v4 + 12), 3, *(_DWORD *)v4, v6);
      if ( v14 )
      {
        v8 = 1;
        v9 = 0;
        v10 = (unsigned int *)(v4 + 44);
        while ( v8 )
        {
          v11 = *v10;
          sub_10013440(a1, a2, v9, 512, (int)FileName);
          v8 = sub_100142B0(v14, v11, FileName, a3, a4);
          ++v9;
          ++v10;
          if ( v9 >= 3 )
          {
            if ( v8 && sub_100143D0(v14, (DWORD *)(v4 + 8)) )
            {
              v5 = 1;
              goto LABEL_11;
            }
            break;
          }
        }
        v5 = 0;
LABEL_11:
        v7 = v13;
      }
      sub_10014B80(v7);
    }
    return v5;
  }
  else
  {
    *(_DWORD *)(v4 + 8) = 0;
    return 1;
  }
}

//----- (10013B70) --------------------------------------------------------
int __cdecl sub_10013B70(int a1)
{
  int result; // eax

  if ( a1 )
  {
    sub_10013480(a1);
    sub_10013510(a1);
    sub_100214C0(a1);
    sub_100214C0(a1 + 16);
    return off_10033624((int)aWPublicGrannyR_16, 590, a1);
  }
  return result;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10013BB0) --------------------------------------------------------
void __cdecl sub_10013BB0(int a1, int a2, int a3, int a4)
{
  _DWORD *v4; // eax

  if ( a2 < 0 || a2 >= *(_DWORD *)(a1 + 1084) )
  {
    sub_10017FE0(
      3,
      8,
      "%s(%d): SectionIndex %d is out of range [0, %d)",
      aWPublicGrannyR_16,
      598,
      a2,
      *(_DWORD *)(a1 + 1084));
  }
  else
  {
    v4 = (_DWORD *)(*(_DWORD *)(a1 + 1088) + 84 * a2);
    *v4 = a3;
    v4[4] = a4;
  }
}

//----- (10013C10) --------------------------------------------------------
int *__cdecl sub_10013C10(int *a1, int a2, int a3, int a4, DWORD a5, unsigned __int8 *a6)
{
  int v6; // esi
  int v7; // ebx
  char v8; // al
  int *result; // eax
  int v10; // ecx
  _DWORD v11[2]; // [esp+8h] [ebp-Ch] BYREF
  int v12; // [esp+10h] [ebp-4h]

  sub_100133A0(v11);
  if ( a3 < 0 || a3 >= *(_DWORD *)(a2 + 1084) )
  {
    sub_10017FE0(
      3,
      8,
      "%s(%d): InSectionIndex %d is out of range [0, %d)",
      aWPublicGrannyR_16,
      646,
      a3,
      *(_DWORD *)(a2 + 1084));
    result = a1;
    *a1 = v11[0];
    a1[1] = v11[1];
    a1[2] = v12;
  }
  else
  {
    v6 = *(_DWORD *)(a2 + 1088) + 84 * a3;
    v7 = sub_10013CE0(a4);
    v8 = *(_BYTE *)(a2 + 1092);
    v12 = *(_DWORD *)(v6 + 4 * v7 + 44);
    if ( v8 )
    {
      sub_10013D10(a2, v6, v7, a5, a6);
      sub_10013D70(a2, v6, v7);
    }
    result = a1;
    v10 = v12;
    *a1 = a3;
    a1[1] = v7;
    a1[2] = v10;
  }
  return result;
}

//----- (10013CE0) --------------------------------------------------------
int __cdecl sub_10013CE0(int a1)
{
  if ( a1 )
  {
    if ( a1 == 2 )
      return 1;
    if ( a1 != 4 )
      return 2;
  }
  return 0;
}

//----- (10013D10) --------------------------------------------------------
DWORD __cdecl sub_10013D10(int a1, int a2, int a3, DWORD nNumberOfBytesToWrite, unsigned __int8 *lpBuffer)
{
  bool v5; // al
  DWORD result; // eax

  v5 = *(_BYTE *)(a1 + 1092) && sub_10014C40(*(_DWORD *)(a2 + 4 * a3 + 56), nNumberOfBytesToWrite, lpBuffer);
  *(_BYTE *)(a1 + 1092) = v5;
  result = nNumberOfBytesToWrite;
  *(_DWORD *)(a2 + 4 * a3 + 44) += nNumberOfBytesToWrite;
  return result;
}

//----- (10013D70) --------------------------------------------------------
char __cdecl sub_10013D70(int a1, int a2, int a3)
{
  unsigned int v3; // ecx
  int v4; // eax
  int v5; // edx
  int v6; // esi
  int v8; // [esp+10h] [ebp-4h] BYREF

  v3 = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 4 * a3 + 44) / v3;
  v5 = *(_DWORD *)(a2 + 4 * a3 + 44) % v3;
  v8 = 0;
  v6 = v3 - v5;
  if ( v3 - v5 != v3 )
  {
    for ( ; v6 > 4; v6 -= 4 )
    {
      LOBYTE(v4) = *(_BYTE *)(a1 + 1092);
      if ( !(_BYTE)v4 )
        break;
      LOBYTE(v4) = sub_10013D10(a1, a2, a3, 4u, (unsigned __int8 *)&v8);
    }
    for ( ; v6 > 0; --v6 )
    {
      LOBYTE(v4) = *(_BYTE *)(a1 + 1092);
      if ( !(_BYTE)v4 )
        break;
      LOBYTE(v4) = sub_10013D10(a1, a2, a3, 1u, (unsigned __int8 *)&v8);
    }
  }
  return v4;
}

//----- (10013E00) --------------------------------------------------------
_DWORD *__cdecl sub_10013E00(_DWORD *a1, int a2, _DWORD *a3, int a4)
{
  int v4; // esi
  int v5; // ecx
  _DWORD *result; // eax

  v4 = a3[1];
  v5 = a3[2];
  result = a1;
  *a1 = *a3;
  a1[1] = v4;
  a1[2] = a4 + v5;
  return result;
}

//----- (10013E30) --------------------------------------------------------
_DWORD *__cdecl sub_10013E30(_DWORD *a1, unsigned int *a2, int a3, unsigned int *a4)
{
  unsigned int *v4; // ebp
  unsigned int v5; // eax
  unsigned int *v6; // ebx
  _DWORD *v7; // esi
  int *v8; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // ecx
  int v12; // ebx
  int v13; // eax
  int v14; // ecx
  _DWORD *v15; // eax
  int v16; // ecx
  int v18; // [esp+Ch] [ebp-Ch] BYREF
  int v19; // [esp+14h] [ebp-4h]

  v4 = a2;
  v5 = a1[271];
  if ( *a2 >= v5 )
  {
    sub_10017FE0(3, 8, "%s(%d): From.SectionIndex %d is out of range [0, %d)", aWPublicGrannyR_16, 682, *a2, a1[271]);
    return &unk_100368E8;
  }
  v6 = a4;
  if ( *a4 >= v5 )
  {
    sub_10017FE0(3, 8, "%s(%d): To.SectionIndex %d is out of range [0, %d)", aWPublicGrannyR_16, 684, *a4, a1[271]);
    return &unk_100368E8;
  }
  if ( !sub_100214E0(a1, &a2) )
    return &unk_100368E8;
  v7 = (_DWORD *)sub_100215A0(a1, (int)a2);
  v8 = sub_10013E00(&v18, (int)a1, v4, a3);
  v9 = *v8;
  v10 = v8[1];
  v19 = v8[2];
  *v7 = v9;
  v11 = v19;
  v7[1] = v10;
  v7[2] = v11;
  v7[3] = *v6;
  v7[4] = v6[1];
  v7[5] = v6[2];
  v7[6] = 0;
  v12 = a1[272];
  v13 = 84 * *v4;
  v14 = *(_DWORD *)(v13 + v12 + 72);
  v15 = (_DWORD *)(v12 + v13);
  if ( v14 )
  {
    *(_DWORD *)(v14 + 24) = v7;
    v16 = v15[8] + 1;
  }
  else
  {
    v16 = v15[8] + 1;
    v15[17] = v7;
  }
  v15[18] = v7;
  v15[8] = v16;
  return v7;
}

//----- (10013F50) --------------------------------------------------------
_DWORD *__cdecl sub_10013F50(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax

  result = a2 + 3;
  a2[3] = *a3;
  a2[4] = a3[1];
  a2[5] = a3[2];
  return result;
}

//----- (10013F70) --------------------------------------------------------
void __cdecl sub_10013F70(_DWORD *a1, unsigned int *a2, unsigned int *a3, int a4)
{
  unsigned int v4; // eax
  unsigned int *v5; // esi
  unsigned int *v6; // edi
  _DWORD *v7; // eax
  unsigned int v8; // ecx
  int v9; // edi
  int v10; // edx
  _DWORD *v11; // ecx

  v4 = a1[271];
  v5 = a2;
  if ( *a2 >= v4 )
  {
    sub_10017FE0(3, 8, "%s(%d): Type.SectionIndex %d is out of range [0, %d)", aWPublicGrannyR_16, 728, *a2, a1[271]);
  }
  else
  {
    v6 = a3;
    if ( *a3 >= v4 )
    {
      sub_10017FE0(
        3,
        8,
        "%s(%d): Object.SectionIndex %d is out of range [0, %d)",
        aWPublicGrannyR_16,
        729,
        *a3,
        a1[271]);
    }
    else if ( sub_100214E0(a1 + 4, &a2) )
    {
      v7 = (_DWORD *)sub_100215A0(a1 + 4, (int)a2);
      *v7 = a4;
      v7[1] = *v5;
      v7[2] = v5[1];
      v7[3] = v5[2];
      v7[4] = *v6;
      v7[5] = v6[1];
      v7[6] = v6[2];
      v7[7] = 0;
      v8 = *v6;
      v9 = a1[272];
      v8 *= 84;
      v10 = *(_DWORD *)(v8 + v9 + 80);
      v11 = (_DWORD *)(v9 + v8);
      if ( v10 )
        *(_DWORD *)(v10 + 28) = v7;
      else
        v11[19] = v7;
      v11[20] = v7;
      ++v11[10];
    }
  }
}

//----- (10014080) --------------------------------------------------------
_DWORD *__cdecl sub_10014080(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax

  a1[268] = *a2;
  a1[269] = a2[1];
  a1[270] = a2[2];
  result = a1 + 265;
  a1[265] = *a3;
  a1[266] = a3[1];
  a1[267] = a3[2];
  return result;
}

//----- (100140C0) --------------------------------------------------------
int __cdecl sub_100140C0(int a1)
{
  if ( a1 == 1 )
    return 4;
  else
    return 0;
}

//----- (100140D0) --------------------------------------------------------
char __cdecl sub_100140D0(int a1, int a2, _BYTE *a3, int a4, int a5, int a6, _BYTE *a7)
{
  void *v7; // esi
  char v8; // bl
  unsigned __int64 v9; // kr00_8
  _QWORD *v10; // eax
  bool v11; // cf
  unsigned __int64 v13; // [esp+10h] [ebp-8h]

  if ( (byte_10036904 & 1) == 0 )
  {
    byte_10036904 |= 1u;
    dword_10036908 = (int)sub_100218A0((int)aDecompressdata);
  }
  v7 = off_1003440C;
  off_1003440C = (_UNKNOWN *)dword_10036908;
  v13 = __rdtsc();
  v8 = 0;
  if ( !a1 )
  {
    sub_10019E10(a6, a3, (int)a7);
    goto LABEL_8;
  }
  if ( a1 == 1 )
  {
    sub_1001D060(a2, a3, a4, a5, a6, a7);
LABEL_8:
    v8 = 1;
    goto LABEL_9;
  }
  sub_10017FE0(3, 11, "%s(%d): Unrecognized compression type %d", aWPublicGrannyR_19, 114, a1);
LABEL_9:
  v9 = __rdtsc() - v13;
  v10 = off_1003440C;
  ++*((_DWORD *)off_1003440C + 1);
  v10[1] += v9;
  off_1003440C = v7;
  v11 = __CFADD__((_DWORD)v9, *((_DWORD *)v7 + 4));
  *((_DWORD *)v7 + 4) += v9;
  *((_DWORD *)v7 + 5) += HIDWORD(v9) + v11;
  return v8;
}
// 1003440C: using guessed type _UNKNOWN *off_1003440C;
// 10036904: using guessed type char byte_10036904;
// 10036908: using guessed type int dword_10036908;

//----- (100141D0) --------------------------------------------------------
_DWORD *__usercall sub_100141D0@<eax>(int a1@<ebx>, int a2, int a3, int a4, int a5)
{
  int v5; // esi
  _DWORD *result; // eax
  int v7; // ecx
  _DWORD *v8; // [esp+8h] [ebp-4h] BYREF

  v5 = a4;
  v8 = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
    {
      sub_10019A60(&v8, 12);
      sub_1001CD80(&a4, a2, a3);
      if ( sub_10019C60((int)aWPublicGrannyR_19, 146) )
      {
        v8[2] = a4;
        sub_1001CE00(a1, (_DWORD *)v8[2], a3);
      }
    }
    else
    {
      sub_10017FE0(3, 11, "%s(%d): Unrecognized compression type %d", aWPublicGrannyR_19, 156, a4);
    }
  }
  else
  {
    sub_10019A60(&v8, 12);
    if ( sub_10019C60((int)aWPublicGrannyR_19, 134) )
      v8[2] = 0;
  }
  result = v8;
  if ( v8 )
  {
    v7 = a5;
    *v8 = v5;
    v8[1] = v7;
    return v8;
  }
  return result;
}

//----- (100142B0) --------------------------------------------------------
bool __cdecl sub_100142B0(_DWORD *a1, unsigned int a2, LPCSTR lpFileName, int a4, unsigned __int8 *a5)
{
  _DWORD *v5; // ebx
  bool result; // al
  int v7; // edi
  int v8; // eax
  unsigned int v9; // ebp
  int v10; // eax
  unsigned int *v11; // esi
  char v12; // bl
  DWORD v13; // [esp-14h] [ebp-20h]

  v5 = a1;
  if ( *a1 )
  {
    if ( *a1 != 1 )
    {
      sub_10017FE0(3, 11, "%s(%d): Unrecognized compression type %d", aWPublicGrannyR_19, 212, *a1);
      return 0;
    }
    v7 = off_10032074((int)aWPublicGrannyR_19, 190, lpFileName);
    if ( !v7 )
      return 0;
    v8 = sub_1001CE50();
    v9 = a2;
    v10 = off_10033620((int)aWPublicGrannyR_19, 196, 4, a2 + v8);
    v11 = (unsigned int *)v10;
    if ( v10
      && (*(int (__cdecl **)(char *, int, int, _DWORD, unsigned int, int))(v7 + 12))(
           aWPublicGrannyR_19,
           197,
           v7,
           0,
           v9,
           v10) == v9 )
    {
      sub_1001CE60((_DWORD *)v5[2], v9, v11);
      v12 = 1;
    }
    else
    {
      v12 = 0;
    }
    off_10033624((int)aWPublicGrannyR_19, 204, (int)v11);
    (*(void (__cdecl **)(char *, int, int))(v7 + 8))(aWPublicGrannyR_19, 205, v7);
    return v12;
  }
  else
  {
    v13 = a1[1];
    a1 = 0;
    result = sub_10014660(v13, lpFileName, a4, a5, &a1);
    v5[2] += a1;
  }
  return result;
}
// 10032074: using guessed type int (__cdecl *off_10032074)(int, int, LPCSTR lpFileName);
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (100143D0) --------------------------------------------------------
char __cdecl sub_100143D0(_DWORD *a1, DWORD *lpBuffer)
{
  DWORD *v2; // edi
  char v3; // bl
  DWORD v4; // eax
  unsigned __int8 *v6; // [esp-Ch] [ebp-18h]

  v2 = lpBuffer;
  v3 = 0;
  *lpBuffer = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      if ( *a1 == 1 )
      {
        v4 = sub_1001CED0(a1[2], &lpBuffer);
        v6 = (unsigned __int8 *)lpBuffer;
        *v2 = v4;
        v3 = sub_10014C40(a1[1], v4, v6);
      }
      else
      {
        sub_10017FE0(3, 11, "%s(%d): Unrecognized compression type %d", aWPublicGrannyR_19, 248, *a1);
      }
    }
    else
    {
      v3 = 1;
      *v2 = a1[2];
    }
  }
  off_10033624((int)aWPublicGrannyR_19, 254, (int)a1);
  return v3;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10014460) --------------------------------------------------------
char __cdecl sub_10014460(int a1, unsigned int *a2, _BYTE *a3)
{
  char result; // al

  *a3 = 0;
  if ( sub_10019E50(16, (char *)a1, (int)&unk_1002A50C) )
  {
    result = 1;
    *a2 = *(_DWORD *)(a1 + 16);
  }
  else if ( sub_10019E50(16, (char *)a1, (int)&unk_1002A52C) )
  {
    *a3 = 1;
    result = 1;
    *a2 = (((*(_DWORD *)(a1 + 16) << 16) | *(_DWORD *)(a1 + 16) & 0xFF00) << 8) | ((HIWORD(*(_DWORD *)(a1 + 16)) | *(_DWORD *)(a1 + 16) & 0xFF0000u) >> 8);
  }
  else
  {
    return 0;
  }
  return result;
}

//----- (100144F0) --------------------------------------------------------
int __cdecl sub_100144F0(int a1)
{
  return a1 + *(_DWORD *)(a1 + 12);
}

//----- (10014500) --------------------------------------------------------
int __cdecl sub_10014500(int a1, int a2, int a3, unsigned int *a4)
{
  sub_10019E80(a1, a4);
  return sub_10019EE0(a2 - a1, (int *)((char *)a4 + a1));
}

//----- (10014530) --------------------------------------------------------
_DWORD *__cdecl sub_10014530(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  _DWORD *result; // eax
  _DWORD *v6; // ebp
  _DWORD *v7; // ecx
  int v8; // edx

  result = a1;
  if ( a1 )
  {
    v6 = a1;
    do
    {
      v7 = a2;
      v8 = *(_DWORD *)(a3 + 4 * a2[1]);
      result = (_DWORD *)(a4 + *a2);
      a2 += 3;
      *result = v8;
      if ( v8 )
        *result = v8 + v7[2];
      v6 = (_DWORD *)((char *)v6 - 1);
    }
    while ( v6 );
  }
  return result;
}

//----- (10014580) --------------------------------------------------------
int __cdecl sub_10014580(int a1, int *a2, int a3, int a4)
{
  int i; // edi
  int result; // eax
  _DWORD *v7; // [esp-18h] [ebp-1Ch]
  int v8; // [esp-14h] [ebp-18h]
  unsigned int *v9; // [esp-10h] [ebp-14h]

  for ( i = a1; i; --i )
  {
    v9 = (unsigned int *)(a4 + a2[1]);
    v8 = *a2;
    v7 = (_DWORD *)(a2[3] + *(_DWORD *)(a3 + 4 * a2[2]));
    a2 += 4;
    result = sub_10001D50(v7, v8, v9);
  }
  return result;
}

//----- (100145D0) --------------------------------------------------------
int __cdecl sub_100145D0(int a1, _DWORD *a2)
{
  return a2[1] + *(_DWORD *)(a1 + 4 * *a2);
}

//----- (100145F0) --------------------------------------------------------
unsigned int __usercall sub_100145F0@<eax>(double a1@<st0>, int a2)
{
  unsigned int v2; // edx
  int v3; // ebx
  int v4; // eax
  unsigned int v5; // edi

  v3 = sub_10013190(a2);
  v4 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 36);
  v5 = v2;
  if ( v4 == -2147483633 )
    return v2;
  if ( !*(_DWORD *)(a2 + 20) )
  {
    sub_10017FE0(
      2,
      9,
      "%s(%d): File has run-time type tag of 0x%x, which doesn't match this version of Granny (0x%x).  Automatic conversi"
      "on will be attempted.",
      aWPublicGrannyR_26,
      145,
      v4,
      -2147483633);
    *(_DWORD *)(a2 + 20) = sub_10010DA0(a1, v3, v5, &dword_10031D48);
  }
  return *(_DWORD *)(a2 + 20);
}
// 1001460D: variable 'v2' is possibly undefined
// 10031D48: using guessed type int dword_10031D48;

//----- (10014660) --------------------------------------------------------
bool __cdecl sub_10014660(DWORD NumberOfBytesWritten, LPCSTR lpFileName, int a3, unsigned __int8 *lpBuffer, _DWORD *a5)
{
  bool v5; // bl
  int v6; // edi
  DWORD v7; // eax
  DWORD v8; // esi

  v5 = 0;
  *a5 = 0;
  v6 = off_10032074((int)aWPublicGrannyR_20, 31, lpFileName);
  if ( v6 )
  {
    v5 = 1;
    do
    {
      v7 = (*(int (__cdecl **)(char *, int, int, _DWORD, int, unsigned __int8 *))(v6 + 12))(
             aWPublicGrannyR_20,
             38,
             v6,
             *a5,
             a3,
             lpBuffer);
      v8 = v7;
      if ( !v7 )
        break;
      v5 = sub_10014C40(NumberOfBytesWritten, v7, lpBuffer) != 0;
      *a5 += v8;
    }
    while ( v5 );
    (*(void (__cdecl **)(char *, int, int))(v6 + 8))(aWPublicGrannyR_20, 44, v6);
  }
  return v5;
}
// 100146B4: conditional instruction was optimized away because bl.1==1
// 10032074: using guessed type int (__cdecl *off_10032074)(int, int, LPCSTR lpFileName);

//----- (10014710) --------------------------------------------------------
BOOL __cdecl sub_10014710(LPCSTR lpFileName)
{
  return DeleteFileA(lpFileName);
}

//----- (10014720) --------------------------------------------------------
_DWORD *__cdecl sub_10014720(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  _DWORD *result; // eax
  int v6; // edx

  if ( !dword_10036A24 )
  {
    dword_10036A24 = (int)&unk_10036A14;
    dword_10036A28 = (int)&unk_10036A14;
  }
  result = a5;
  *a5 = a1;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  v6 = dword_10036A24;
  a5[5] = &unk_10036A14;
  a5[4] = v6;
  *(_DWORD *)(v6 + 20) = a5;
  *(_DWORD *)(a5[5] + 16) = a5;
  return result;
}
// 10036A24: using guessed type int dword_10036A24;
// 10036A28: using guessed type int dword_10036A28;

//----- (10014780) --------------------------------------------------------
int __cdecl sub_10014780(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 16) + 20) = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 16) = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
  }
  return result;
}

//----- (100147A0) --------------------------------------------------------
int (__cdecl *GrannyGetDefaultFileReaderOpenCallback())(int, int, LPCSTR lpFileName)
{
  return off_10032074;
}
// 10032074: using guessed type int (__cdecl *off_10032074)(int, int, LPCSTR lpFileName);

//----- (100147B0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100147B0(int (__cdecl *a1)(int, int, LPCSTR lpFileName)))(int, int, LPCSTR lpFileName)
{
  int (__cdecl *result)(int, int, LPCSTR); // eax

  result = a1;
  off_10032074 = a1;
  return result;
}
// 10032074: using guessed type int (__cdecl *off_10032074)(int, int, LPCSTR lpFileName);

//----- (100147C0) --------------------------------------------------------
_DWORD *__cdecl sub_100147C0(int a1, int a2, LPCSTR lpFileName)
{
  void *v3; // esi
  _DWORD *v4; // edi
  HANDLE FileA; // ebx
  unsigned __int64 v6; // kr00_8
  _QWORD *v7; // eax
  unsigned __int64 v9; // [esp+14h] [ebp-8h]

  if ( (byte_10036A2C & 1) == 0 )
  {
    byte_10036A2C |= 1u;
    dword_10036A3C = (int)sub_100218A0((int)aCreateplatform);
  }
  v3 = off_1003440C;
  off_1003440C = (_UNKNOWN *)dword_10036A3C;
  v9 = __rdtsc();
  v4 = 0;
  FileA = CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
  if ( FileA == (HANDLE)-1 )
  {
    sub_10025F20(0, aWPublicGrannyR_21, 114, aCreatefile);
  }
  else
  {
    v4 = (_DWORD *)off_10033620((int)aWPublicGrannyR_21, 98, 4, 28);
    if ( v4 )
    {
      sub_10014720(a1, a2, (int)byte_100148D0, (int)byte_100149A0, v4);
      v4[6] = FileA;
    }
    else
    {
      CloseHandle(FileA);
    }
  }
  v6 = __rdtsc() - v9;
  v7 = off_1003440C;
  ++*((_DWORD *)off_1003440C + 1);
  v7[1] += v6;
  off_1003440C = v3;
  *((_QWORD *)v3 + 2) += v6;
  return v4;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 1003440C: using guessed type _UNKNOWN *off_1003440C;
// 10036A2C: using guessed type char byte_10036A2C;
// 10036A3C: using guessed type int dword_10036A3C;

//----- (10014A90) --------------------------------------------------------
int __cdecl sub_10014A90(HANDLE *NumberOfBytesWritten)
{
  HANDLE *v1; // edi
  DWORD v2; // eax
  int v3; // esi

  v1 = NumberOfBytesWritten;
  v2 = sub_10014BC0(NumberOfBytesWritten);
  v3 = sub_10014AF0(v2);
  if ( v3 )
  {
    if ( sub_10014CD0((int)v1) )
    {
      NumberOfBytesWritten = 0;
      sub_10014C40((DWORD)v1, v3, (unsigned __int8 *)&NumberOfBytesWritten);
      return v3;
    }
    sub_10014C20(v1, v3);
  }
  return v3;
}

//----- (10014AF0) --------------------------------------------------------
int __cdecl sub_10014AF0(int a1)
{
  return ((a1 + 3) & 0xFFFFFFFC) - a1;
}

//----- (10014B00) --------------------------------------------------------
int __cdecl sub_10014B00(LPCSTR lpFileName, char a2)
{
  HANDLE FileA; // esi
  int result; // eax

  FileA = CreateFileA(lpFileName, 0x40000000u, 0, 0, 2 * (a2 == 0) + 2, 0x80u, 0);
  if ( FileA == (HANDLE)-1 )
  {
    sub_10025F20(0, aWPublicGrannyR_2, 68, aCreatefile);
    return 0;
  }
  else
  {
    result = off_10033620((int)aWPublicGrannyR_2, 54, 4, 12);
    if ( result )
    {
      *(_DWORD *)result = FileA;
      *(_BYTE *)(result + 4) = 0;
    }
    else
    {
      CloseHandle(FileA);
      return 0;
    }
  }
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (10014B80) --------------------------------------------------------
void __cdecl sub_10014B80(HANDLE *a1)
{
  if ( a1 )
  {
    if ( !CloseHandle(*a1) )
      sub_10025F20(0, aWPublicGrannyR_2, 83, aClosehandle);
    off_10033624((int)aWPublicGrannyR_2, 86, (int)a1);
  }
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10014BC0) --------------------------------------------------------
DWORD __cdecl sub_10014BC0(HANDLE *a1)
{
  return sub_10025FA0(*a1, 0, 1u);
}

//----- (10014BE0) --------------------------------------------------------
DWORD __cdecl sub_10014BE0(HANDLE *a1, LONG lDistanceToMove)
{
  return sub_10025FA0(*a1, lDistanceToMove, 0);
}

//----- (10014C00) --------------------------------------------------------
DWORD __cdecl sub_10014C00(HANDLE *a1, LONG lDistanceToMove)
{
  return sub_10025FA0(*a1, lDistanceToMove, 2u);
}

//----- (10014C20) --------------------------------------------------------
DWORD __cdecl sub_10014C20(HANDLE *a1, LONG lDistanceToMove)
{
  return sub_10025FA0(*a1, lDistanceToMove, 1u);
}

//----- (10014C40) --------------------------------------------------------
char __cdecl sub_10014C40(DWORD NumberOfBytesWritten, DWORD nNumberOfBytesToWrite, unsigned __int8 *lpBuffer)
{
  unsigned __int8 *v3; // ebx
  void **v4; // esi
  DWORD v5; // edi
  void *v7; // [esp-14h] [ebp-20h]

  v3 = lpBuffer;
  v4 = (void **)NumberOfBytesWritten;
  v5 = nNumberOfBytesToWrite;
  if ( *(_BYTE *)(NumberOfBytesWritten + 4) )
    sub_100105B0((int *)(NumberOfBytesWritten + 8), nNumberOfBytesToWrite, lpBuffer);
  v7 = *v4;
  NumberOfBytesWritten = 0;
  if ( WriteFile(v7, v3, v5, &NumberOfBytesWritten, 0) && NumberOfBytesWritten == v5 )
    return 1;
  sub_10025F20(0, aWPublicGrannyR_2, 138, aWritefile);
  return 0;
}

//----- (10014CB0) --------------------------------------------------------
_DWORD *__cdecl sub_10014CB0(int a1)
{
  *(_BYTE *)(a1 + 4) = 1;
  return sub_100105A0((_DWORD *)(a1 + 8));
}

//----- (10014CD0) --------------------------------------------------------
char __cdecl sub_10014CD0(int a1)
{
  return *(_BYTE *)(a1 + 4);
}

//----- (10014CE0) --------------------------------------------------------
int __cdecl sub_10014CE0(int a1)
{
  *(_BYTE *)(a1 + 4) = 0;
  sub_100105F0((int *)(a1 + 8));
  return *(_DWORD *)(a1 + 8);
}

//----- (10014D00) --------------------------------------------------------
_DWORD *__cdecl sub_10014D00(int *a1)
{
  int v1; // eax
  _DWORD *v2; // eax

  if ( *a1 )
  {
    if ( !a1[1] || !a1[5] )
    {
      if ( *a1 < 4 )
        *a1 = 4;
      v1 = 4000 / *a1;
      a1[1] = v1;
      if ( v1 < 64 )
        a1[1] = 64;
      a1[5] = (int)(a1 + 2);
      a1[6] = (int)(a1 + 2);
    }
    v2 = sub_10014D90(a1);
    if ( v2 )
      return sub_10014E30(a1, v2);
  }
  else
  {
    sub_10017FE0(3, 30, "%s(%d): The fixed allocator cannot be used with a unit size of 0.", aWPublicGrannyR_5, 170);
  }
  return 0;
}

//----- (10014D90) --------------------------------------------------------
_DWORD *__cdecl sub_10014D90(_DWORD *a1)
{
  _DWORD *v1; // esi
  _DWORD *result; // eax
  _DWORD *v3; // edi

  v1 = a1;
  result = (_DWORD *)a1[5];
  v3 = a1 + 2;
  if ( result == a1 + 2 )
  {
LABEL_5:
    sub_10019A60(&a1, 20);
    sub_10019B90((int)a1, 4, *v1 * v1[1]);
    if ( sub_10019C60((int)aWPublicGrannyR_5, 56) )
    {
      *a1 = 0;
      a1[2] = 0;
      a1[3] = v3;
      a1[4] = v1[6];
      *(_DWORD *)(a1[3] + 16) = a1;
      *(_DWORD *)(a1[4] + 12) = a1;
    }
    return a1;
  }
  else
  {
    while ( !result[2] && *result >= a1[1] )
    {
      result = (_DWORD *)result[3];
      if ( result == v3 )
        goto LABEL_5;
    }
  }
  return result;
}

//----- (10014E30) --------------------------------------------------------
_DWORD *__cdecl sub_10014E30(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = (_DWORD *)a2[2];
  if ( result )
    a2[2] = *result;
  else
    result = (_DWORD *)(a2[1] + *a2 * *a1);
  ++*a2;
  return result;
}

//----- (10014E60) --------------------------------------------------------
void __cdecl sub_10014E60(_DWORD *a1, unsigned int a2)
{
  _DWORD *v2; // eax

  if ( a2 )
  {
    v2 = sub_10014EB0(a1, a2);
    if ( v2 )
      sub_10014EF0((int)a1, v2, a2);
    else
      sub_10017FE0(3, 30, "%s(%d): Memory block 0x%x was not allocated by this allocator.", aWPublicGrannyR_5, 190, a2);
  }
}

//----- (10014EB0) --------------------------------------------------------
_DWORD *__cdecl sub_10014EB0(_DWORD *a1, unsigned int a2)
{
  _DWORD *result; // eax
  unsigned int v3; // ecx

  result = (_DWORD *)a1[5];
  if ( result == a1 + 2 )
    return 0;
  while ( 1 )
  {
    v3 = result[1];
    if ( a2 >= v3 && a2 < v3 + *a1 * a1[1] )
      break;
    result = (_DWORD *)result[3];
    if ( result == a1 + 2 )
      return 0;
  }
  return result;
}

//----- (10014EF0) --------------------------------------------------------
_DWORD *__cdecl sub_10014EF0(int a1, _DWORD *a2, int a3)
{
  _DWORD *result; // eax

  if ( (*a2)-- == 1 )
    return (_DWORD *)sub_10014F30((int)a2);
  result = (_DWORD *)sub_10014F20(a3);
  *result = a2[2];
  a2[2] = result;
  return result;
}

//----- (10014F20) --------------------------------------------------------
int __cdecl sub_10014F20(int a1)
{
  return a1;
}

//----- (10014F30) --------------------------------------------------------
int __cdecl sub_10014F30(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 16) = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(*(_DWORD *)(a1 + 16) + 12) = *(_DWORD *)(a1 + 12);
    return off_10033624((int)aWPublicGrannyR_5, 116, a1);
  }
  return result;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10014F60) --------------------------------------------------------
int __cdecl sub_10014F60(int a1, int a2, float *a3, int a4, int a5, int a6)
{
  int result; // eax
  double v8; // st7
  double v9; // st6
  double v10; // st5
  int v11; // edi
  int v12; // edi
  int v13; // edi
  int v14; // edi
  int v15; // edi
  int v16; // edi
  int v17; // edi
  int v18; // [esp+0h] [ebp-4h]
  float v19; // [esp+8h] [ebp+4h]
  float v20; // [esp+Ch] [ebp+8h]
  float v21; // [esp+10h] [ebp+Ch]

  result = a2;
  if ( a1 )
  {
    v18 = a1;
    do
    {
      v8 = *(float *)result;
      v9 = *(float *)(result + 4);
      v19 = *(float *)(result + 16);
      v10 = *(float *)(result + 8);
      v21 = *(float *)(result + 20);
      v20 = *(float *)(result + 24);
      v11 = *(_DWORD *)(a4 + 4 * *(_DWORD *)(result + 12)) << 6;
      *a3 = v10 * *(float *)(v11 + a5 + 32)
          + v9 * *(float *)(a5 + v11 + 16)
          + v8 * *(float *)(a5 + v11)
          + *(float *)(a5 + v11 + 48);
      v12 = *(_DWORD *)(a4 + 4 * *(_DWORD *)(result + 12)) << 6;
      a3[1] = v10 * *(float *)(v12 + a5 + 36)
            + v9 * *(float *)(a5 + v12 + 20)
            + v8 * *(float *)(a5 + v12 + 4)
            + *(float *)(a5 + v12 + 52);
      v13 = *(_DWORD *)(a4 + 4 * *(_DWORD *)(result + 12)) << 6;
      a3[2] = v10 * *(float *)(v13 + a5 + 40)
            + v9 * *(float *)(a5 + v13 + 24)
            + v8 * *(float *)(a5 + v13 + 8)
            + *(float *)(a5 + v13 + 56);
      v14 = *(_DWORD *)(a4 + 4 * *(_DWORD *)(result + 12)) << 6;
      a3[3] = v20 * *(float *)(v14 + a5 + 32) + v21 * *(float *)(a5 + v14 + 16) + v19 * *(float *)(a5 + v14);
      v15 = *(_DWORD *)(a4 + 4 * *(_DWORD *)(result + 12)) << 6;
      a3[4] = v20 * *(float *)(v15 + a5 + 36) + v21 * *(float *)(a5 + v15 + 20) + v19 * *(float *)(a5 + v15 + 4);
      v16 = *(_DWORD *)(a4 + 4 * *(_DWORD *)(result + 12)) << 6;
      result += 28;
      a3 += 6;
      *(a3 - 1) = v20 * *(float *)(v16 + a5 + 40) + v21 * *(float *)(a5 + v16 + 24) + v19 * *(float *)(a5 + v16 + 8);
      if ( a6 )
      {
        v17 = a6;
        do
        {
          *a3++ = *(float *)result;
          result += 4;
          --v17;
        }
        while ( v17 );
      }
      --v18;
    }
    while ( v18 );
  }
  return result;
}

//----- (100150C0) --------------------------------------------------------
int __cdecl sub_100150C0(int a1, int a2, float *a3, int a4, int a5)
{
  int result; // eax
  int v7; // ebx
  double v8; // st7
  double v9; // st6
  double v10; // st5
  int v11; // esi
  int v12; // esi
  int v13; // esi
  int v14; // esi
  int v15; // esi
  float v16; // [esp+4h] [ebp+4h]
  float v17; // [esp+8h] [ebp+8h]
  float v18; // [esp+Ch] [ebp+Ch]

  result = a2;
  if ( a1 )
  {
    v7 = a1;
    do
    {
      v8 = *(float *)result;
      v9 = *(float *)(result + 4);
      v16 = *(float *)(result + 16);
      v10 = *(float *)(result + 8);
      v18 = *(float *)(result + 20);
      v17 = *(float *)(result + 24);
      v11 = *(_DWORD *)(result + 12) << 6;
      *a3 = v10 * *(float *)(v11 + a4 + 32)
          + v9 * *(float *)(a4 + v11 + 16)
          + v8 * *(float *)(a4 + v11)
          + *(float *)(a4 + v11 + 48);
      v12 = *(_DWORD *)(result + 12) << 6;
      a3[1] = v10 * *(float *)(v12 + a4 + 36)
            + v9 * *(float *)(a4 + v12 + 20)
            + v8 * *(float *)(a4 + v12 + 4)
            + *(float *)(a4 + v12 + 52);
      v13 = *(_DWORD *)(result + 12) << 6;
      a3[2] = v10 * *(float *)(v13 + a4 + 40)
            + v9 * *(float *)(a4 + v13 + 24)
            + v8 * *(float *)(a4 + v13 + 8)
            + *(float *)(a4 + v13 + 56);
      a3[3] = v17 * *(float *)((*(_DWORD *)(result + 12) << 6) + a4 + 32)
            + v18 * *(float *)(a4 + (*(_DWORD *)(result + 12) << 6) + 16)
            + v16 * *(float *)(a4 + (*(_DWORD *)(result + 12) << 6));
      a3[4] = v17 * *(float *)((*(_DWORD *)(result + 12) << 6) + a4 + 36)
            + v18 * *(float *)(a4 + (*(_DWORD *)(result + 12) << 6) + 20)
            + v16 * *(float *)(a4 + (*(_DWORD *)(result + 12) << 6) + 4);
      v14 = *(_DWORD *)(result + 12) << 6;
      result += 28;
      a3 += 6;
      *(a3 - 1) = v17 * *(float *)(v14 + a4 + 40) + v18 * *(float *)(a4 + v14 + 24) + v16 * *(float *)(a4 + v14 + 8);
      if ( a5 )
      {
        v15 = a5;
        do
        {
          *a3++ = *(float *)result;
          result += 4;
          --v15;
        }
        while ( v15 );
      }
      --v7;
    }
    while ( v7 );
  }
  return result;
}

//----- (10015200) --------------------------------------------------------
float *__cdecl sub_10015200(int a1, int a2, float *a3, int a4, int a5, int a6)
{
  float *result; // eax
  double v9; // st7
  double v10; // st6
  double v11; // st5
  float *v12; // ecx
  double v13; // st4
  float *v14; // ecx
  double v15; // st7
  double v16; // st6
  int v17; // ecx
  int v18; // [esp+0h] [ebp-4h]
  float v19; // [esp+8h] [ebp+4h]
  float v20; // [esp+Ch] [ebp+8h]
  float v21; // [esp+10h] [ebp+Ch]
  float v22; // [esp+18h] [ebp+14h]

  result = a3;
  if ( a1 )
  {
    v18 = a1;
    do
    {
      result[2] = 0.0;
      result[1] = 0.0;
      *result = 0.0;
      result[3] = 0.0;
      result[5] = 0.0;
      result[4] = 0.0;
      v9 = *(float *)a2;
      v10 = *(float *)(a2 + 4);
      v20 = *(float *)(a2 + 16);
      v11 = *(float *)(a2 + 8);
      v19 = *(float *)(a2 + 20);
      v21 = *(float *)(a2 + 24);
      v12 = (float *)(a5 + (*(_DWORD *)(a4 + 4 * *(unsigned __int8 *)(a2 + 14)) << 6));
      v13 = (double)*(unsigned __int8 *)(a2 + 12) * 0.0039215689;
      *result = (v9 * *v12 + v11 * v12[8] + v10 * v12[4] + v12[12]) * v13;
      result[1] = (v11 * v12[9] + v10 * v12[5] + v9 * v12[1] + v12[13]) * v13;
      result[2] = (v9 * v12[2] + v11 * v12[10] + v10 * v12[6] + v12[14]) * v13;
      result[3] = (v20 * *v12 + v21 * v12[8] + v19 * v12[4]) * v13;
      result[4] = (v21 * v12[9] + v19 * v12[5] + v20 * v12[1]) * v13;
      result[5] = (v20 * v12[2] + v21 * v12[10] + v19 * v12[6]) * v13;
      v14 = (float *)(a5 + (*(_DWORD *)(a4 + 4 * *(unsigned __int8 *)(a2 + 15)) << 6));
      v22 = (double)*(unsigned __int8 *)(a2 + 13) * 0.0039215689;
      *result = (v9 * *v14 + v11 * v14[8] + v10 * v14[4] + v14[12]) * v22 + *result;
      result[1] = (v11 * v14[9] + v10 * v14[5] + v9 * v14[1] + v14[13]) * v22 + result[1];
      result[2] = (v9 * v14[2] + v11 * v14[10] + v10 * v14[6] + v14[14]) * v22 + result[2];
      result[3] = (v20 * *v14 + v21 * v14[8] + v19 * v14[4]) * v22 + result[3];
      a2 += 28;
      result += 6;
      *(result - 2) = (v21 * v14[9] + v19 * v14[5] + v20 * v14[1]) * v22 + *(result - 2);
      v15 = v20 * v14[2] + v21 * v14[10];
      v16 = v19 * v14[6];
      v17 = a6;
      for ( *(result - 1) = (v15 + v16) * v22 + *(result - 1); v17; --v17 )
      {
        *result++ = *(float *)a2;
        a2 += 4;
      }
      --v18;
    }
    while ( v18 );
  }
  return result;
}

//----- (10015440) --------------------------------------------------------
float *__cdecl sub_10015440(int a1, int a2, float *a3, int a4, int a5)
{
  float *result; // eax
  double v8; // st7
  double v9; // st6
  double v10; // st5
  float *v11; // ecx
  double v12; // st4
  float *v13; // ecx
  int v14; // ecx
  int v15; // [esp+0h] [ebp-4h]
  float v16; // [esp+8h] [ebp+4h]
  float v17; // [esp+Ch] [ebp+8h]
  float v18; // [esp+10h] [ebp+Ch]
  float v19; // [esp+18h] [ebp+14h]

  result = a3;
  if ( a1 )
  {
    v15 = a1;
    do
    {
      result[2] = 0.0;
      result[1] = 0.0;
      *result = 0.0;
      result[3] = 0.0;
      result[5] = 0.0;
      result[4] = 0.0;
      v8 = *(float *)a2;
      v9 = *(float *)(a2 + 4);
      v17 = *(float *)(a2 + 16);
      v10 = *(float *)(a2 + 8);
      v16 = *(float *)(a2 + 20);
      v18 = *(float *)(a2 + 24);
      v11 = (float *)(a4 + (*(unsigned __int8 *)(a2 + 14) << 6));
      v12 = (double)*(unsigned __int8 *)(a2 + 12) * 0.0039215689;
      *result = (v8 * *v11 + v10 * v11[8] + v9 * v11[4] + v11[12]) * v12;
      result[1] = (v10 * v11[9] + v9 * v11[5] + v8 * v11[1] + v11[13]) * v12;
      result[2] = (v8 * v11[2] + v10 * v11[10] + v9 * v11[6] + v11[14]) * v12;
      result[3] = (v17 * *v11 + v18 * v11[8] + v16 * v11[4]) * v12;
      result[4] = (v18 * v11[9] + v16 * v11[5] + v17 * v11[1]) * v12;
      result[5] = (v17 * v11[2] + v18 * v11[10] + v16 * v11[6]) * v12;
      v13 = (float *)(a4 + (*(unsigned __int8 *)(a2 + 15) << 6));
      v19 = (double)*(unsigned __int8 *)(a2 + 13) * 0.0039215689;
      *result = (v8 * *v13 + v10 * v13[8] + v9 * v13[4] + v13[12]) * v19 + *result;
      result[1] = (v10 * v13[9] + v9 * v13[5] + v8 * v13[1] + v13[13]) * v19 + result[1];
      result[2] = (v8 * v13[2] + v10 * v13[10] + v9 * v13[6] + v13[14]) * v19 + result[2];
      result[3] = (v17 * *v13 + v18 * v13[8] + v16 * v13[4]) * v19 + result[3];
      a2 += 28;
      result += 6;
      *(result - 2) = (v18 * v13[9] + v16 * v13[5] + v17 * v13[1]) * v19 + *(result - 2);
      *(result - 1) = (v17 * v13[2] + v18 * v13[10] + v16 * v13[6]) * v19 + *(result - 1);
      if ( a5 )
      {
        v14 = a5;
        do
        {
          *result++ = *(float *)a2;
          a2 += 4;
          --v14;
        }
        while ( v14 );
      }
      --v15;
    }
    while ( v15 );
  }
  return result;
}

//----- (10015670) --------------------------------------------------------
float *__cdecl sub_10015670(int a1, int a2, float *a3, int a4, int a5, int a6)
{
  float *result; // eax
  double v9; // st7
  double v10; // st6
  double v11; // st5
  float *v12; // ecx
  double v13; // st4
  float *v14; // ecx
  double v15; // st4
  float *v16; // ecx
  double v17; // st4
  float *v18; // ecx
  double v19; // st7
  double v20; // st6
  int v21; // ecx
  int v22; // [esp+0h] [ebp-4h]
  float v23; // [esp+8h] [ebp+4h]
  float v24; // [esp+Ch] [ebp+8h]
  float v25; // [esp+10h] [ebp+Ch]
  float v26; // [esp+18h] [ebp+14h]

  result = a3;
  if ( a1 )
  {
    v22 = a1;
    do
    {
      result[2] = 0.0;
      result[1] = 0.0;
      *result = 0.0;
      result[3] = 0.0;
      result[5] = 0.0;
      result[4] = 0.0;
      v9 = *(float *)a2;
      v10 = *(float *)(a2 + 4);
      v24 = *(float *)(a2 + 20);
      v11 = *(float *)(a2 + 8);
      v23 = *(float *)(a2 + 24);
      v25 = *(float *)(a2 + 28);
      v12 = (float *)(a5 + (*(_DWORD *)(a4 + 4 * *(unsigned __int8 *)(a2 + 16)) << 6));
      v13 = (double)*(unsigned __int8 *)(a2 + 12) * 0.0039215689;
      *result = (v9 * *v12 + v11 * v12[8] + v10 * v12[4] + v12[12]) * v13;
      result[1] = (v11 * v12[9] + v10 * v12[5] + v9 * v12[1] + v12[13]) * v13;
      result[2] = (v9 * v12[2] + v11 * v12[10] + v10 * v12[6] + v12[14]) * v13;
      result[3] = (v24 * *v12 + v25 * v12[8] + v23 * v12[4]) * v13;
      result[4] = (v25 * v12[9] + v23 * v12[5] + v24 * v12[1]) * v13;
      result[5] = (v24 * v12[2] + v25 * v12[10] + v23 * v12[6]) * v13;
      v14 = (float *)(a5 + (*(_DWORD *)(a4 + 4 * *(unsigned __int8 *)(a2 + 17)) << 6));
      v15 = (double)*(unsigned __int8 *)(a2 + 13) * 0.0039215689;
      *result = (v9 * *v14 + v11 * v14[8] + v10 * v14[4] + v14[12]) * v15 + *result;
      result[1] = (v11 * v14[9] + v10 * v14[5] + v9 * v14[1] + v14[13]) * v15 + result[1];
      result[2] = (v9 * v14[2] + v11 * v14[10] + v10 * v14[6] + v14[14]) * v15 + result[2];
      result[3] = (v24 * *v14 + v25 * v14[8] + v23 * v14[4]) * v15 + result[3];
      result[4] = (v25 * v14[9] + v23 * v14[5] + v24 * v14[1]) * v15 + result[4];
      result[5] = (v24 * v14[2] + v25 * v14[10] + v23 * v14[6]) * v15 + result[5];
      v16 = (float *)(a5 + (*(_DWORD *)(a4 + 4 * *(unsigned __int8 *)(a2 + 18)) << 6));
      v17 = (double)*(unsigned __int8 *)(a2 + 14) * 0.0039215689;
      *result = (v9 * *v16 + v11 * v16[8] + v10 * v16[4] + v16[12]) * v17 + *result;
      result[1] = (v11 * v16[9] + v10 * v16[5] + v9 * v16[1] + v16[13]) * v17 + result[1];
      result[2] = (v9 * v16[2] + v11 * v16[10] + v10 * v16[6] + v16[14]) * v17 + result[2];
      result[3] = (v24 * *v16 + v25 * v16[8] + v23 * v16[4]) * v17 + result[3];
      result[4] = (v25 * v16[9] + v23 * v16[5] + v24 * v16[1]) * v17 + result[4];
      result[5] = (v24 * v16[2] + v25 * v16[10] + v23 * v16[6]) * v17 + result[5];
      v18 = (float *)(a5 + (*(_DWORD *)(a4 + 4 * *(unsigned __int8 *)(a2 + 19)) << 6));
      v26 = (double)*(unsigned __int8 *)(a2 + 15) * 0.0039215689;
      *result = (v9 * *v18 + v11 * v18[8] + v10 * v18[4] + v18[12]) * v26 + *result;
      result[1] = (v11 * v18[9] + v10 * v18[5] + v9 * v18[1] + v18[13]) * v26 + result[1];
      result[2] = (v9 * v18[2] + v11 * v18[10] + v10 * v18[6] + v18[14]) * v26 + result[2];
      a2 += 32;
      result += 6;
      *(result - 3) = (v24 * *v18 + v25 * v18[8] + v23 * v18[4]) * v26 + *(result - 3);
      *(result - 2) = (v25 * v18[9] + v23 * v18[5] + v24 * v18[1]) * v26 + *(result - 2);
      v19 = v24 * v18[2] + v25 * v18[10];
      v20 = v23 * v18[6];
      v21 = a6;
      for ( *(result - 1) = (v19 + v20) * v26 + *(result - 1); v21; --v21 )
      {
        *result++ = *(float *)a2;
        a2 += 4;
      }
      --v22;
    }
    while ( v22 );
  }
  return result;
}

//----- (10015A60) --------------------------------------------------------
float *__cdecl sub_10015A60(int a1, int a2, float *a3, int a4, int a5)
{
  float *result; // eax
  double v8; // st7
  double v9; // st6
  double v10; // st5
  float *v11; // ecx
  double v12; // st4
  float *v13; // ecx
  double v14; // st4
  float *v15; // ecx
  double v16; // st4
  float *v17; // ecx
  int v18; // ecx
  int v19; // [esp+8h] [ebp-4h]
  float v20; // [esp+10h] [ebp+4h]
  float v21; // [esp+14h] [ebp+8h]
  float v22; // [esp+18h] [ebp+Ch]
  float v23; // [esp+20h] [ebp+14h]

  result = a3;
  if ( a1 )
  {
    v19 = a1;
    do
    {
      result[2] = 0.0;
      result[1] = 0.0;
      *result = 0.0;
      result[3] = 0.0;
      result[5] = 0.0;
      result[4] = 0.0;
      v8 = *(float *)a2;
      v9 = *(float *)(a2 + 4);
      v21 = *(float *)(a2 + 20);
      v10 = *(float *)(a2 + 8);
      v20 = *(float *)(a2 + 24);
      v22 = *(float *)(a2 + 28);
      v11 = (float *)(a4 + (*(unsigned __int8 *)(a2 + 16) << 6));
      v12 = (double)*(unsigned __int8 *)(a2 + 12) * 0.0039215689;
      *result = (v8 * *v11 + v10 * v11[8] + v9 * v11[4] + v11[12]) * v12;
      result[1] = (v10 * v11[9] + v9 * v11[5] + v8 * v11[1] + v11[13]) * v12;
      result[2] = (v8 * v11[2] + v10 * v11[10] + v9 * v11[6] + v11[14]) * v12;
      result[3] = (v21 * *v11 + v22 * v11[8] + v20 * v11[4]) * v12;
      result[4] = (v22 * v11[9] + v20 * v11[5] + v21 * v11[1]) * v12;
      result[5] = (v21 * v11[2] + v22 * v11[10] + v20 * v11[6]) * v12;
      v13 = (float *)(a4 + (*(unsigned __int8 *)(a2 + 17) << 6));
      v14 = (double)*(unsigned __int8 *)(a2 + 13) * 0.0039215689;
      *result = (v8 * *v13 + v10 * v13[8] + v9 * v13[4] + v13[12]) * v14 + *result;
      result[1] = (v10 * v13[9] + v9 * v13[5] + v8 * v13[1] + v13[13]) * v14 + result[1];
      result[2] = (v8 * v13[2] + v10 * v13[10] + v9 * v13[6] + v13[14]) * v14 + result[2];
      result[3] = (v21 * *v13 + v22 * v13[8] + v20 * v13[4]) * v14 + result[3];
      result[4] = (v22 * v13[9] + v20 * v13[5] + v21 * v13[1]) * v14 + result[4];
      result[5] = (v21 * v13[2] + v22 * v13[10] + v20 * v13[6]) * v14 + result[5];
      v15 = (float *)(a4 + (*(unsigned __int8 *)(a2 + 18) << 6));
      v16 = (double)*(unsigned __int8 *)(a2 + 14) * 0.0039215689;
      *result = (v8 * *v15 + v10 * v15[8] + v9 * v15[4] + v15[12]) * v16 + *result;
      result[1] = (v10 * v15[9] + v9 * v15[5] + v8 * v15[1] + v15[13]) * v16 + result[1];
      result[2] = (v8 * v15[2] + v10 * v15[10] + v9 * v15[6] + v15[14]) * v16 + result[2];
      result[3] = (v21 * *v15 + v22 * v15[8] + v20 * v15[4]) * v16 + result[3];
      result[4] = (v22 * v15[9] + v20 * v15[5] + v21 * v15[1]) * v16 + result[4];
      result[5] = (v21 * v15[2] + v22 * v15[10] + v20 * v15[6]) * v16 + result[5];
      v17 = (float *)(a4 + (*(unsigned __int8 *)(a2 + 19) << 6));
      v23 = (double)*(unsigned __int8 *)(a2 + 15) * 0.0039215689;
      *result = (v8 * *v17 + v10 * v17[8] + v9 * v17[4] + v17[12]) * v23 + *result;
      result[1] = (v10 * v17[9] + v9 * v17[5] + v8 * v17[1] + v17[13]) * v23 + result[1];
      result[2] = (v8 * v17[2] + v10 * v17[10] + v9 * v17[6] + v17[14]) * v23 + result[2];
      result[3] = (v21 * *v17 + v22 * v17[8] + v20 * v17[4]) * v23 + result[3];
      a2 += 32;
      result += 6;
      *(result - 2) = (v22 * v17[9] + v20 * v17[5] + v21 * v17[1]) * v23 + *(result - 2);
      *(result - 1) = (v21 * v17[2] + v22 * v17[10] + v20 * v17[6]) * v23 + *(result - 1);
      if ( a5 )
      {
        v18 = a5;
        do
        {
          *result++ = *(float *)a2;
          a2 += 4;
          --v18;
        }
        while ( v18 );
      }
      --v19;
    }
    while ( v19 );
  }
  return result;
}

//----- (10015E40) --------------------------------------------------------
float *__cdecl sub_10015E40(int a1, float *a2, float *a3, _DWORD *a4, int a5, int a6)
{
  float *result; // eax
  double v8; // st7
  double v9; // st6
  double v10; // st5
  int v11; // edi
  int v12; // edi
  int v13; // [esp+0h] [ebp-4h]
  float v14; // [esp+8h] [ebp+4h]
  float v15; // [esp+Ch] [ebp+8h]
  float v16; // [esp+10h] [ebp+Ch]

  result = a2;
  if ( a1 )
  {
    v13 = a1;
    do
    {
      v8 = *result;
      v9 = result[1];
      v14 = result[3];
      v10 = result[2];
      v16 = result[4];
      v15 = result[5];
      *a3 = v10 * *(float *)((*a4 << 6) + a5 + 32)
          + v9 * *(float *)(a5 + (*a4 << 6) + 16)
          + v8 * *(float *)(a5 + (*a4 << 6))
          + *(float *)(a5 + (*a4 << 6) + 48);
      a3[1] = v10 * *(float *)((*a4 << 6) + a5 + 36)
            + v9 * *(float *)(a5 + (*a4 << 6) + 20)
            + v8 * *(float *)(a5 + (*a4 << 6) + 4)
            + *(float *)(a5 + (*a4 << 6) + 52);
      v11 = *a4 << 6;
      a3[2] = v10 * *(float *)(v11 + a5 + 40)
            + v9 * *(float *)(a5 + v11 + 24)
            + v8 * *(float *)(a5 + v11 + 8)
            + *(float *)(a5 + v11 + 56);
      a3[3] = v15 * *(float *)((*a4 << 6) + a5 + 32)
            + v16 * *(float *)(a5 + (*a4 << 6) + 16)
            + v14 * *(float *)(a5 + (*a4 << 6));
      a3[4] = v15 * *(float *)((*a4 << 6) + a5 + 36)
            + v16 * *(float *)(a5 + (*a4 << 6) + 20)
            + v14 * *(float *)(a5 + (*a4 << 6) + 4);
      result += 6;
      a3 += 6;
      *(a3 - 1) = v15 * *(float *)((*a4 << 6) + a5 + 40)
                + v16 * *(float *)(a5 + (*a4 << 6) + 24)
                + v14 * *(float *)(a5 + (*a4 << 6) + 8);
      if ( a6 )
      {
        v12 = a6;
        do
        {
          *a3++ = *result++;
          --v12;
        }
        while ( v12 );
      }
      --v13;
    }
    while ( v13 );
  }
  return result;
}

//----- (10015F80) --------------------------------------------------------
float *__cdecl sub_10015F80(int a1, float *a2, float *a3, float *a4, int a5)
{
  float *result; // eax
  int v8; // ebx
  double v9; // st7
  double v10; // st6
  double v11; // st5
  int v12; // esi
  float v13; // [esp+8h] [ebp+4h]
  float v14; // [esp+Ch] [ebp+8h]
  float v15; // [esp+10h] [ebp+Ch]

  if ( a1 )
  {
    result = a4;
    v8 = a1;
    do
    {
      v9 = *a2;
      v10 = a2[1];
      v13 = a2[3];
      v11 = a2[2];
      v15 = a2[4];
      v14 = a2[5];
      a2 += 6;
      a3 += 6;
      *(a3 - 6) = v11 * a4[8] + v10 * a4[4] + v9 * *a4 + a4[12];
      *(a3 - 5) = v9 * a4[1] + v11 * a4[9] + v10 * a4[5] + a4[13];
      *(a3 - 4) = v11 * a4[10] + v10 * a4[6] + v9 * a4[2] + a4[14];
      *(a3 - 3) = v14 * a4[8] + v15 * a4[4] + v13 * *a4;
      *(a3 - 2) = v13 * a4[1] + v14 * a4[9] + v15 * a4[5];
      *(a3 - 1) = v14 * a4[10] + v15 * a4[6] + v13 * a4[2];
      if ( a5 )
      {
        v12 = a5;
        do
        {
          *a3++ = *a2++;
          --v12;
        }
        while ( v12 );
      }
      --v8;
    }
    while ( v8 );
  }
  return result;
}

//----- (10016080) --------------------------------------------------------
int sub_10016080()
{
  _DWORD v1[24]; // [esp+0h] [ebp-60h] BYREF

  v1[4] = &unk_100356A8;
  v1[10] = &unk_100356A8;
  v1[16] = &unk_100356A8;
  v1[21] = &unk_100356A8;
  v1[22] = &unk_100356A8;
  v1[0] = 2;
  v1[1] = sub_100150C0;
  v1[2] = sub_10014F60;
  v1[3] = &unk_10035848;
  v1[5] = 1;
  v1[6] = 2;
  v1[7] = sub_10015440;
  v1[8] = sub_10015200;
  v1[9] = &unk_10035968;
  v1[11] = 1;
  v1[12] = 2;
  v1[13] = sub_10015A60;
  v1[14] = sub_10015670;
  v1[15] = &unk_10035AC8;
  v1[17] = 1;
  v1[18] = 2;
  v1[19] = sub_10015F80;
  v1[20] = sub_10015E40;
  v1[23] = 1;
  return sub_100123E0(4, v1);
}

//----- (10016130) --------------------------------------------------------
double sub_10016130()
{
  return 0.82699001;
}

//----- (10016140) --------------------------------------------------------
int GrannyGetGrannyHeadBezierCount()
{
  return 100;
}

//----- (10016150) --------------------------------------------------------
char *__cdecl sub_10016150(int a1)
{
  if ( a1 >= GrannyGetGrannyHeadBezierCount() )
    return (char *)&unk_10032218;
  else
    return (char *)&unk_10032218 + 32 * a1;
}

//----- (10016170) --------------------------------------------------------
unsigned int __usercall sub_10016170@<eax>(double a1@<st0>, int a2)
{
  unsigned int v2; // edx
  int v3; // ebx
  int v4; // eax
  unsigned int v5; // edi

  v3 = sub_10013190(a2);
  v4 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 36);
  v5 = v2;
  if ( v4 == -1879048192 )
    return v2;
  if ( !*(_DWORD *)(a2 + 20) )
  {
    sub_10017FE0(
      2,
      9,
      "%s(%d): File has IGC type tag of 0x%x, which doesn't match this version of Granny (0x%x).  Automatic conversion wi"
      "ll be attempted.",
      aWPublicGrannyR_27,
      78,
      v4,
      -1879048192);
    *(_DWORD *)(a2 + 20) = sub_10010DA0(a1, v3, v5, &dword_100330E0);
  }
  return *(_DWORD *)(a2 + 20);
}
// 1001618D: variable 'v2' is possibly undefined
// 100330E0: using guessed type int dword_100330E0;

//----- (100161E0) --------------------------------------------------------
unsigned int *__cdecl sub_100161E0(int a1, int a2, unsigned int *a3)
{
  int *v3; // eax

  v3 = sub_10009B60(*(_DWORD *)(a1 + 8) != 0);
  return sub_10009E50(
           *(int **)a1,
           *(_DWORD *)(a1 + 4),
           *(_DWORD *)(a1 + 8) != 0,
           *(int **)(a1 + 16),
           (unsigned int *)v3,
           a2,
           a3);
}

//----- (10016220) --------------------------------------------------------
int __cdecl sub_10016220(int a1, int a2, float *a3, int a4, int a5, float *a6, int *a7, int *a8)
{
  int v8; // edx
  int v9; // ecx
  int v11; // esi
  int result; // eax
  int i; // edi
  int v14; // eax
  float v15; // ecx
  int v16; // ebx
  float v17; // edx
  int v18; // esi
  float *v19; // eax
  double v20; // st7
  double v21; // st6
  double v22; // st7
  double v23; // st6
  double v24; // st5
  double v25; // st4
  double v26; // st5
  double v27; // st6
  double v28; // st7
  long double v29; // st6
  float v30; // [esp+8h] [ebp-450h]
  float v31; // [esp+8h] [ebp-450h]
  float v32; // [esp+Ch] [ebp-44Ch]
  float v33; // [esp+Ch] [ebp-44Ch]
  float v34; // [esp+Ch] [ebp-44Ch]
  float v35; // [esp+10h] [ebp-448h]
  float v36; // [esp+14h] [ebp-444h]
  float v37; // [esp+14h] [ebp-444h]
  float v38; // [esp+18h] [ebp-440h]
  float v39; // [esp+20h] [ebp-438h]
  float v40; // [esp+20h] [ebp-438h]
  float v41; // [esp+24h] [ebp-434h] BYREF
  float v42; // [esp+28h] [ebp-430h]
  float v43; // [esp+2Ch] [ebp-42Ch]
  float v44; // [esp+30h] [ebp-428h]
  float v45; // [esp+34h] [ebp-424h]
  int v46; // [esp+38h] [ebp-420h]
  float v47; // [esp+3Ch] [ebp-41Ch]
  int v48; // [esp+40h] [ebp-418h]
  float v49; // [esp+44h] [ebp-414h]
  float v50; // [esp+48h] [ebp-410h]
  float v51; // [esp+4Ch] [ebp-40Ch]
  float v52; // [esp+50h] [ebp-408h]
  int v53; // [esp+54h] [ebp-404h]
  int v54[256]; // [esp+58h] [ebp-400h]

  v8 = 0;
  v9 = 0;
  v53 = *(_DWORD *)(a5 + 4);
  if ( a1 > 0 )
  {
    v11 = *(_DWORD *)(a5 + 8);
    do
    {
      v54[v9] = a2;
      a2 = *(_DWORD *)(156 * a2 + v11 + 4);
      if ( a2 == -1 )
        break;
      ++v8;
      ++v9;
    }
    while ( v9 < a1 );
  }
  result = a4;
  if ( a4 > 0 )
  {
    v46 = v8 - 1;
    v48 = a4;
    do
    {
      result = v46;
      for ( i = 1; i < v46; ++i )
      {
        v14 = sub_10025C40(a8, v54[0]);
        v15 = *(float *)(v14 + 52);
        v16 = v54[i];
        v50 = *(float *)(v14 + 48);
        v17 = *(float *)(v14 + 56);
        v51 = v15;
        v52 = v17;
        v18 = sub_10017830(a7, v16);
        v19 = (float *)sub_10025C40(a8, v16);
        v20 = *a3 - v19[12];
        v21 = a3[1] - v19[13];
        v39 = a3[2] - v19[14];
        v30 = v20;
        v45 = v21;
        v47 = v19[12] * 0.0;
        v38 = v39 * v19[2] + v21 * v19[1] + v20 * *v19 + v47;
        v49 = v19[13] * 0.0;
        v22 = v30 * v19[4] + v39 * v19[6] + v21 * v19[5] + v49;
        v23 = v19[14] * 0.0;
        v40 = v39 * v19[10] + v45 * v19[9] + v30 * v19[8] + v23;
        v24 = v50 - v19[12];
        v25 = v51 - v19[13];
        v36 = v52 - v19[14];
        v31 = v24;
        v45 = v25;
        v32 = v36 * v19[2] + v25 * v19[1] + v24 * *v19 + v47;
        v26 = v31 * v19[4] + v36 * v19[6] + v25 * v19[5] + v49;
        v37 = v36 * v19[10] + v45 * v19[9] + v31 * v19[8] + v23;
        v33 = v32 + v38;
        v34 = v33 * 0.5;
        v35 = (v26 + v22) * 0.5;
        v27 = (v37 + v40) * 0.5;
        v41 = v35 * v40 - v27 * v22;
        v42 = v38 * v27 - v40 * v34;
        v43 = v22 * v34 - v35 * v38;
        v28 = v27 * v40 + v35 * v22 + v34 * v38;
        v29 = 1.0 / sqrt(v43 * v43 + v42 * v42 + v41 * v41 + v28 * v28);
        v41 = v41 * v29;
        v42 = v42 * v29;
        v43 = v43 * v29;
        v44 = v29 * v28;
        *(_DWORD *)v18 |= 2u;
        sub_10018BC0((float *)(v18 + 16), (float *)(v18 + 16), &v41);
        sub_10025C80(a5, 0, v53, a7, a6, a8);
        result = v46;
      }
      --v48;
    }
    while ( v48 );
  }
  return result;
}
// 1002A170: using guessed type float flt_1002A170;

//----- (10016540) --------------------------------------------------------
void __cdecl sub_10016540(float a1, unsigned int a2, unsigned int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int *v9; // esi

  if ( SLODWORD(a1) >= 3 )
  {
    sub_10017FE0(3, 20, "%s(%d): Invalid pixel filter specified (%d)", aWPublicGrannyR_29, 97, a1);
  }
  else
  {
    v9 = sub_100166C0(a1, a6, a7, a2, a3);
    sub_10016CA0(v9, a9, a8, a5, a4, sub_100165B0);
    sub_10016C50((int)v9);
  }
}

//----- (100165B0) --------------------------------------------------------
int __cdecl sub_100165B0(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4 * a2);
}

//----- (100165C0) --------------------------------------------------------
double __cdecl sub_100165C0(float a1)
{
  if ( a1 <= -0.5 || a1 > 0.5 )
    return 0.0;
  else
    return 1.0;
}

//----- (100165F0) --------------------------------------------------------
double __cdecl sub_100165F0(float a1)
{
  if ( a1 < 0.0 )
    a1 = -a1;
  if ( a1 >= 1.0 )
    return 0.0;
  else
    return 1.0 - a1;
}

//----- (100166C0) --------------------------------------------------------
int *__cdecl sub_100166C0(float a1, int a2, int a3, unsigned int a4, unsigned int a5)
{
  int *result; // eax
  int *v6; // esi
  double (__cdecl *v7)(_DWORD); // ebx
  float v8; // [esp+10h] [ebp+4h]

  result = (int *)off_10033620((int)aWPublicGrannyR_29, 301, 4, 16 * a5 + 40);
  v6 = result;
  if ( result )
  {
    v7 = (double (__cdecl *)(_DWORD))*(&off_10033398 + LODWORD(a1));
    v8 = flt_1003338C[LODWORD(a1)];
    result[3] = a5;
    result[1] = a3;
    *result = a2;
    result[2] = a4;
    sub_100167B0(a2, a4, result + 4, result + 5, result + 6, v7, v8);
    if ( !v6[4] )
    {
LABEL_5:
      off_10033624((int)aWPublicGrannyR_29, 317, (int)v6);
      return 0;
    }
    sub_100167B0(a3, a5, v6 + 7, v6 + 8, v6 + 9, v7, v8);
    if ( !v6[7] )
    {
      off_10033624((int)aWPublicGrannyR_29, 324, v6[4]);
      goto LABEL_5;
    }
    return v6;
  }
  return result;
}
// 1003338C: using guessed type float flt_1003338C[3];
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (100167B0) --------------------------------------------------------
int __cdecl sub_100167B0(int a1, unsigned int a2, int *a3, int *a4, int *a5, double (__cdecl *a6)(_DWORD), float a7)
{
  int v8; // ebx
  double v9; // st7
  double v10; // st7
  double v11; // st7
  int v12; // eax
  int v13; // edx
  int v14; // eax
  int v15; // edi
  double v16; // st7
  signed int v17; // esi
  unsigned int v18; // eax
  double v19; // st7
  int v20; // eax
  int v21; // eax
  int v22; // edx
  int v23; // edi
  double v24; // st7
  signed int v25; // esi
  unsigned int v26; // eax
  double v27; // st7
  int v28; // eax
  int result; // eax
  float v30; // [esp+0h] [ebp-5Ch]
  float v31; // [esp+0h] [ebp-5Ch]
  int v32; // [esp+14h] [ebp-48h]
  float v33; // [esp+18h] [ebp-44h]
  float v34; // [esp+18h] [ebp-44h]
  float i; // [esp+18h] [ebp-44h]
  int v36; // [esp+1Ch] [ebp-40h]
  float v37; // [esp+20h] [ebp-3Ch]
  float v38; // [esp+20h] [ebp-3Ch]
  float v39; // [esp+24h] [ebp-38h]
  float v40; // [esp+28h] [ebp-34h]
  float v41; // [esp+28h] [ebp-34h]
  int v42; // [esp+30h] [ebp-2Ch]
  int v43; // [esp+34h] [ebp-28h]
  float v44; // [esp+38h] [ebp-24h]
  float v45; // [esp+38h] [ebp-24h]
  int v46; // [esp+38h] [ebp-24h]
  int v47; // [esp+38h] [ebp-24h]
  int v48; // [esp+3Ch] [ebp-20h]
  int v49; // [esp+3Ch] [ebp-20h]
  int v50; // [esp+40h] [ebp-1Ch]
  int v51; // [esp+44h] [ebp-18h]
  int v52; // [esp+48h] [ebp-14h]
  int v53; // [esp+50h] [ebp-Ch]
  float v54; // [esp+50h] [ebp-Ch]
  float v55; // [esp+50h] [ebp-Ch]
  float v56; // [esp+50h] [ebp-Ch]
  int v57; // [esp+54h] [ebp-8h]
  float v58; // [esp+64h] [ebp+8h]
  int v59; // [esp+64h] [ebp+8h]
  int v60; // [esp+64h] [ebp+8h]
  float v61; // [esp+78h] [ebp+1Ch]
  float j; // [esp+78h] [ebp+1Ch]

  v8 = 0;
  v32 = 0;
  if ( a2 == 1 || a1 == 1 )
    v9 = (double)(unsigned int)a1 / (double)(int)a2;
  else
    v9 = (double)(unsigned int)(a1 - 1) / (double)(int)(a2 - 1);
  v33 = v9;
  if ( v33 >= 1.0 )
  {
    v54 = a7 + a7 + 1.0;
    v52 = (int)v54;
    v57 = 8 * v52;
    v21 = off_10033620((int)aWPublicGrannyR_29, 234, 4, a1 * (8 * v52 + 4));
    v36 = v21;
    if ( v21 )
    {
      v22 = 0;
      v32 = v21 + 4 * a1;
      v60 = 0;
      if ( a1 > 0 )
      {
        v23 = v21 + 4 * a1;
        v43 = 0;
        v42 = v23;
        v38 = 1.0 / v33;
        while ( 1 )
        {
          v34 = 0.0;
          v24 = (double)v60 * v38;
          v41 = v24;
          v55 = v24 + a7;
          v47 = (int)v55;
          v56 = v41 - a7;
          v25 = (int)v56;
          if ( v25 <= v47 )
          {
            v26 = 1 - a2;
            v49 = (int)v56;
            v8 = v47 - v25 + 1;
            while ( 1 )
            {
              if ( v25 >= 0 )
                *(_DWORD *)(v23 + 4) = v25 < (int)a2 ? v25 : a2 - (v25 + v26) % a2 - 1;
              else
                *(_DWORD *)(v23 + 4) = -v25 % a2;
              v31 = v41 - (double)v49;
              v27 = a6(LODWORD(v31));
              *(float *)v23 = v27;
              ++v25;
              v23 += 8;
              v34 = v27 + v34;
              v49 = v25;
              if ( v25 > v47 )
                break;
              v26 = 1 - a2;
            }
            v22 = v60;
            v23 = v42;
          }
          v28 = v23;
          for ( i = 1.0 / v34; v8; *(float *)(v28 - 8) = i * *(float *)(v28 - 8) )
          {
            v28 += 8;
            --v8;
          }
          *(_DWORD *)(v36 + 4 * v22) = (v28 - v43 - v32) >> 3;
          v23 += v57;
          v60 = ++v22;
          v43 += v57;
          v42 = v23;
          if ( v22 >= a1 )
            break;
          v8 = 0;
        }
      }
    }
  }
  else
  {
    v10 = 1.0 / v33;
    v37 = v10;
    v11 = v10 * a7;
    v39 = v11;
    v58 = v11 + v11 + 1.0;
    v52 = (int)v58;
    v53 = 8 * v52;
    v12 = off_10033620((int)aWPublicGrannyR_29, 177, 4, a1 * (8 * v52 + 4));
    v36 = v12;
    if ( v12 )
    {
      v13 = 0;
      v14 = v12 + 4 * a1;
      v32 = v14;
      v59 = 0;
      if ( a1 > 0 )
      {
        v15 = v14;
        v50 = 0;
        v51 = v14;
        while ( 1 )
        {
          v61 = 0.0;
          v16 = (double)v59 * v37;
          v40 = v16;
          v44 = v16 + v39;
          v48 = (int)v44;
          v45 = v40 - v39;
          v17 = (int)v45;
          v46 = v17;
          if ( v17 <= v48 )
          {
            v18 = 1 - a2;
            v8 = v48 - v17 + 1;
            while ( 1 )
            {
              if ( v17 >= 0 )
                *(_DWORD *)(v15 + 4) = v17 < (int)a2 ? v17 : a2 - (v17 + v18) % a2 - 1;
              else
                *(_DWORD *)(v15 + 4) = -v17 % a2;
              v30 = (v40 - (double)v46) * v33;
              v19 = a6(LODWORD(v30)) * v33;
              v15 += 8;
              *(float *)(v15 - 8) = v19;
              v46 = ++v17;
              v61 = v19 + v61;
              if ( v17 > v48 )
                break;
              v18 = 1 - a2;
            }
            v13 = v59;
            v15 = v51;
          }
          v20 = v15;
          for ( j = 1.0 / v61; v8; *(float *)(v20 - 8) = j * *(float *)(v20 - 8) )
          {
            v20 += 8;
            --v8;
          }
          *(_DWORD *)(v36 + 4 * v13) = (v20 - v50 - v32) >> 3;
          v15 += v53;
          v59 = ++v13;
          v50 += v53;
          v51 = v15;
          if ( v13 >= a1 )
            break;
          v8 = 0;
        }
      }
    }
  }
  *a3 = v36;
  *a4 = v32;
  result = v52;
  *a5 = v52;
  return result;
}
// 1002A170: using guessed type float flt_1002A170;
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (10016C50) --------------------------------------------------------
int __cdecl sub_10016C50(int a1)
{
  off_10033624((int)aWPublicGrannyR_29, 333, *(_DWORD *)(a1 + 16));
  off_10033624((int)aWPublicGrannyR_29, 334, *(_DWORD *)(a1 + 28));
  return off_10033624((int)aWPublicGrannyR_29, 335, a1);
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10016CA0) --------------------------------------------------------
int __cdecl sub_10016CA0(_DWORD *a1, int a2, int a3, int a4, int a5, int (__cdecl *a6)(int, _DWORD))
{
  int result; // eax
  int v8; // ecx
  int v9; // ebp
  float *v10; // eax
  int v11; // ebx
  int v12; // esi
  unsigned int v13; // eax
  double v14; // st7
  bool v15; // cc
  int *v16; // ebp
  int v17; // ebx
  double v18; // st7
  double v19; // st6
  int v20; // esi
  int v21; // edx
  int v22; // ecx
  double v23; // st5
  int v24; // eax
  double v25; // st4
  float *v26; // eax
  int v27; // ecx
  int v28; // eax
  int v29; // eax
  int v30; // eax
  float v31; // [esp+4h] [ebp-34h]
  float v32; // [esp+4h] [ebp-34h]
  float v33; // [esp+8h] [ebp-30h]
  float v34; // [esp+8h] [ebp-30h]
  float v35; // [esp+Ch] [ebp-2Ch]
  float v36; // [esp+Ch] [ebp-2Ch]
  int i; // [esp+10h] [ebp-28h]
  float *v38; // [esp+14h] [ebp-24h]
  int v39; // [esp+18h] [ebp-20h]
  float v40; // [esp+3Ch] [ebp+4h]
  float v41; // [esp+3Ch] [ebp+4h]

  result = *a1;
  v8 = 0;
  for ( i = 0; v8 < *a1; i = v8 )
  {
    v9 = a4;
    v10 = (float *)(a1 + 10);
    v38 = (float *)(a1 + 10);
    v39 = 0;
    if ( (int)a1[3] > 0 )
    {
      do
      {
        v11 = a1[5] + 8 * v8 * a1[6];
        v12 = 0;
        v35 = 0.0;
        v33 = 0.0;
        v40 = 0.0;
        v31 = 0.0;
        if ( *(int *)(a1[4] + 4 * v8) > 0 )
        {
          do
          {
            v13 = a6(v9, *(_DWORD *)(v11 + 8 * v12 + 4));
            v14 = *(float *)(v11 + 8 * v12);
            v35 = (double)HIBYTE(v13) * v14 + v35;
            ++v12;
            v33 = (double)BYTE2(v13) * v14 + v33;
            v40 = (double)BYTE1(v13) * v14 + v40;
            v31 = (double)(unsigned __int8)v13 * v14 + v31;
          }
          while ( v12 < *(_DWORD *)(a1[4] + 4 * i) );
          v10 = v38;
          v8 = i;
        }
        *v10 = v35;
        v10[1] = v33;
        v10[2] = v40;
        v10[3] = v31;
        v9 += a5;
        v10 += 4;
        v15 = v39 + 1 < a1[3];
        v38 = v10;
        ++v39;
      }
      while ( v15 );
    }
    v16 = (int *)(a2 + 4 * v8);
    v17 = 0;
    if ( (int)a1[1] > 0 )
    {
      do
      {
        v18 = 0.0;
        v36 = 0.0;
        v19 = 0.0;
        v34 = 0.0;
        v20 = *(_DWORD *)(a1[7] + 4 * v17);
        v21 = a1[8] + 8 * v17 * a1[9];
        v22 = 0;
        v41 = 0.0;
        v32 = 0.0;
        if ( v20 > 0 )
        {
          do
          {
            v23 = *(float *)(v21 + 8 * v22);
            v24 = 4 * *(_DWORD *)(v21 + 8 * v22 + 4);
            v25 = v23 * *(float *)&a1[v24 + 10];
            v26 = (float *)&a1[v24 + 10];
            ++v22;
            v18 = v18 + v25;
            v19 = v19 + v23 * v26[1];
            v41 = v23 * v26[2] + v41;
            v32 = v23 * v26[3] + v32;
          }
          while ( v22 < v20 );
          v34 = v19;
          v36 = v18;
        }
        if ( v18 <= 0.0 )
        {
          v27 = 0;
        }
        else if ( v18 < 254.5 )
        {
          v27 = (int)v36 << 24;
        }
        else
        {
          v27 = -16777216;
        }
        if ( v34 > 0.0 )
        {
          if ( v34 < 254.5 )
            v28 = (int)v34 << 16;
          else
            v28 = 16711680;
          v27 |= v28;
        }
        if ( v41 > 0.0 )
        {
          if ( v41 < 254.5 )
            v29 = (int)v41 << 8;
          else
            v29 = 65280;
          v27 |= v29;
        }
        if ( v32 > 0.0 )
        {
          if ( v32 < 254.5 )
            v30 = (int)v32;
          else
            v30 = 255;
          v27 |= v30;
        }
        *v16 = v27;
        v16 = (int *)((char *)v16 + a3);
        ++v17;
      }
      while ( v17 < a1[1] );
      v8 = i;
    }
    result = *a1;
    ++v8;
  }
  return result;
}

//----- (10016FB0) --------------------------------------------------------
int __cdecl sub_10016FB0(float *a1, float a2, float *a3, float *a4, float *a5)
{
  double v5; // st7
  double v6; // st7

  v5 = a4[1] * a1[1] + a4[2] * a1[2] + *a1 * *a4;
  if ( v5 == 0.0 )
    return 0;
  v6 = -((a3[1] * a1[1] + a3[2] * a1[2] + *a1 * *a3 + a2) / v5);
  *a5 = v6;
  if ( v6 < 0.0 )
    return -1;
  else
    return 1;
}

//----- (10017020) --------------------------------------------------------
BOOL __cdecl sub_10017020()
{
  char v1; // c0

  return v1 == 0;
}
// 10017081: variable 'v1' is possibly undefined

//----- (10017090) --------------------------------------------------------
BOOL __cdecl sub_10017090(float *a1, float a2, float *a3, float *a4, float *a5, float *a6)
{
  double v6; // st7
  double v7; // st6
  double v8; // st5
  double v9; // st4
  long double v10; // st4
  long double v11; // st7
  long double v12; // st7
  int v14; // [esp+4h] [ebp+4h]

  v6 = *a1 - *a3;
  v7 = a1[1] - a3[1];
  v8 = a1[2] - a3[2];
  v9 = v8 * a4[2] + v7 * a4[1] + v6 * *a4;
  *(float *)&v14 = v9;
  v10 = v9 * *(float *)&v14 - (v6 * v6 + v8 * v8 + v7 * v7) + a2 * a2;
  if ( v10 < 0.0 )
    return 0;
  v11 = sqrt(v10);
  *a5 = *(float *)&v14 - v11;
  v12 = v11 + *(float *)&v14;
  *a6 = v12;
  return *a5 >= 0.0 || v12 >= 0.0;
}

//----- (10017140) --------------------------------------------------------
BOOL __cdecl sub_10017140(float *a1, float *a2, int a3, float *a4, float *a5)
{
  float *v6; // edi
  float *v7; // esi
  float v8; // edx
  double v9; // st7
  float v10; // eax
  float v11; // edx
  float v13; // [esp+0h] [ebp-44h]
  int v14; // [esp+24h] [ebp-20h] BYREF
  int v15; // [esp+28h] [ebp-1Ch] BYREF
  int v16; // [esp+2Ch] [ebp-18h] BYREF
  float v17; // [esp+30h] [ebp-14h]
  float v18; // [esp+34h] [ebp-10h]
  int v19[3]; // [esp+38h] [ebp-Ch] BYREF
  int v20; // [esp+48h] [ebp+4h]

  *(float *)&v14 = -3.4028235e38;
  *(float *)&v15 = 3.4028235e38;
  *(float *)v19 = *a4 - a1[12];
  v6 = a2;
  v7 = a1 + 2;
  *(float *)&v19[1] = a4[1] - a1[13];
  v20 = 3;
  *(float *)&v19[2] = a4[2] - a1[14];
  do
  {
    v8 = *(v7 - 1);
    v9 = -*(float *)((char *)v6 + a3 - (_DWORD)a2);
    v10 = *v7;
    v16 = *((int *)v7 - 2);
    v17 = v8;
    v18 = v10;
    v13 = v9;
    sub_10017270((float *)&v16, v13, (float *)v19, a5, (float *)&v14, (float *)&v15);
    *(float *)&v16 = -*(float *)&v16;
    v11 = *v6;
    v17 = -v17;
    v18 = -v18;
    sub_10017270((float *)&v16, v11, (float *)v19, a5, (float *)&v14, (float *)&v15);
    v7 += 4;
    ++v6;
    --v20;
  }
  while ( v20 );
  return *(float *)&v14 <= (double)*(float *)&v15 && (*(float *)&v14 >= 0.0 || *(float *)&v15 >= 0.0);
}

//----- (10017270) --------------------------------------------------------
void __cdecl sub_10017270(float *a1, float a2, float *a3, float *a4, float *a5, float *a6)
{
  double v7; // st7
  double v8; // st7
  int v9; // [esp+4h] [ebp+4h]

  v7 = a4[1] * a1[1] + a4[2] * a1[2] + *a1 * *a4;
  *(float *)&v9 = v7;
  if ( v7 != 0.0 )
  {
    v8 = -((a3[1] * a1[1] + a3[2] * a1[2] + *a1 * *a3 + a2) / *(float *)&v9);
    if ( *(float *)&v9 >= 0.0 )
    {
      if ( v8 < *a6 )
        *a6 = v8;
    }
    else if ( v8 > *a5 )
    {
      *a5 = v8;
    }
  }
}

//----- (10017300) --------------------------------------------------------
BOOL __cdecl sub_10017300(int a1, float *a2, int a3, float *a4, float *a5, int a6)
{
  float *v6; // ebx
  float *v8; // ebp
  float *v9; // esi
  int v10; // ecx
  float v11; // eax
  float v12; // edx
  float v14; // [esp+0h] [ebp-44h]
  float v15; // [esp+0h] [ebp-44h]
  int v16; // [esp+2Ch] [ebp-18h] BYREF
  float v17; // [esp+30h] [ebp-14h]
  float v18; // [esp+34h] [ebp-10h]
  int v19[3]; // [esp+38h] [ebp-Ch] BYREF
  int v20; // [esp+48h] [ebp+4h]
  float v21; // [esp+5Ch] [ebp+18h]

  v6 = a2;
  *(float *)a6 = -3.4028235e38;
  *(_DWORD *)(a6 + 16) = 2139095039;
  v8 = (float *)(a6 + 16);
  v9 = (float *)(a1 + 8);
  v10 = a3 - (_DWORD)a2;
  *(float *)v19 = *a4 - *(float *)(a1 + 48);
  v20 = 3;
  *(float *)&v19[1] = a4[1] - v9[11];
  *(float *)&v19[2] = a4[2] - v9[12];
  while ( 1 )
  {
    v11 = *(v9 - 1);
    v16 = *((int *)v9 - 2);
    v12 = *v9;
    v17 = v11;
    v18 = v12;
    v21 = v12 * v12 + v11 * v11 + *(float *)&v16 * *(float *)&v16;
    v14 = -(v21 * *(float *)((char *)v6 + v10));
    sub_10017470(
      (float *)&v16,
      v14,
      (float *)v19,
      a5,
      (_DWORD *)(a6 + 4),
      (_DWORD *)(a6 + 20),
      (float *)a6,
      (float *)(a6 + 16));
    *(float *)&v16 = -*(float *)&v16;
    v17 = -v17;
    v18 = -v18;
    v15 = v21 * *v6;
    sub_10017470(
      (float *)&v16,
      v15,
      (float *)v19,
      a5,
      (_DWORD *)(a6 + 4),
      (_DWORD *)(a6 + 20),
      (float *)a6,
      (float *)(a6 + 16));
    v9 += 4;
    ++v6;
    if ( !--v20 )
      break;
    v10 = a3 - (_DWORD)a2;
  }
  return *(float *)a6 <= (double)*v8 && (*(float *)a6 >= 0.0 || *v8 >= 0.0);
}

//----- (10017470) --------------------------------------------------------
void __cdecl sub_10017470(float *a1, float a2, float *a3, float *a4, _DWORD *a5, _DWORD *a6, float *a7, float *a8)
{
  double v9; // st7
  double v10; // st7
  float *v11; // edx
  int v13; // [esp+8h] [ebp+4h]

  v9 = a4[1] * a1[1] + a4[2] * a1[2] + *a4 * *a1;
  *(float *)&v13 = v9;
  if ( v9 != 0.0 )
  {
    v10 = -((a3[1] * a1[1] + a3[2] * a1[2] + *a3 * *a1 + a2) / *(float *)&v13);
    if ( *(float *)&v13 >= 0.0 )
    {
      v11 = a8;
      if ( v10 >= *a8 )
        return;
      a5 = a6;
    }
    else
    {
      v11 = a7;
      if ( v10 <= *a7 )
        return;
    }
    *a5 = *(_DWORD *)a1;
    a5[1] = *((_DWORD *)a1 + 1);
    a5[2] = *((_DWORD *)a1 + 2);
    *v11 = v10;
  }
}

//----- (10017510) --------------------------------------------------------
int __cdecl sub_10017510(float *a1, float *a2, float *a3, float *a4, float *a5, int a6)
{
  double v9; // st7
  double v10; // st7
  double v11; // st6
  double v12; // st5
  double v13; // st5
  double v14; // st7
  unsigned __int8 v16; // c0
  unsigned __int8 v17; // c3
  double v18; // st7
  float v20; // [esp+4h] [ebp-18h]
  float v21; // [esp+8h] [ebp-14h]
  float v22; // [esp+Ch] [ebp-10h]
  float v23; // [esp+10h] [ebp-Ch]
  float v24; // [esp+10h] [ebp-Ch]
  float v25; // [esp+14h] [ebp-8h]
  float v26; // [esp+18h] [ebp-4h]
  float v27; // [esp+20h] [ebp+4h]
  float v28; // [esp+24h] [ebp+8h]
  float v29; // [esp+34h] [ebp+18h]

  *(float *)(a6 + 12) = *a2 - *a1;
  *(float *)(a6 + 16) = a2[1] - a1[1];
  *(float *)(a6 + 20) = a2[2] - a1[2];
  *(float *)(a6 + 24) = *a3 - *a1;
  *(float *)(a6 + 28) = a3[1] - a1[1];
  v9 = a3[2] - a1[2];
  *(float *)(a6 + 32) = v9;
  v23 = v9 * a5[1] - *(float *)(a6 + 28) * a5[2];
  v10 = a5[2] * *(float *)(a6 + 24) - v9 * *a5;
  v11 = *(float *)(a6 + 28) * *a5 - a5[1] * *(float *)(a6 + 24);
  v12 = v23 * *(float *)(a6 + 12) + v10 * *(float *)(a6 + 16) + v11 * *(float *)(a6 + 20);
  v27 = v12;
  if ( v12 == 0.0 )
    return 0;
  v28 = 1.0 / v27;
  v20 = *a4 - *a1;
  v21 = a4[1] - a1[1];
  v13 = a4[2] - a1[2];
  v22 = v13;
  v29 = (v13 * v11 + v20 * v23 + v21 * v10) * v28;
  *(float *)(a6 + 4) = v29;
  if ( v29 <= 0.0 )
    return 0;
  if ( v29 >= 1.0 )
    return 0;
  v24 = v21 * *(float *)(a6 + 20) - v22 * *(float *)(a6 + 16);
  v25 = v22 * *(float *)(a6 + 12) - v20 * *(float *)(a6 + 20);
  v26 = v20 * *(float *)(a6 + 16) - v21 * *(float *)(a6 + 12);
  v14 = (v24 * *a5 + v26 * a5[2] + v25 * a5[1]) * v28;
  *(float *)(a6 + 8) = v14;
  if ( v16 | v17 || v29 + v14 >= 1.0 )
    return 0;
  *(float *)a6 = (v25 * *(float *)(a6 + 28) + v26 * *(float *)(a6 + 32) + v24 * *(float *)(a6 + 24)) * v28;
  v18 = *(float *)a6;
  *(_BYTE *)(a6 + 36) = v27 < 0.0;
  if ( v18 < 0.0 )
    return -1;
  else
    return 1;
}
// 10017690: variable 'v16' is possibly undefined
// 10017690: variable 'v17' is possibly undefined

//----- (10017720) --------------------------------------------------------
int __usercall sub_10017720@<eax>(int a1@<ebx>, int a2)
{
  int v2; // eax
  int v3; // eax

  v2 = sub_10017770(a2);
  v3 = off_10033620((int)aWPublicGrannyR_1, 71, 4, v2);
  return sub_100177C0(a1, a2, v3);
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (10017750) --------------------------------------------------------
int __cdecl sub_10017750(int a1)
{
  return off_10033624((int)aWPublicGrannyR_1, 79, a1);
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10017770) --------------------------------------------------------
int __cdecl sub_10017770(int a1)
{
  sub_10017790(a1, &a1);
  return sub_10019D70();
}

//----- (10017790) --------------------------------------------------------
int __cdecl sub_10017790(int a1, int *a2)
{
  sub_10019A60(a2, 16);
  return sub_10019BC0(*a2, 0, 4, a1, 80);
}

//----- (100177C0) --------------------------------------------------------
int __usercall sub_100177C0@<eax>(int a1@<ebx>, int a2, int a3)
{
  int v4; // [esp+4h] [ebp-4h] BYREF

  v4 = 0;
  sub_10017790(a2, &v4);
  if ( sub_10019D50((int)aWPublicGrannyR_1, 106, a3) )
  {
    *(_DWORD *)(v4 + 8) = 1045220557;
    *(_DWORD *)(v4 + 12) = 0;
    sub_10019D80(a1, 80 * a2, 0, *(char **)(v4 + 4));
  }
  return v4;
}

//----- (10017830) --------------------------------------------------------
int __cdecl sub_10017830(int *a1, int a2)
{
  if ( a2 >= 0 && a2 < *a1 )
    return 80 * a2 + a1[1] + 8;
  sub_10017FE0(3, 33, "%s(%d): BoneIndex %d is out of range [0, %d)", aWPublicGrannyR_1, 128, a2, *a1);
  return 0;
}

//----- (10017870) --------------------------------------------------------
int __cdecl sub_10017870(int a1)
{
  int result; // eax

  result = a1;
  ++*(_DWORD *)(a1 + 12);
  return result;
}

//----- (10017880) --------------------------------------------------------
int __cdecl sub_10017880(int a1, int a2, float a3, float *a4)
{
  double v4; // st7
  int v5; // edx
  double v7; // st7
  char v8; // c0
  int result; // eax
  double v10; // st7

  v4 = a3;
  v5 = *(_DWORD *)(a1 + 4) + 80 * a2;
  if ( *(_DWORD *)(v5 + 76) == *(_DWORD *)(a1 + 12) )
  {
    *(_DWORD *)(v5 + 8) |= *(_DWORD *)a4;
    *(float *)(v5 + 12) = v4 * a4[1] + *(float *)(v5 + 12);
    *(float *)(v5 + 16) = a3 * a4[2] + *(float *)(v5 + 16);
    *(float *)(v5 + 20) = a3 * a4[3] + *(float *)(v5 + 20);
    v7 = a3;
    if ( v8 )
      v7 = -v7;
    *(float *)(v5 + 24) = v7 * a4[4] + *(float *)(v5 + 24);
    *(float *)(v5 + 28) = v7 * a4[5] + *(float *)(v5 + 28);
    *(float *)(v5 + 32) = v7 * a4[6] + *(float *)(v5 + 32);
    *(float *)(v5 + 36) = v7 * a4[7] + *(float *)(v5 + 36);
    *(float *)(v5 + 40) = a3 * a4[8] + *(float *)(v5 + 40);
    *(float *)(v5 + 44) = a3 * a4[9] + *(float *)(v5 + 44);
    *(float *)(v5 + 48) = a3 * a4[10] + *(float *)(v5 + 48);
    *(float *)(v5 + 52) = a3 * a4[11] + *(float *)(v5 + 52);
    *(float *)(v5 + 56) = a3 * a4[12] + *(float *)(v5 + 56);
    *(float *)(v5 + 60) = a3 * a4[13] + *(float *)(v5 + 60);
    *(float *)(v5 + 64) = a3 * a4[14] + *(float *)(v5 + 64);
    *(float *)(v5 + 68) = a3 * a4[15] + *(float *)(v5 + 68);
    *(float *)(v5 + 72) = a3 * a4[16] + *(float *)(v5 + 72);
    result = *(_DWORD *)(v5 + 4) + 1;
    v10 = a3 + *(float *)v5;
    *(_DWORD *)(v5 + 4) = result;
    *(float *)v5 = v10;
  }
  else
  {
    if ( v4 == 1.0 )
    {
      qmemcpy((void *)(v5 + 8), a4, 0x44u);
    }
    else
    {
      *(float *)(v5 + 8) = *a4;
      *(float *)(v5 + 12) = a3 * a4[1];
      *(float *)(v5 + 16) = a3 * a4[2];
      *(float *)(v5 + 20) = a3 * a4[3];
      *(float *)(v5 + 24) = a3 * a4[4];
      *(float *)(v5 + 28) = a3 * a4[5];
      *(float *)(v5 + 32) = a3 * a4[6];
      *(float *)(v5 + 36) = a3 * a4[7];
      *(float *)(v5 + 40) = a3 * a4[8];
      *(float *)(v5 + 44) = a3 * a4[9];
      *(float *)(v5 + 48) = a3 * a4[10];
      *(float *)(v5 + 52) = a3 * a4[11];
      *(float *)(v5 + 56) = a3 * a4[12];
      *(float *)(v5 + 60) = a3 * a4[13];
      *(float *)(v5 + 64) = a3 * a4[14];
      *(float *)(v5 + 68) = a3 * a4[15];
      *(float *)(v5 + 72) = a3 * a4[16];
    }
    result = LODWORD(a3);
    *(float *)v5 = a3;
    *(_DWORD *)(v5 + 4) = 1;
    *(_DWORD *)(v5 + 76) = *(_DWORD *)(a1 + 12);
  }
  return result;
}
// 10017906: variable 'v8' is possibly undefined

//----- (10017AA0) --------------------------------------------------------
void __cdecl sub_10017AA0(int *a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi
  int v6; // ecx
  int v7; // edi
  float *v8; // edx
  float *v9; // ecx
  float *v10; // ebx
  double v11; // st7
  long double v12; // rt1
  float v13; // [esp+Ch] [ebp-28h]
  int v14; // [esp+24h] [ebp-10h]
  float *v15; // [esp+28h] [ebp-Ch]
  float *v16; // [esp+2Ch] [ebp-8h]

  v5 = (int)a1;
  if ( a2 < 0 || (v6 = *a1, a2 >= *a1) )
  {
    sub_10017FE0(3, 33, "%s(%d): FirstBone %d is out of range [0, %d)", aWPublicGrannyR_1, 190, a2, *a1);
  }
  else
  {
    v7 = a2 + a3;
    if ( a2 + a3 < 0 || v7 > v6 )
    {
      sub_10017FE0(
        3,
        33,
        "%s(%d): FirstBone + BoneCount %d is out of range [%d, %d]",
        aWPublicGrannyR_1,
        191,
        a2 + a3,
        0,
        v6);
    }
    else
    {
      v8 = (float *)(a1[1] + 80 * a2);
      v15 = v8;
      v14 = a2;
      if ( a2 < v7 )
      {
        v9 = (float *)(a5 + a4 * a2);
        v16 = v9;
        v10 = v8 + 5;
        do
        {
          if ( *((_DWORD *)v10 + 14) == *(_DWORD *)(v5 + 12) )
          {
            if ( *v8 < (double)*(float *)(v5 + 8) )
            {
              if ( a5 )
              {
                v13 = *(float *)(v5 + 8) - *v8;
                sub_10017880(v5, v14, v13, v9);
              }
              else
              {
                sub_10017FE0(
                  2,
                  33,
                  "%s(%d): Total weight %f for bone index %d is below fill threshold %f, but no default transform buffer "
                  "was supplied - numerical instability or divide-by-zero exceptions may be in your future",
                  aWPublicGrannyR_1,
                  217,
                  *v8,
                  v14,
                  *(float *)(v5 + 8));
              }
              v8 = v15;
            }
            if ( *((_DWORD *)v10 - 4) != 1 || *(_DWORD *)v8 != 1065353216 )
            {
              v11 = 1.0 / *v8;
              *(v10 - 2) = v11 * *(v10 - 2);
              *(v10 - 1) = v11 * *(v10 - 1);
              *v10 = v11 * *v10;
              v12 = sqrt(v10[4] * v10[4] + v10[3] * v10[3] + v10[2] * v10[2] + v10[1] * v10[1]);
              v10[1] = 1.0 / v12 * v10[1];
              v10[2] = 1.0 / v12 * v10[2];
              v10[3] = 1.0 / v12 * v10[3];
              v10[4] = 1.0 / v12 * v10[4];
              v10[5] = v11 * v10[5];
              v10[6] = v11 * v10[6];
              v10[7] = v11 * v10[7];
              v10[8] = v11 * v10[8];
              v10[9] = v11 * v10[9];
              v10[10] = v11 * v10[10];
              v10[11] = v11 * v10[11];
              v10[12] = v11 * v10[12];
              v10[13] = v11 * v10[13];
            }
          }
          else
          {
            qmemcpy(v10 - 3, v16, 0x44u);
            v7 = a2 + a3;
            v5 = (int)a1;
          }
          v8 += 20;
          v10 += 20;
          ++v14;
          v9 = (float *)((char *)v16 + a4);
          v15 = v8;
          v16 = (float *)((char *)v16 + a4);
        }
        while ( v14 < v7 );
      }
    }
  }
}
// 1002A170: using guessed type float flt_1002A170;

//----- (10017CE0) --------------------------------------------------------
double __cdecl sub_10017CE0(int a1)
{
  return *(float *)(a1 + 8);
}

//----- (10017CF0) --------------------------------------------------------
int __cdecl sub_10017CF0(int a1, float a2)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 8) = a2;
  return result;
}

//----- (10017D00) --------------------------------------------------------
void __cdecl sub_10017D00(int a1, int a2, int *a3, float *a4, int a5)
{
  int v5; // edi
  int v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // eax
  int v12; // ecx
  int v13; // edx
  int v14; // eax
  int v15; // ecx
  int v16; // edx
  int v17; // eax
  int v18; // ecx
  int v19; // edx
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  int v23; // ecx
  int v24; // edx
  int v25; // eax
  int v26; // ecx
  int v27; // edx
  int v28; // eax
  int v29; // ecx
  int v30; // edx
  int v31; // eax
  int v32; // ecx
  int v33; // edx
  int v34; // eax
  int v35; // ecx
  int v36; // edx
  int v37; // eax
  int v38; // [esp+10h] [ebp-80h] BYREF
  int v39; // [esp+14h] [ebp-7Ch]
  int v40; // [esp+18h] [ebp-78h]
  int v41; // [esp+1Ch] [ebp-74h]
  int v42; // [esp+20h] [ebp-70h]
  int v43; // [esp+24h] [ebp-6Ch]
  int v44; // [esp+28h] [ebp-68h]
  int v45; // [esp+2Ch] [ebp-64h]
  int v46; // [esp+30h] [ebp-60h]
  int v47; // [esp+34h] [ebp-5Ch]
  int v48; // [esp+38h] [ebp-58h]
  int v49; // [esp+3Ch] [ebp-54h]
  int v50; // [esp+40h] [ebp-50h]
  int v51; // [esp+44h] [ebp-4Ch]
  int v52; // [esp+48h] [ebp-48h]
  int v53; // [esp+4Ch] [ebp-44h]
  float v54[16]; // [esp+50h] [ebp-40h] BYREF

  v5 = a2;
  *(_DWORD *)(a5 + 60) = 1065353216;
  *(_DWORD *)(a5 + 40) = 1065353216;
  *(_DWORD *)(a5 + 20) = 1065353216;
  *(_DWORD *)a5 = 1065353216;
  *(_DWORD *)(a5 + 56) = 0;
  *(_DWORD *)(a5 + 52) = 0;
  *(_DWORD *)(a5 + 48) = 0;
  *(_DWORD *)(a5 + 44) = 0;
  *(_DWORD *)(a5 + 36) = 0;
  *(_DWORD *)(a5 + 32) = 0;
  *(_DWORD *)(a5 + 28) = 0;
  *(_DWORD *)(a5 + 24) = 0;
  *(_DWORD *)(a5 + 16) = 0;
  *(_DWORD *)(a5 + 12) = 0;
  *(_DWORD *)(a5 + 8) = 0;
  *(_DWORD *)(a5 + 4) = 0;
  if ( a2 < 0 || a2 >= sub_100043A0((int)a3) )
  {
    v37 = sub_100043A0((int)a3);
    sub_10017FE0(3, 33, "%s(%d): BoneIndex %d is out of range [0, %d)", aWPublicGrannyR_1, 264, a2, v37);
  }
  else
  {
    do
    {
      v6 = sub_10017830(a3, v5);
      sub_100018D0(v6, v54);
      sub_10018630((int)&v38, (float *)a5, v54);
      v7 = v39;
      v8 = v40;
      *(_DWORD *)a5 = v38;
      v9 = v41;
      *(_DWORD *)(a5 + 4) = v7;
      v10 = v42;
      *(_DWORD *)(a5 + 8) = v8;
      v11 = v43;
      *(_DWORD *)(a5 + 12) = v9;
      v12 = v44;
      *(_DWORD *)(a5 + 16) = v10;
      v13 = v45;
      *(_DWORD *)(a5 + 20) = v11;
      v14 = v46;
      *(_DWORD *)(a5 + 24) = v12;
      v15 = v47;
      *(_DWORD *)(a5 + 28) = v13;
      v16 = v48;
      *(_DWORD *)(a5 + 32) = v14;
      v17 = v49;
      *(_DWORD *)(a5 + 36) = v15;
      v18 = v50;
      *(_DWORD *)(a5 + 40) = v16;
      v19 = v51;
      *(_DWORD *)(a5 + 44) = v17;
      v20 = v52;
      *(_DWORD *)(a5 + 48) = v18;
      v21 = v53;
      *(_DWORD *)(a5 + 52) = v19;
      *(_DWORD *)(a5 + 56) = v20;
      *(_DWORD *)(a5 + 60) = v21;
      v5 = *(_DWORD *)(156 * v5 + *(_DWORD *)(a1 + 8) + 4);
    }
    while ( v5 != -1 );
    if ( a4 )
    {
      sub_10018630((int)&v38, (float *)a5, a4);
      v22 = v39;
      v23 = v40;
      *(_DWORD *)a5 = v38;
      v24 = v41;
      *(_DWORD *)(a5 + 4) = v22;
      v25 = v42;
      *(_DWORD *)(a5 + 8) = v23;
      v26 = v43;
      *(_DWORD *)(a5 + 12) = v24;
      v27 = v44;
      *(_DWORD *)(a5 + 16) = v25;
      v28 = v45;
      *(_DWORD *)(a5 + 20) = v26;
      v29 = v46;
      *(_DWORD *)(a5 + 24) = v27;
      v30 = v47;
      *(_DWORD *)(a5 + 28) = v28;
      v31 = v48;
      *(_DWORD *)(a5 + 32) = v29;
      v32 = v49;
      *(_DWORD *)(a5 + 36) = v30;
      v33 = v50;
      *(_DWORD *)(a5 + 40) = v31;
      v34 = v51;
      *(_DWORD *)(a5 + 44) = v32;
      v35 = v52;
      *(_DWORD *)(a5 + 48) = v33;
      v36 = v53;
      *(_DWORD *)(a5 + 52) = v34;
      *(_DWORD *)(a5 + 56) = v35;
      *(_DWORD *)(a5 + 60) = v36;
    }
  }
}
// 10017D71: conditional instruction was optimized away because %arg_4.4>=0

//----- (10017EF0) --------------------------------------------------------
int __cdecl sub_10017EF0(int a1, int *a2, int *a3, float *a4, int a5)
{
  float v6[16]; // [esp+0h] [ebp-40h] BYREF

  sub_10017D00(a1, *a2, a3, a4, (int)v6);
  return sub_100182E0(a5, v6);
}

//----- (10017F30) --------------------------------------------------------
char __cdecl sub_10017F30(CHAR *lpFileName, char a2)
{
  HANDLE *v2; // eax

  if ( !lpFileName )
  {
    FileName[0] = 0;
    return 1;
  }
  sub_10021B20(FileName, 512, lpFileName);
  if ( !FileName[0] )
    return 1;
  v2 = (HANDLE *)sub_10014B00(lpFileName, a2);
  if ( !v2 )
    return 0;
  sub_10014B80(v2);
  return 1;
}

//----- (10017F90) --------------------------------------------------------
__int64 GrannyGetLogCallback()
{
  return qword_1003EA40;
}
// 1003EA40: using guessed type __int64 qword_1003EA40;

//----- (10017FA0) --------------------------------------------------------
__int64 *__cdecl sub_10017FA0(__int64 *a1)
{
  __int64 *result; // eax

  result = a1;
  qword_1003EA40 = *a1;
  return result;
}
// 1003EA40: using guessed type __int64 qword_1003EA40;

//----- (10017FC0) --------------------------------------------------------
BOOL GrannyLogging()
{
  return FileName || (_DWORD)qword_1003EA40;
}
// 1003EA40: using guessed type __int64 qword_1003EA40;

//----- (10017FE0) --------------------------------------------------------
void sub_10017FE0(int a1, int a2, char *a3, ...)
{
  int v3; // esi
  int v4; // edi
  int v5; // ecx
  bool v6; // zf
  DWORD v7; // eax
  char v8; // cl
  DWORD v9; // eax
  va_list va; // [esp+18h] [ebp+10h] BYREF

  va_start(va, a3);
  v3 = a1;
  v4 = a2;
  v5 = dword_10046A88[a2] + 1;
  v6 = a1 == 0;
  ++dword_10046A74[a1];
  dword_10046A88[v4] = v5;
  if ( !v6 )
  {
    if ( v3 <= dword_10046B30 )
    {
      if ( !byte_10046A48[v4] && GrannyLogging() )
      {
        va_copy((va_list)a1, va);
        v9 = sub_100222E0(0x8000u, (int)byte_1003EA48, a3, (char **)&a1);
        a1 = 0;
        sub_100180C0(v3, v4, v9, byte_1003EA48);
      }
    }
    else
    {
      dword_10046B30 = v3;
      va_copy((va_list)a1, va);
      v7 = sub_100222E0(0x8000u, (int)byte_10036A40, a3, (char **)&a1);
      v8 = byte_10046A48[v4];
      a1 = 0;
      if ( !v8 )
        sub_100180C0(v3, v4, v7, (unsigned __int8 *)byte_10036A40);
    }
  }
}
// 1003EA48: using guessed type unsigned __int8 byte_1003EA48[32768];
// 10046A74: using guessed type int dword_10046A74[5];
// 10046A88: using guessed type int dword_10046A88[42];
// 10046B30: using guessed type int dword_10046B30;

//----- (100180C0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100180C0(
        int a1,
        int a2,
        DWORD nNumberOfBytesToWrite,
        unsigned __int8 *lpBuffer))(_DWORD, _DWORD, _DWORD, _DWORD)
{
  HANDLE *v4; // eax
  HANDLE *v5; // esi
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD, _DWORD); // eax

  if ( FileName && byte_10033588 )
  {
    byte_10033588 = 0;
    v4 = (HANDLE *)sub_10014B00(&FileName, 0);
    v5 = v4;
    if ( v4 )
    {
      sub_10014C00(v4, 0);
      sub_10014C40((DWORD)v5, nNumberOfBytesToWrite, lpBuffer);
      sub_10014C40((DWORD)v5, 1u, byte_1003358C);
      sub_10014B80(v5);
    }
    byte_10033588 = 1;
  }
  result = qword_1003EA40;
  if ( qword_1003EA40 )
    return (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))qword_1003EA40(a1, a2, lpBuffer, *(&qword_1003EA40 + 1));
  return result;
}
// 1003EA40: invalid function type '?' has been ignored
// 10033588: using guessed type char byte_10033588;
// 1003358C: using guessed type unsigned __int8 byte_1003358C[4];
// 1003EA40: using guessed type int (__cdecl *qword_1003EA40)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10018150) --------------------------------------------------------
bool __cdecl sub_10018150(int a1, char a2)
{
  bool result; // al

  result = a2 == 0;
  byte_10046A48[a1] = a2 == 0;
  return result;
}

//----- (10018170) --------------------------------------------------------
__int16 __usercall sub_10018170@<ax>(int a1@<edx>, char a2)
{
  int v2; // eax

  LOBYTE(a1) = a2 == 0;
  BYTE1(a1) = a2 == 0;
  v2 = a1 << 16;
  LOWORD(v2) = a1;
  memset32(byte_10046A48, v2, 0xAu);
  *(_WORD *)&byte_10046A48[40] = a1;
  return v2;
}

//----- (100181A0) --------------------------------------------------------
int GrannyGetMostSeriousMessageType()
{
  return dword_10046B30;
}
// 10046B30: using guessed type int dword_10046B30;

//----- (100181B0) --------------------------------------------------------
char *GrannyGetMostSeriousMessage()
{
  return &byte_10036A40;
}
// 10036A40: using guessed type char byte_10036A40;

//----- (100181C0) --------------------------------------------------------
int GrannyClearMostSeriousMessage()
{
  int result; // eax

  result = 0;
  dword_10046B30 = 0;
  byte_10036A40 = 0;
  return result;
}
// 10036A40: using guessed type char byte_10036A40;
// 10046B30: using guessed type int dword_10046B30;

//----- (100181D0) --------------------------------------------------------
void __cdecl sub_100181D0(float *a1, float *a2)
{
  double v2; // st7
  double v3; // st6
  double v4; // rt0

  v2 = a2[4] * a2[8] - a2[7] * a2[5];
  v3 = v2 * *a2 - (a2[8] * a2[3] - a2[6] * a2[5]) * a2[1] + (a2[7] * a2[3] - a2[6] * a2[4]) * a2[2];
  if ( v3 != 0.0 )
  {
    v4 = 1.0 / v3;
    *a1 = v2 * v4;
    a1[3] = -((a2[8] * a2[3] - a2[6] * a2[5]) * v4);
    a1[6] = (a2[7] * a2[3] - a2[6] * a2[4]) * v4;
    a1[1] = -((a2[1] * a2[8] - a2[7] * a2[2]) * v4);
    a1[4] = (a2[8] * *a2 - a2[6] * a2[2]) * v4;
    a1[7] = -((a2[7] * *a2 - a2[6] * a2[1]) * v4);
    a1[2] = (a2[1] * a2[5] - a2[4] * a2[2]) * v4;
    a1[5] = -((a2[5] * *a2 - a2[2] * a2[3]) * v4);
    a1[8] = (a2[4] * *a2 - a2[1] * a2[3]) * v4;
  }
}

//----- (100182E0) --------------------------------------------------------
int __cdecl sub_100182E0(int a1, float *a2)
{
  double v2; // st7
  double v3; // st6
  int result; // eax
  double v5; // rt0
  double v6; // st7
  double v7; // st7
  double v8; // st6

  v2 = a2[5] * a2[10] - a2[9] * a2[6];
  v3 = v2 * *a2 - (a2[10] * a2[1] - a2[9] * a2[2]) * a2[4] + (a2[6] * a2[1] - a2[5] * a2[2]) * a2[8];
  result = a1;
  if ( v3 != 0.0 )
  {
    v5 = 1.0 / v3;
    *(float *)a1 = v2 * v5;
    *(float *)(a1 + 4) = -((a2[10] * a2[1] - a2[9] * a2[2]) * v5);
    *(float *)(a1 + 8) = (a2[6] * a2[1] - a2[5] * a2[2]) * v5;
    *(float *)(a1 + 16) = -((a2[4] * a2[10] - a2[8] * a2[6]) * v5);
    *(float *)(a1 + 20) = (a2[10] * *a2 - a2[8] * a2[2]) * v5;
    *(float *)(a1 + 24) = -((a2[6] * *a2 - a2[2] * a2[4]) * v5);
    *(float *)(a1 + 32) = (a2[9] * a2[4] - a2[8] * a2[5]) * v5;
    *(float *)(a1 + 36) = -((a2[9] * *a2 - a2[8] * a2[1]) * v5);
    *(float *)(a1 + 40) = (a2[5] * *a2 - a2[4] * a2[1]) * v5;
  }
  v6 = *(float *)(a1 + 32);
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(float *)(a1 + 48) = -(v6 * a2[14] + *(float *)(a1 + 16) * a2[13] + a2[12] * *(float *)a1);
  *(float *)(a1 + 52) = -(*(float *)(a1 + 36) * a2[14] + *(float *)(a1 + 4) * a2[12] + *(float *)(a1 + 20) * a2[13]);
  v7 = *(float *)(a1 + 40) * a2[14] + *(float *)(a1 + 8) * a2[12];
  v8 = *(float *)(a1 + 24) * a2[13];
  *(_DWORD *)(a1 + 60) = 1065353216;
  *(float *)(a1 + 56) = -(v7 + v8);
  return result;
}

//----- (10018450) --------------------------------------------------------
float *__cdecl sub_10018450(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a3;
  *a1 = *a2 * *a3 + a2[2] * a3[6] + a2[1] * a3[3];
  a1[1] = a2[1] * a3[4] + a3[1] * *a2 + a2[2] * a3[7];
  a1[2] = a2[2] * a3[8] + a2[1] * a3[5] + a3[2] * *a2;
  a1[3] = a2[5] * a3[6] + a2[4] * a3[3] + a2[3] * *a3;
  a1[4] = a2[4] * a3[4] + a2[5] * a3[7] + a2[3] * a3[1];
  a1[5] = a2[5] * a3[8] + a2[3] * a3[2] + a2[4] * a3[5];
  a1[6] = a3[6] * a2[8] + a2[7] * a3[3] + *a3 * a2[6];
  a1[7] = a2[7] * a3[4] + a3[7] * a2[8] + a3[1] * a2[6];
  a1[8] = a3[8] * a2[8] + a3[2] * a2[6] + a2[7] * a3[5];
  return result;
}

//----- (10018540) --------------------------------------------------------
float *__cdecl sub_10018540(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a3;
  *a1 = *a2 * *a3 + a2[6] * a3[6] + a2[3] * a3[3];
  a1[1] = a2[3] * a3[4] + a3[1] * *a2 + a2[6] * a3[7];
  a1[2] = a2[6] * a3[8] + a2[3] * a3[5] + a3[2] * *a2;
  a1[3] = a2[7] * a3[6] + a2[4] * a3[3] + a2[1] * *a3;
  a1[4] = a2[4] * a3[4] + a2[7] * a3[7] + a2[1] * a3[1];
  a1[5] = a2[7] * a3[8] + a2[1] * a3[2] + a2[4] * a3[5];
  a1[6] = a3[6] * a2[8] + a2[5] * a3[3] + *a3 * a2[2];
  a1[7] = a2[5] * a3[4] + a3[7] * a2[8] + a3[1] * a2[2];
  a1[8] = a3[8] * a2[8] + a3[2] * a2[2] + a2[5] * a3[5];
  return result;
}

//----- (10018630) --------------------------------------------------------
int __cdecl sub_10018630(int a1, float *a2, float *a3)
{
  double v3; // st7
  int result; // eax

  *(float *)a1 = *a2 * *a3 + a2[2] * a3[8] + a2[1] * a3[4];
  *(float *)(a1 + 4) = a2[1] * a3[5] + a3[1] * *a2 + a2[2] * a3[9];
  *(float *)(a1 + 8) = a2[2] * a3[10] + a2[1] * a3[6] + a3[2] * *a2;
  *(float *)(a1 + 16) = a2[6] * a3[8] + a2[5] * a3[4] + a2[4] * *a3;
  *(float *)(a1 + 20) = a2[5] * a3[5] + a2[6] * a3[9] + a2[4] * a3[1];
  *(float *)(a1 + 24) = a2[6] * a3[10] + a2[4] * a3[2] + a2[5] * a3[6];
  *(float *)(a1 + 32) = a3[8] * a2[10] + a2[9] * a3[4] + *a3 * a2[8];
  *(float *)(a1 + 36) = a2[9] * a3[5] + a3[9] * a2[10] + a3[1] * a2[8];
  *(float *)(a1 + 40) = a3[10] * a2[10] + a3[2] * a2[8] + a2[9] * a3[6];
  *(float *)(a1 + 48) = a2[14] * a3[8] + a2[12] * *a3 + a3[4] * a2[13] + a3[12];
  *(float *)(a1 + 52) = a2[14] * a3[9] + a2[12] * a3[1] + a2[13] * a3[5] + a3[13];
  v3 = a3[6] * a2[13] + a3[10] * a2[14] + a3[2] * a2[12] + a3[14];
  result = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(float *)(a1 + 56) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 60) = 1065353216;
  return result;
}

//----- (10018780) --------------------------------------------------------
float *__cdecl sub_10018780(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a3;
  *a1 = *a2 * *a3 + a3[12] * a2[3] + a3[8] * a2[2] + a2[1] * a3[4];
  a1[1] = a3[13] * a2[3] + a2[2] * a3[9] + a2[1] * a3[5] + a3[1] * *a2;
  a1[2] = a3[14] * a2[3] + a3[6] * a2[1] + *a2 * a3[2] + a3[10] * a2[2];
  a1[3] = a3[15] * a2[3] + a2[2] * a3[11] + a2[1] * a3[7] + a3[3] * *a2;
  a1[4] = a3[8] * a2[6] + a3[12] * a2[7] + a2[5] * a3[4] + *a3 * a2[4];
  a1[5] = a2[6] * a3[9] + a3[1] * a2[4] + a2[7] * a3[13] + a2[5] * a3[5];
  a1[6] = a3[10] * a2[6] + a3[14] * a2[7] + a3[6] * a2[5] + a3[2] * a2[4];
  a1[7] = a2[6] * a3[11] + a3[3] * a2[4] + a2[7] * a3[15] + a2[5] * a3[7];
  a1[8] = a3[8] * a2[10] + a3[12] * a2[11] + a2[9] * a3[4] + *a3 * a2[8];
  a1[9] = a2[10] * a3[9] + a3[1] * a2[8] + a2[11] * a3[13] + a2[9] * a3[5];
  a1[10] = a3[10] * a2[10] + a3[14] * a2[11] + a3[6] * a2[9] + a2[8] * a3[2];
  a1[11] = a2[10] * a3[11] + a3[3] * a2[8] + a2[11] * a3[15] + a2[9] * a3[7];
  a1[12] = a3[8] * a2[14] + a3[12] * a2[15] + a2[13] * a3[4] + *a3 * a2[12];
  a1[13] = a2[14] * a3[9] + a3[1] * a2[12] + a2[15] * a3[13] + a2[13] * a3[5];
  a1[14] = a2[14] * a3[10] + a3[14] * a2[15] + a2[13] * a3[6] + a2[12] * a3[2];
  a1[15] = a2[14] * a3[11] + a3[3] * a2[12] + a2[15] * a3[15] + a2[13] * a3[7];
  return result;
}

//----- (100189A0) --------------------------------------------------------
float *__cdecl sub_100189A0(float *a1, float *a2)
{
  double v3; // st7
  double v4; // st6
  double v5; // st5
  double v6; // st4
  double v7; // st3
  float *result; // eax
  float v9; // [esp+0h] [ebp-Ch]
  float v10; // [esp+4h] [ebp-8h]
  float v11; // [esp+8h] [ebp-4h]
  float v12; // [esp+14h] [ebp+8h]

  v3 = *a2 * *a2;
  v4 = a2[1] * a2[1];
  v5 = a2[2] * a2[2];
  v6 = a2[1] * *a2;
  v12 = a2[2] * *a2;
  v11 = a2[2] * a2[1];
  v10 = a2[3] * *a2;
  v9 = a2[1] * a2[3];
  v7 = a2[2] * a2[3];
  result = a1;
  *a1 = 1.0 - (v5 + v4 + v5 + v4);
  a1[1] = v6 - v7 + v6 - v7;
  a1[2] = v9 + v12 + v9 + v12;
  a1[3] = v7 + v6 + v7 + v6;
  a1[4] = 1.0 - (v5 + v3 + v5 + v3);
  a1[5] = v11 - v10 + v11 - v10;
  a1[6] = v12 - v9 + v12 - v9;
  a1[7] = v10 + v11 + v10 + v11;
  a1[8] = 1.0 - (v4 + v3 + v4 + v3);
  return result;
}

//----- (10018A70) --------------------------------------------------------
int __cdecl sub_10018A70(float *a1, float *a2)
{
  double v2; // st7
  int result; // eax
  long double v4; // st7
  long double v5; // st7
  int v6; // edx

  v2 = a2[8] + *a2 + a2[4];
  if ( v2 <= 0.0 )
  {
    v6 = a2[4] > (double)*a2;
    if ( a2[8] > (double)a2[4 * v6] )
      v6 = 2;
    return sub_10018B10((int)a1, (int)a2, v6);
  }
  else
  {
    result = (int)a1;
    v4 = sqrt(v2 + 1.0);
    a1[3] = 0.5 * v4;
    v5 = 0.5 / v4;
    *a1 = (a2[7] - a2[5]) * v5;
    a1[1] = (a2[2] - a2[6]) * v5;
    a1[2] = (a2[3] - a2[1]) * v5;
  }
  return result;
}

//----- (10018B10) --------------------------------------------------------
int __cdecl sub_10018B10(int a1, int a2, int a3)
{
  unsigned int v4; // esi
  unsigned int v5; // edx
  int result; // eax
  int v7; // ebp
  double v8; // st7
  long double v9; // st7
  long double v10; // st7
  int v11; // [esp+1Ch] [ebp+Ch]

  v4 = (a3 + 1) % 3u;
  v5 = (a3 + 2) % 3u;
  result = a2;
  v7 = a3 + 3 * v4;
  v8 = *(float *)(16 * a3 + a2) - (*(float *)(16 * v5 + a2) + *(float *)(a2 + 16 * v4));
  v11 = 3 * a3;
  v9 = sqrt(v8 + 1.0);
  *(float *)(a1 + 4 * a3) = 0.5 * v9;
  v10 = 0.5 / v9;
  *(float *)(a1 + 4 * v4) = (*(float *)(a2 + 4 * v7) + *(float *)(a2 + 4 * (v4 + v11))) * v10;
  *(float *)(a1 + 4 * v5) = (*(float *)(a2 + 4 * (3 * v5 + a3)) + *(float *)(a2 + 4 * (v5 + v11))) * v10;
  *(float *)(a1 + 12) = (*(float *)(a2 + 4 * (v4 + 3 * v5)) - *(float *)(a2 + 4 * (v5 + 3 * v4))) * v10;
  return result;
}

//----- (10018BC0) --------------------------------------------------------
float *__cdecl sub_10018BC0(float *a1, float *a2, float *a3)
{
  double v3; // st7
  double v4; // st6
  double v5; // st5
  double v6; // st4
  float *result; // eax
  float v8; // [esp+0h] [ebp-Ch]
  float v9; // [esp+0h] [ebp-Ch]
  float v10; // [esp+8h] [ebp-4h]
  float v11; // [esp+8h] [ebp-4h]
  float v12; // [esp+14h] [ebp+8h]

  v3 = a2[3];
  v4 = a3[3];
  v10 = *a2 * a3[1] - a2[1] * *a3;
  v8 = v3 * *a3 + a2[1] * a3[2] - a2[2] * a3[1];
  v11 = v3 * a3[2] + v10;
  v9 = v4 * *a2 + v8;
  v5 = v3 * a3[1] + a2[2] * *a3 - a3[2] * *a2 + v4 * a2[1];
  v6 = v4 * a2[2] + v11;
  result = a1;
  v12 = a2[2] * a3[2] + a2[1] * a3[1] + *a2 * *a3;
  *a1 = v9;
  a1[1] = v5;
  a1[2] = v6;
  a1[3] = v4 * v3 - v12;
  return result;
}

//----- (10018C80) --------------------------------------------------------
float *__cdecl sub_10018C80(float *a1, float *a2)
{
  double v2; // st7
  double v3; // st6
  double v4; // st5
  double v5; // st4
  double v6; // st3
  float *result; // eax
  double v8; // st2
  float v9; // edx
  float v10; // [esp+4h] [ebp-18h]
  float v11; // [esp+8h] [ebp-14h]
  float v12; // [esp+Ch] [ebp-10h]
  float v13; // [esp+10h] [ebp-Ch]
  float v14; // [esp+14h] [ebp-8h]
  float v15; // [esp+18h] [ebp-4h]
  float v16; // [esp+20h] [ebp+4h]
  float v17; // [esp+24h] [ebp+8h]

  v2 = *a2 * *a2;
  v3 = a2[1] * a2[1];
  v4 = a2[2] * a2[2];
  v5 = a2[1] * *a2;
  v10 = a2[2] * *a2;
  v14 = a2[3] * *a2;
  v13 = a2[2] * a2[1];
  v11 = a2[1] * a2[3];
  v6 = a2[2] * a2[3];
  result = a1;
  v8 = *a1;
  v9 = a1[2];
  v17 = a1[1];
  v12 = v8 + v8;
  v15 = v17 + v17;
  v16 = v9 + v9;
  *result = (1.0 - (v4 + v3 + v4 + v3)) * v8 + (v5 - v6) * v15 + (v11 + v10) * v16;
  result[1] = (1.0 - (v4 + v2 + v4 + v2)) * v17 + (v13 - v14) * v16 + (v6 + v5) * v12;
  result[2] = (1.0 - (v3 + v2 + v3 + v2)) * v9 + (v10 - v11) * v12 + (v13 + v14) * v15;
  return result;
}

//----- (10018D90) --------------------------------------------------------
int __cdecl sub_10018D90(int a1, float *a2)
{
  int v2; // edx
  double v4; // st7
  double v5; // st6
  int result; // eax
  float v7; // [esp+0h] [ebp-10h]
  float v8; // [esp+4h] [ebp-Ch]
  float v9; // [esp+8h] [ebp-8h]
  float i; // [esp+Ch] [ebp-4h]
  float v11; // [esp+14h] [ebp+4h]
  float v12; // [esp+18h] [ebp+8h]

  v2 = a1;
  v7 = 0.0;
  v8 = 0.0;
  v9 = 0.0;
  for ( i = 0.0; v2; i = v12 )
  {
    v4 = *a2;
    v5 = a2[1];
    v11 = a2[2];
    v12 = a2[3];
    if ( v12 * i + v11 * v9 + v5 * v8 + v4 * v7 < 0.0 )
    {
      v4 = -v4;
      v5 = -v5;
      v11 = -v11;
      v12 = -v12;
    }
    v7 = v4;
    a2[2] = v11;
    v9 = v11;
    result = LODWORD(v12);
    *a2 = v4;
    a2[3] = v12;
    v8 = v5;
    a2 += 4;
    --v2;
    *(a2 - 3) = v8;
  }
  return result;
}

//----- (10018E60) --------------------------------------------------------
char __cdecl sub_10018E60(int a1, float a2, int a3, int a4)
{
  double v4; // st7
  int v5; // ebx
  double v6; // st6
  double v7; // st6
  double v8; // st7
  double v9; // st6
  int v10; // edx
  double v11; // st7
  double v12; // st7
  double v13; // st7
  double v14; // st7
  long double v15; // st7
  long double v16; // st6
  long double v17; // st5
  long double v18; // st5
  long double v19; // st5
  long double v20; // st5
  long double v21; // st5
  long double v22; // st5
  long double v23; // st5
  float v25; // [esp+14h] [ebp-64h]
  float v26; // [esp+18h] [ebp-60h]
  float v27; // [esp+20h] [ebp-58h]
  long double v28; // [esp+20h] [ebp-58h]
  float v29; // [esp+28h] [ebp-50h]
  long double v30; // [esp+28h] [ebp-50h]
  float v31; // [esp+30h] [ebp-48h]
  long double v32; // [esp+30h] [ebp-48h]
  float v33; // [esp+38h] [ebp-40h]
  long double v34; // [esp+38h] [ebp-40h]
  float v35; // [esp+40h] [ebp-38h]
  long double v36; // [esp+40h] [ebp-38h]
  float v37; // [esp+48h] [ebp-30h]
  long double v38; // [esp+48h] [ebp-30h]
  float v39; // [esp+50h] [ebp-28h]
  float v40[9]; // [esp+54h] [ebp-24h] BYREF

  v4 = *(float *)(a1 + 16) * *(float *)(a1 + 32);
  v5 = 0;
  v6 = *(float *)(a1 + 20);
  v40[0] = 1.0;
  v7 = v6 * *(float *)(a1 + 28);
  memset(&v40[1], 0, 12);
  v40[4] = 1.0;
  memset(&v40[5], 0, 12);
  v8 = (v4 - v7) * *(float *)a1;
  v9 = *(float *)(a1 + 12) * *(float *)(a1 + 32);
  v40[8] = -1.0;
  if ( v8
     - (v9 - *(float *)(a1 + 20) * *(float *)(a1 + 24)) * *(float *)(a1 + 4)
     + (*(float *)(a1 + 12) * *(float *)(a1 + 28) - *(float *)(a1 + 16) * *(float *)(a1 + 24)) * *(float *)(a1 + 8) < 0.0 )
  {
    sub_10018450((float *)a3, (float *)a1, v40);
  }
  else
  {
    *(_DWORD *)a3 = *(_DWORD *)a1;
    *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a3 + 20) = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a3 + 24) = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a3 + 28) = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a3 + 32) = *(_DWORD *)(a1 + 32);
  }
  v10 = a4;
  while ( 1 )
  {
    sub_100181D0((float *)v10, (float *)a3);
    v11 = *(float *)(v10 + 4);
    *(_DWORD *)(v10 + 4) = *(_DWORD *)(v10 + 12);
    *(float *)(v10 + 12) = v11;
    v12 = *(float *)(v10 + 8);
    *(_DWORD *)(v10 + 8) = *(_DWORD *)(v10 + 24);
    *(float *)(v10 + 24) = v12;
    v13 = *(float *)(v10 + 20);
    *(_DWORD *)(v10 + 20) = *(_DWORD *)(v10 + 28);
    *(float *)(v10 + 28) = v13;
    *(float *)v10 = *(float *)a3 + *(float *)v10;
    *(float *)(v10 + 4) = *(float *)(v10 + 4) + *(float *)(a3 + 4);
    *(float *)(v10 + 8) = *(float *)(v10 + 8) + *(float *)(a3 + 8);
    *(float *)(v10 + 12) = *(float *)(v10 + 12) + *(float *)(a3 + 12);
    *(float *)(v10 + 16) = *(float *)(a3 + 16) + *(float *)(v10 + 16);
    *(float *)(v10 + 20) = *(float *)(v10 + 20) + *(float *)(a3 + 20);
    *(float *)(v10 + 24) = *(float *)(a3 + 24) + *(float *)(v10 + 24);
    *(float *)(v10 + 28) = *(float *)(v10 + 28) + *(float *)(a3 + 28);
    *(float *)(v10 + 32) = *(float *)(a3 + 32) + *(float *)(v10 + 32);
    v25 = *(float *)v10 * 0.5;
    v14 = *(float *)(v10 + 4) * 0.5;
    *(float *)v10 = v25;
    v26 = v14;
    *(float *)(v10 + 4) = v14;
    v27 = *(float *)(v10 + 8) * 0.5;
    *(float *)(v10 + 8) = v27;
    v29 = *(float *)(v10 + 12) * 0.5;
    *(float *)(v10 + 12) = v29;
    v31 = *(float *)(v10 + 16) * 0.5;
    *(float *)(v10 + 16) = v31;
    v33 = *(float *)(v10 + 20) * 0.5;
    *(float *)(v10 + 20) = v33;
    v35 = *(float *)(v10 + 24) * 0.5;
    *(float *)(v10 + 24) = v35;
    v37 = *(float *)(v10 + 28) * 0.5;
    *(float *)(v10 + 28) = v37;
    v39 = *(float *)(v10 + 32) * 0.5;
    *(float *)(v10 + 32) = v39;
    v15 = v25 - *(float *)a3;
    *(float *)a3 = v25;
    v16 = v26 - *(float *)(a3 + 4);
    *(_DWORD *)(a3 + 4) = *(_DWORD *)(v10 + 4);
    v17 = v27 - *(float *)(a3 + 8);
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(v10 + 8);
    v28 = v17;
    v18 = v29 - *(float *)(a3 + 12);
    *(_DWORD *)(a3 + 12) = *(_DWORD *)(v10 + 12);
    v30 = v18;
    v19 = v31 - *(float *)(a3 + 16);
    *(_DWORD *)(a3 + 16) = *(_DWORD *)(v10 + 16);
    v32 = v19;
    v20 = v33 - *(float *)(a3 + 20);
    *(_DWORD *)(a3 + 20) = *(_DWORD *)(v10 + 20);
    v34 = v20;
    v21 = v35 - *(float *)(a3 + 24);
    *(_DWORD *)(a3 + 24) = *(_DWORD *)(v10 + 24);
    v36 = v21;
    v22 = v37 - *(float *)(a3 + 28);
    *(_DWORD *)(a3 + 28) = *(_DWORD *)(v10 + 28);
    v38 = v22;
    v23 = v39 - *(float *)(a3 + 32);
    *(_DWORD *)(a3 + 32) = *(_DWORD *)(v10 + 32);
    if ( fabs(v15) + fabs(v16) + fabs(v28) + fabs(v30) + fabs(v32) + fabs(v34) + fabs(v36) + fabs(v38) + fabs(v23) < a2 )
      break;
    if ( ++v5 >= 1000 )
    {
      sub_10018540((float *)v10, (float *)a3, (float *)a1);
      return 0;
    }
  }
  sub_10018540((float *)v10, (float *)a3, (float *)a1);
  return 1;
}
// 10018F52: variable 'v10' is possibly undefined

//----- (100191A0) --------------------------------------------------------
float *__cdecl sub_100191A0(float *a1, float *a2, float *a3)
{
  float *result; // eax
  double v4; // st7
  double v5; // st6
  double v6; // st5

  result = a3;
  v4 = *a3;
  v5 = a3[1];
  v6 = a3[2];
  *a3 = v6 * a2[2] + v5 * a2[1] + v4 * *a2;
  a3[1] = v6 * a2[5] + v5 * a2[4] + v4 * a2[3];
  a3[2] = v6 * a2[8] + v5 * a2[7] + v4 * a2[6];
  *a3 = *a1 + *a3;
  a3[1] = a1[1] + a3[1];
  a3[2] = a1[2] + a3[2];
  return result;
}

//----- (10019210) --------------------------------------------------------
int __cdecl sub_10019210(float *a1, float *a2, float *a3)
{
  double v4; // st7
  int result; // eax
  float v7[9]; // [esp+4h] [ebp-48h] BYREF
  float v8[9]; // [esp+28h] [ebp-24h] BYREF
  float v9; // [esp+58h] [ebp+Ch]

  v9 = sqrt(*a3 * *a3 + a3[1] * a3[1] + a3[2] * a3[2] + a3[3] * a3[3]);
  v4 = 1.0 / v9;
  *a3 = v4 * *a3;
  a3[1] = v4 * a3[1];
  a3[2] = v4 * a3[2];
  a3[3] = v4 * a3[3];
  sub_100189A0(v7, a3);
  sub_10018450(v8, a1, v7);
  sub_10018450(v7, v8, a2);
  result = sub_10018A70(a3, v7);
  *a3 = v9 * *a3;
  a3[1] = v9 * a3[1];
  a3[2] = v9 * a3[2];
  a3[3] = v9 * a3[3];
  return result;
}

//----- (100192E0) --------------------------------------------------------
float *__cdecl sub_100192E0(float *a1, float *a2, float *a3)
{
  float v4[9]; // [esp+4h] [ebp-24h] BYREF

  sub_10018450(v4, a1, a3);
  return sub_10018450(a3, v4, a2);
}

//----- (10019310) --------------------------------------------------------
float *__cdecl sub_10019310(float *a1, float *a2, float *a3, float *a4, float *a5, float *a6)
{
  sub_100191A0(a1, a2, a4);
  sub_10019210(a2, a3, a5);
  return sub_100192E0(a2, a3, a6);
}

//----- (10019350) --------------------------------------------------------
int __cdecl sub_10019350(float *a1, float *a2, float *a3, float *a4)
{
  int v4; // ecx
  int v5; // edx
  int v6; // eax
  int v7; // ecx
  int v8; // edx
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  int v12; // ecx
  int v13; // edx
  int v14; // eax
  int v15; // ecx
  int v16; // edx
  int result; // eax
  int v18; // ecx
  int v19; // edx
  float v20[4]; // [esp+4h] [ebp-34h] BYREF
  float v21; // [esp+14h] [ebp-24h] BYREF
  int v22; // [esp+18h] [ebp-20h]
  int v23; // [esp+1Ch] [ebp-1Ch]
  int v24; // [esp+20h] [ebp-18h]
  int v25; // [esp+24h] [ebp-14h]
  int v26; // [esp+28h] [ebp-10h]
  int v27; // [esp+2Ch] [ebp-Ch]
  int v28; // [esp+30h] [ebp-8h]
  int v29; // [esp+34h] [ebp-4h]

  v4 = *((_DWORD *)a4 + 4);
  v5 = *((_DWORD *)a4 + 8);
  v21 = *a4;
  v6 = *((_DWORD *)a4 + 1);
  v22 = v4;
  v7 = *((_DWORD *)a4 + 5);
  v23 = v5;
  v8 = *((_DWORD *)a4 + 9);
  v24 = v6;
  v9 = *((_DWORD *)a4 + 2);
  v25 = v7;
  v10 = *((_DWORD *)a4 + 6);
  v26 = v8;
  v11 = *((_DWORD *)a4 + 10);
  v27 = v9;
  v28 = v10;
  v29 = v11;
  memset(v20, 0, 12);
  v20[3] = 1.0;
  sub_10019310(a1, a2, a3, a4 + 12, v20, &v21);
  v12 = v22;
  v13 = v23;
  *a4 = v21;
  v14 = v24;
  *((_DWORD *)a4 + 4) = v12;
  v15 = v25;
  *((_DWORD *)a4 + 8) = v13;
  v16 = v26;
  *((_DWORD *)a4 + 1) = v14;
  result = v27;
  *((_DWORD *)a4 + 5) = v15;
  v18 = v28;
  *((_DWORD *)a4 + 9) = v16;
  v19 = v29;
  *((_DWORD *)a4 + 2) = result;
  *((_DWORD *)a4 + 6) = v18;
  *((_DWORD *)a4 + 10) = v19;
  return result;
}

//----- (10019420) --------------------------------------------------------
int __cdecl sub_10019420(int a1, int a2, _DWORD *a3)
{
  *a3 = 1;
  a3[1] = a1;
  a3[2] = a2;
  a3[3] = 1;
  if ( a1 )
    a3[4] = 21;
  return sub_10019460(a3);
}

//----- (10019460) --------------------------------------------------------
int __cdecl sub_10019460(_DWORD *a1)
{
  int result; // eax
  _DWORD *v2; // eax
  bool v3; // zf
  int *v4; // edi
  int *v5; // edi
  _DWORD *v6; // ebx
  int v7; // ebp

  a1[10] = a1 + 7;
  a1[9] = a1 + 8;
  a1[11] = a1 + 6;
  a1[12] = 0;
  a1[13] = 0;
  result = sub_100195B0(a1);
  if ( (_BYTE)result )
  {
    v2 = (_DWORD *)a1[1];
    a1[4] = *v2;
    if ( *a1 == 1 )
      a1[5] = sub_10001990((int)v2);
    a1[7] = *(_DWORD *)(a1[1] + 8);
    v3 = *a1 == 0;
    a1[8] = 1;
    v4 = (int *)a1[2];
    a1[6] = 0;
    if ( v3 )
    {
LABEL_8:
      a1[11] = v4;
    }
    else
    {
      switch ( a1[4] )
      {
        case 2:
        case 8:
          goto LABEL_8;
        case 3:
        case 4:
          a1[9] = v4;
          a1[12] = v4 + 1;
          break;
        case 5:
          a1[10] = v4++;
          goto LABEL_8;
        case 6:
          v6 = (_DWORD *)sub_10001BB0(*(_DWORD **)a1[10]);
          a1[13] = v4;
          v7 = *v4;
          if ( v7 < sub_10001BD0(v6) )
            a1[7] = v6[v7];
          ++v4;
          goto LABEL_8;
        case 7:
          a1[10] = v4;
          a1[9] = v4 + 1;
          a1[12] = v4 + 2;
          break;
        default:
          break;
      }
    }
    v5 = (int *)a1[9];
    result = *v5 * sub_10001B90(a1[1]);
    *v5 = result;
  }
  return result;
}

//----- (10019560) --------------------------------------------------------
int __cdecl sub_10019560(int a1, _DWORD *a2, int a3, int a4, _DWORD *a5)
{
  int v5; // eax
  _DWORD *v6; // edx

  a5[2] = a4;
  *a5 = a1;
  a5[1] = a2;
  a5[3] = a3;
  if ( a3 && a2 )
  {
    v5 = sub_100019C0(a2);
    v6 = (_DWORD *)a5[1];
    a5[5] = v5;
    a5[4] = *v6;
  }
  return sub_10019460(a5);
}

//----- (100195B0) --------------------------------------------------------
BOOL __cdecl sub_100195B0(_DWORD *a1)
{
  return a1[1] && a1[4] && a1[2] && a1[3];
}

//----- (100195E0) --------------------------------------------------------
int __cdecl sub_100195E0(int *a1)
{
  int v1; // ecx

  v1 = *a1;
  if ( !*a1 )
  {
    a1[2] += 4;
LABEL_3:
    --a1[3];
    return sub_10019460(a1);
  }
  a1[2] += a1[5];
  if ( v1 != 1 )
    goto LABEL_3;
  a1[1] += 32;
  return sub_10019460(a1);
}

//----- (10019620) --------------------------------------------------------
int __cdecl sub_10019620(int a1, _DWORD *a2)
{
  if ( *(_DWORD *)a1 == 1 )
    return sub_10019420(**(_DWORD **)(a1 + 40), **(_DWORD **)(a1 + 44), a2);
  sub_10017FE0(
    3,
    25,
    "%s(%d): Illegal iterator type (%d) in IterateOverSubMembers",
    aWPublicGrannyR_13,
    208,
    *(_DWORD *)a1);
  return sub_10019560(0, 0, 0, 0, a2);
}

//----- (10019680) --------------------------------------------------------
int __cdecl sub_10019680(int a1, _DWORD *a2)
{
  if ( *(_DWORD *)(a1 + 16) != 3 )
  {
    if ( *(_DWORD *)(a1 + 16) == 4 )
      return sub_10019560(0, **(_DWORD ***)(a1 + 40), **(_DWORD **)(a1 + 36), **(_DWORD **)(a1 + 48), a2);
    if ( *(_DWORD *)(a1 + 16) != 7 )
    {
      sub_10017FE0(
        3,
        25,
        "%s(%d): Illegal iterator type (%d) in IterateOverSubMembers",
        aWPublicGrannyR_13,
        244,
        *(_DWORD *)a1);
      return sub_10019560(0, 0, 0, 0, a2);
    }
  }
  return sub_10019560(2, **(_DWORD ***)(a1 + 40), **(_DWORD **)(a1 + 36), **(_DWORD **)(a1 + 48), a2);
}

//----- (10019710) --------------------------------------------------------
int __cdecl sub_10019710(int a1, _DWORD *a2)
{
  if ( !*(_DWORD *)a1 )
    return sub_10019420(*(_DWORD *)(a1 + 4), **(_DWORD **)(a1 + 8), a2);
  if ( *(_DWORD *)a1 == 2 )
    return sub_10019420(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2);
  return sub_10019560(0, 0, 0, 0, a2);
}

//----- (10019770) --------------------------------------------------------
int __cdecl sub_10019770(const char *a1, int a2, unsigned int a3, int a4)
{
  SIZE_T v4; // ebp
  LPVOID v5; // eax
  LPVOID v6; // edi
  int v7; // esi
  unsigned int v8; // edx
  int v9; // eax

  v4 = a3 + a4 + 31;
  v5 = sub_10019F80(v4);
  v6 = v5;
  if ( v5 )
  {
    v7 = (int)v5 + 32;
    v8 = ((unsigned int)v5 + 32) % a3;
    if ( v8 )
      v7 += a3 - v8;
    v9 = sub_10019830(v7);
    *(_DWORD *)(v9 + 16) = a1;
    *(_DWORD *)(v9 + 8) = v6;
    *(_DWORD *)(v9 + 12) = v4;
    *(_DWORD *)v9 = -899757474;
    *(_DWORD *)(v9 + 20) = a2;
    *(_DWORD *)(v9 + 4) = a4;
    *(_DWORD *)(v9 + 24) = off_10033614;
    *(_DWORD *)(v9 + 28) = &unk_100335FC;
    *((_DWORD *)off_10033614 + 7) = v9;
    off_10033614 = (_UNKNOWN *)v9;
    return v7;
  }
  else
  {
    sub_10017FE0(
      3,
      40,
      "%s(%d): Unable to allocate %d bytes (%d requested by %s:%d).",
      aWPublicGrannyR_3,
      142,
      v4,
      a4,
      a1,
      a2);
    return 0;
  }
}
// 10017FE0: using guessed type _DWORD sub_10017FE0(_DWORD, _DWORD, _DWORD, ...);
// 10033614: using guessed type _UNKNOWN *off_10033614;

//----- (10019830) --------------------------------------------------------
int __cdecl sub_10019830(int a1)
{
  return a1 - 32;
}

//----- (10019840) --------------------------------------------------------
void __cdecl sub_10019840(const char *a1, int a2, int a3)
{
  int v3; // esi
  int v4; // eax
  int v5; // ecx

  if ( a3 )
  {
    v3 = sub_10019830(a3);
    if ( sub_100198B0((_DWORD *)v3) )
    {
      v4 = *(_DWORD *)(v3 + 24);
      v5 = *(_DWORD *)(v3 + 28);
      *(_DWORD *)(v3 + 4) = -1;
      *(_DWORD *)(v4 + 28) = v5;
      *(_DWORD *)(*(_DWORD *)(v3 + 28) + 24) = *(_DWORD *)(v3 + 24);
      sub_10019FA0(*(LPVOID *)(v3 + 8));
    }
    else
    {
      sub_10017FE0(
        3,
        40,
        "%s(%d): %s:%d Attempted to free 0x%x, which was not allocated by this allocator.",
        aWPublicGrannyR_3,
        187,
        a1,
        a2,
        a3);
    }
  }
}
// 10017FE0: using guessed type _DWORD sub_10017FE0(_DWORD, _DWORD, _DWORD, ...);

//----- (100198B0) --------------------------------------------------------
BOOL __cdecl sub_100198B0(_DWORD *a1)
{
  return a1 && *a1 == -899757474 && a1[1] != -1;
}

//----- (100198D0) --------------------------------------------------------
void *GrannyAllocationsBegin()
{
  return off_10033614;
}
// 10033614: using guessed type _UNKNOWN *off_10033614;

//----- (100198E0) --------------------------------------------------------
int __cdecl sub_100198E0(int a1)
{
  return *(_DWORD *)(a1 + 24);
}

//----- (100198F0) --------------------------------------------------------
void *GrannyAllocationsEnd()
{
  return &unk_100335FC;
}

//----- (10019900) --------------------------------------------------------
int __cdecl sub_10019900(_DWORD *a1, int *a2)
{
  int result; // eax

  *a2 = sub_10019940((int)a1);
  a2[1] = a1[1];
  a2[2] = a1[1] + 32;
  result = a1[4];
  a2[3] = result;
  a2[4] = a1[5];
  return result;
}

//----- (10019940) --------------------------------------------------------
int __cdecl sub_10019940(int a1)
{
  return a1 + 32;
}

//----- (10019950) --------------------------------------------------------
int GrannyBeginAllocationCheck()
{
  return off_10033620((int)aWPublicGrannyR_3, 239, 4, 0);
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (10019980) --------------------------------------------------------
bool __cdecl sub_10019980(int a1)
{
  void *v1; // eax
  bool v2; // bl
  _DWORD *v3; // esi
  int i; // edi
  int v6[5]; // [esp+10h] [ebp-14h] BYREF

  v1 = (void *)sub_10019830(a1);
  v2 = v1 == off_10033614;
  if ( v1 != off_10033614 )
  {
    v3 = GrannyAllocationsBegin();
    for ( i = sub_10019970(a1); v3 != (_DWORD *)i; v3 = (_DWORD *)sub_100198E0((int)v3) )
    {
      sub_10019900(v3, v6);
      sub_10017FE0(
        2,
        40,
        "%s(%d): Unfreed block %s:%d (%d bytes at 0x%x)",
        aWPublicGrannyR_3,
        269,
        (const char *)v6[3],
        v6[4],
        v6[1],
        v6[0]);
    }
  }
  off_10033624((int)aWPublicGrannyR_3, 275, a1);
  return v2;
}
// 10033614: using guessed type _UNKNOWN *off_10033614;
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10019A40) --------------------------------------------------------
int sub_10019A40()
{
  int result; // eax

  result = dword_1003361C;
  dword_10047438 = dword_1003361C;
  return result;
}
// 1003361C: using guessed type int dword_1003361C;
// 10047438: using guessed type int dword_10047438;

//----- (10019A50) --------------------------------------------------------
int __cdecl sub_10019A50(int a1)
{
  int result; // eax

  result = a1;
  dword_1003361C = a1;
  return result;
}
// 1003361C: using guessed type int dword_1003361C;

//----- (10019A60) --------------------------------------------------------
int __cdecl sub_10019A60(_DWORD *a1, int a2)
{
  return dword_10046D44[7 * sub_10019A80(a1, a2)];
}
// 10046D44: using guessed type int dword_10046D44[445];

//----- (10019A80) --------------------------------------------------------
int __cdecl sub_10019A80(_DWORD *a1, int a2)
{
  int v2; // eax
  int v3; // edx
  char *v4; // ecx
  int v5; // ecx

  v2 = sub_10019AE0(dword_1004743C);
  v3 = dword_10047440++;
  v4 = (char *)&unk_10046D38 + 28 * v3;
  *((_DWORD *)v4 + 3) = v2;
  *((_DWORD *)v4 + 1) = a1;
  *v4 = 0;
  *((_DWORD *)v4 + 2) = 0;
  *((_DWORD *)v4 + 4) = -1;
  v5 = *((_DWORD *)v4 + 3);
  dword_1004743C = a2 + v2;
  *a1 = v5;
  return v3;
}
// 1004743C: using guessed type int dword_1004743C;
// 10047440: using guessed type int dword_10047440;

//----- (10019AE0) --------------------------------------------------------
int __cdecl sub_10019AE0(int a1)
{
  int v1; // esi

  if ( dword_10047438 < dword_1003361C )
    dword_10047438 = dword_1003361C;
  v1 = a1;
  if ( a1 % dword_1003361C )
    return dword_1003361C - a1 % dword_1003361C + a1;
  return v1;
}
// 1003361C: using guessed type int dword_1003361C;
// 10047438: using guessed type int dword_10047438;

//----- (10019B10) --------------------------------------------------------
int __cdecl sub_10019B10(int a1, int a2)
{
  return dword_10046D44[7 * sub_10019B30(a1, a2)];
}
// 10046D44: using guessed type int dword_10046D44[445];

//----- (10019B30) --------------------------------------------------------
int __cdecl sub_10019B30(int a1, int a2)
{
  int v2; // eax
  int v3; // edx
  char *v4; // ecx

  v2 = sub_10019AE0(dword_1004743C);
  v3 = dword_10047440++;
  v4 = (char *)&unk_10046D38 + 28 * v3;
  *((_DWORD *)v4 + 3) = v2;
  *((_DWORD *)v4 + 2) = a1;
  *((_DWORD *)v4 + 1) = 0;
  *v4 = 0;
  *((_DWORD *)v4 + 4) = -1;
  dword_1004743C = a2 + v2;
  return v3;
}
// 1004743C: using guessed type int dword_1004743C;
// 10047440: using guessed type int dword_10047440;

//----- (10019B90) --------------------------------------------------------
int __cdecl sub_10019B90(int a1, int a2, int a3)
{
  return dword_10046D44[7 * sub_10019B30(a2 + a1, a3)];
}
// 10046D44: using guessed type int dword_10046D44[445];

//----- (10019BC0) --------------------------------------------------------
int __cdecl sub_10019BC0(int a1, int a2, int a3, int a4, int a5)
{
  return dword_10046D44[7 * sub_10019C00(a2 + a1, a1 + a3, a4, a5 * a4)];
}
// 10046D44: using guessed type int dword_10046D44[445];

//----- (10019C00) --------------------------------------------------------
int __cdecl sub_10019C00(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // edx
  char *v6; // ecx

  v4 = sub_10019AE0(dword_1004743C);
  v5 = dword_10047440++;
  v6 = (char *)&unk_10046D38 + 28 * v5;
  *((_DWORD *)v6 + 2) = a2;
  *((_DWORD *)v6 + 4) = a3;
  *((_DWORD *)v6 + 3) = v4;
  *((_DWORD *)v6 + 5) = a1;
  *((_DWORD *)v6 + 1) = 0;
  *v6 = 0;
  dword_1004743C = a4 + v4;
  return v5;
}
// 1004743C: using guessed type int dword_1004743C;
// 10047440: using guessed type int dword_10047440;

//----- (10019C60) --------------------------------------------------------
int __cdecl sub_10019C60(int a1, int a2)
{
  int v2; // esi

  v2 = off_10033620(a1, a2, dword_10047438, dword_1004743C);
  sub_10019CA0(v2);
  sub_10019D30();
  return v2;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10047438: using guessed type int dword_10047438;
// 1004743C: using guessed type int dword_1004743C;

//----- (10019CA0) --------------------------------------------------------
void __cdecl sub_10019CA0(int a1)
{
  int v1; // edi
  _DWORD *v2; // eax
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  _DWORD *v6; // eax

  if ( a1 )
  {
    v1 = 0;
    if ( dword_10047440 > 0 )
    {
      v2 = &unk_10046D3C;
      do
      {
        v3 = v2[2];
        if ( !*((_BYTE *)v2 - 4) )
          v3 += a1;
        if ( *v2 )
        {
          *(_DWORD *)*v2 = v3;
        }
        else
        {
          *(_DWORD *)(a1 + v2[1]) = v3;
          v4 = v2[3];
          if ( v4 != -1 )
            *(_DWORD *)(a1 + v2[4]) = v4;
        }
        ++v1;
        v2 += 7;
      }
      while ( v1 < dword_10047440 );
    }
  }
  else
  {
    v5 = dword_10047440;
    if ( dword_10047440 > 0 )
    {
      v6 = &unk_10046D3C;
      do
      {
        if ( *v6 )
          *v6 = 0;
        v6 += 7;
        --v5;
      }
      while ( v5 );
    }
  }
}
// 10047440: using guessed type int dword_10047440;

//----- (10019D30) --------------------------------------------------------
int sub_10019D30()
{
  int result; // eax

  dword_1004743C = 0;
  dword_10047440 = 0;
  result = 4;
  dword_1003361C = 4;
  dword_10047438 = 4;
  return result;
}
// 1003361C: using guessed type int dword_1003361C;
// 10047438: using guessed type int dword_10047438;
// 1004743C: using guessed type int dword_1004743C;
// 10047440: using guessed type int dword_10047440;

//----- (10019D50) --------------------------------------------------------
int __cdecl sub_10019D50(int a1, int a2, int a3)
{
  sub_10019CA0(a3);
  sub_10019D30();
  return a3;
}

//----- (10019D70) --------------------------------------------------------
int sub_10019D70()
{
  int v0; // ecx

  sub_10019D30();
  return v0;
}
// 10019D7B: variable 'v0' is possibly undefined
// 1004743C: using guessed type int dword_1004743C;

//----- (10019D80) --------------------------------------------------------
void __usercall sub_10019D80(int a1@<ebx>, unsigned int a2, char a3, char *a4)
{
  int v4; // eax

  if ( a2 )
  {
    LOBYTE(a1) = a3;
    BYTE1(a1) = a3;
    v4 = a1 << 16;
    LOWORD(v4) = a1;
    memset32(a4, v4, a2 >> 2);
    memset(&a4[4 * (a2 >> 2)], a3, a2 & 3);
  }
}
// 10019D80: could not find valid save-restore pair for ebx

//----- (10019DC0) --------------------------------------------------------
int __cdecl sub_10019DC0(unsigned int a1, int a2, void *a3)
{
  int result; // eax

  if ( a1 )
  {
    result = a2;
    memset32(a3, a2, a1);
  }
  return result;
}

//----- (10019DE0) --------------------------------------------------------
int __cdecl sub_10019DE0(int a1, float a2, float *a3)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    *a3 = a2;
    qmemcpy(a3 + 1, a3, 4 * ((unsigned int)(4 * a1 - 1) >> 2));
  }
  return result;
}

//----- (10019E10) --------------------------------------------------------
_BYTE *__cdecl sub_10019E10(int a1, _BYTE *a2, int a3)
{
  _BYTE *result; // eax
  int i; // esi

  result = a2;
  for ( i = a1; i; --i )
  {
    result[a3 - (_DWORD)a2] = *result;
    ++result;
  }
  return result;
}

//----- (10019E30) --------------------------------------------------------
_DWORD *__cdecl sub_10019E30(int a1, _DWORD *a2, int a3)
{
  int v3; // edx
  _DWORD *result; // eax

  v3 = a1;
  for ( result = a2; v3; --v3 )
  {
    *(_DWORD *)((char *)result + a3 - (_DWORD)a2) = *result;
    ++result;
  }
  return result;
}

//----- (10019E50) --------------------------------------------------------
char __cdecl sub_10019E50(int a1, char *a2, int a3)
{
  char *v3; // eax
  int v4; // esi
  char v5; // cl
  char v6; // dl

  v3 = a2;
  v4 = a1;
  if ( !a1 )
    return 1;
  while ( 1 )
  {
    v5 = *v3;
    v6 = v3[a3 - (_DWORD)a2];
    --v4;
    ++v3;
    if ( v5 != v6 )
      break;
    if ( !v4 )
      return 1;
  }
  return 0;
}

//----- (10019E80) --------------------------------------------------------
int __cdecl sub_10019E80(int a1, unsigned int *a2)
{
  int result; // eax
  int v4; // edx

  result = a1 / 4;
  if ( a1 / 4 )
  {
    v4 = a1 / 4;
    do
    {
      result = *a2 << 16;
      *a2 = ((result | *a2 & 0xFF00) << 8) | ((HIWORD(*a2) | *a2 & 0xFF0000) >> 8);
      ++a2;
      --v4;
    }
    while ( v4 );
  }
  return result;
}

//----- (10019EE0) --------------------------------------------------------
int __cdecl sub_10019EE0(int a1, int *a2)
{
  int result; // eax
  int v4; // esi

  result = a1 / 4;
  if ( a1 / 4 )
  {
    v4 = a1 / 4;
    do
    {
      result = (*a2 << 8) ^ ((*a2 << 8) ^ ((unsigned int)*a2 >> 8)) & 0xFF00FF;
      *a2++ = result;
      --v4;
    }
    while ( v4 );
  }
  return result;
}

//----- (10019F20) --------------------------------------------------------
int __cdecl sub_10019F20(int a1)
{
  return off_10033624((int)aWPublicGrannyR_3, 736, a1);
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10019F40) --------------------------------------------------------
int (__cdecl *__cdecl sub_10019F40(_DWORD *a1, _DWORD *a2))(int, int, int)
{
  int (__cdecl *result)(int, int, int); // eax

  *a1 = off_10033620;
  result = off_10033624;
  *a2 = off_10033624;
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10019F60) --------------------------------------------------------
int (__cdecl *__cdecl sub_10019F60(
        int (__cdecl *a1)(int, int, int, int),
        int (__cdecl *a2)(int, int, int)))(int, int, int, int)
{
  int (__cdecl *result)(int, int, int, int); // eax

  result = a1;
  off_10033620 = a1;
  off_10033624 = a2;
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10019F80) --------------------------------------------------------
LPVOID __cdecl sub_10019F80(SIZE_T dwBytes)
{
  HANDLE ProcessHeap; // eax

  ProcessHeap = GetProcessHeap();
  return HeapAlloc(ProcessHeap, 0, dwBytes);
}

//----- (10019FA0) --------------------------------------------------------
BOOL __cdecl sub_10019FA0(LPVOID lpMem)
{
  HANDLE ProcessHeap; // eax

  ProcessHeap = GetProcessHeap();
  return HeapFree(ProcessHeap, 0, lpMem);
}

//----- (10019FC0) --------------------------------------------------------
_DWORD *GrannyNewMemoryArena()
{
  _DWORD *result; // eax

  result = (_DWORD *)off_10033620((int)aWPublicGrannyR_30, 31, 4, 4);
  if ( result )
    *result = 0;
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (10019FE0) --------------------------------------------------------
int __cdecl sub_10019FE0(_DWORD **a1)
{
  int result; // eax

  result = sub_1001A000(*a1);
  *a1 = 0;
  return result;
}

//----- (1001A000) --------------------------------------------------------
int __cdecl sub_1001A000(_DWORD *a1)
{
  _DWORD *i; // esi
  int v2; // eax
  int result; // eax

  for ( i = a1; i; result = off_10033624((int)aWPublicGrannyR_30, 56, v2) )
  {
    v2 = (int)i;
    i = (_DWORD *)*i;
  }
  return result;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (1001A030) --------------------------------------------------------
int __cdecl sub_1001A030(_DWORD *a1, int a2)
{
  int v3; // [esp+0h] [ebp-8h] BYREF
  _DWORD *v4; // [esp+4h] [ebp-4h] BYREF

  v3 = 0;
  sub_10019A60(&v4, 4);
  sub_10019A60(&v3, a2);
  if ( sub_10019C60((int)aWPublicGrannyR_30, 68) )
  {
    *v4 = *a1;
    *a1 = v4;
  }
  return v3;
}

//----- (1001A090) --------------------------------------------------------
_DWORD *__cdecl sub_1001A090(int a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // esi

  v5 = (_DWORD *)off_10033620((int)aWPublicGrannyR_25, 77, 4, 36);
  if ( v5 )
  {
    sub_10014720(a1, a2, (int)sub_1001A0F0, (int)sub_1001A110, v5);
    v5[6] = a3;
    v5[7] = a4;
    v5[8] = a5;
  }
  return v5;
}
// 1001A110: using guessed type int sub_1001A110();
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (1001A0F0) --------------------------------------------------------
int __cdecl sub_1001A0F0(int a1, int a2, int a3)
{
  sub_10014780(a3);
  return off_10033624((int)aWPublicGrannyR_25, 41, a3);
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (1001A160) --------------------------------------------------------
int __cdecl sub_1001A160(int a1)
{
  int v1; // ecx
  int result; // eax

  v1 = *(_DWORD *)(a1 + 16);
  result = 0;
  if ( v1 )
    return *(_DWORD *)v1;
  return result;
}

//----- (1001A170) --------------------------------------------------------
int __cdecl sub_1001A170(int a1)
{
  int v1; // ecx
  int result; // eax

  v1 = *(_DWORD *)(a1 + 16);
  result = 0;
  if ( v1 )
    return *(_DWORD *)(v1 + 4);
  return result;
}

//----- (1001A190) --------------------------------------------------------
int __cdecl sub_1001A190(int a1)
{
  int v1; // ecx
  int result; // eax

  v1 = *(_DWORD *)(a1 + 4);
  result = 0;
  if ( v1 )
    return *(_DWORD *)v1;
  return result;
}

//----- (1001A1A0) --------------------------------------------------------
int __cdecl sub_1001A1A0(int a1)
{
  int v1; // ecx
  int result; // eax

  v1 = *(_DWORD *)(a1 + 4);
  result = 0;
  if ( v1 )
    return *(_DWORD *)(v1 + 4);
  return result;
}

//----- (1001A1C0) --------------------------------------------------------
void __usercall sub_1001A1C0(double a1@<st0>, const char **a2, _DWORD *a3, char *a4)
{
  int v4; // eax
  int v5; // eax
  _DWORD *v6; // [esp-10h] [ebp-14h]
  int v7; // [esp-Ch] [ebp-10h]

  v4 = sub_1001A220((int)a2);
  if ( v4 )
  {
    v7 = v4;
    v6 = (_DWORD *)sub_1001A190((int)a2);
    v5 = sub_1001A1A0((int)a2);
    sub_100252A0(a1, v5, v6, v7, a3, a4);
  }
  else
  {
    sub_10017FE0(3, 15, "%s(%d): Mesh \"%s\" has no vertices.", aWPublicGrannyR_31, 141, *a2);
  }
}

//----- (1001A220) --------------------------------------------------------
int __cdecl sub_1001A220(int a1)
{
  int v1; // ecx
  int result; // eax

  v1 = *(_DWORD *)(a1 + 4);
  result = 0;
  if ( v1 )
    return *(_DWORD *)(v1 + 8);
  return result;
}

//----- (1001A240) --------------------------------------------------------
BOOL __cdecl sub_1001A240(int a1)
{
  return *(_DWORD *)(a1 + 28) == 1;
}

//----- (1001A250) --------------------------------------------------------
int __cdecl sub_1001A250(int a1)
{
  int v1; // ecx
  int result; // eax

  v1 = *(_DWORD *)(a1 + 16);
  result = 0;
  if ( v1 )
  {
    result = *(_DWORD *)(v1 + 8);
    if ( !result )
      return *(_DWORD *)(v1 + 16);
  }
  return result;
}

//----- (1001A270) --------------------------------------------------------
int __cdecl sub_1001A270(int a1)
{
  int v1; // ecx
  int result; // eax

  v1 = *(_DWORD *)(a1 + 16);
  result = 0;
  if ( v1 )
  {
    LOBYTE(result) = *(_DWORD *)(v1 + 8) != 0;
    return 2 * result + 2;
  }
  return result;
}

//----- (1001A290) --------------------------------------------------------
int __cdecl sub_1001A290(int a1)
{
  _DWORD *v1; // ecx
  int result; // eax

  v1 = *(_DWORD **)(a1 + 16);
  result = 0;
  if ( v1 )
  {
    if ( v1[2] )
      return v1[3];
    else
      return v1[5];
  }
  return result;
}

//----- (1001A2B0) --------------------------------------------------------
void __cdecl sub_1001A2B0(const char **a1, unsigned int a2, int *a3)
{
  int v3; // eax
  int v4; // eax
  unsigned int v5; // [esp-10h] [ebp-14h]
  _DWORD *v6; // [esp-Ch] [ebp-10h]

  v3 = sub_1001A290((int)a1);
  if ( v3 )
  {
    v6 = (_DWORD *)v3;
    v5 = sub_1001A270((int)a1);
    v4 = sub_1001A250((int)a1);
    sub_10024C50(v4, v5, v6, a2, a3);
  }
  else
  {
    sub_10017FE0(3, 15, "%s(%d): Mesh \"%s\" has no indices.", aWPublicGrannyR_31, 231, *a1);
  }
}

//----- (1001A310) --------------------------------------------------------
int __cdecl sub_1001A310(float *a1, float *a2, int a3, float *a4)
{
  int j; // ebx
  int k; // edi
  int v6; // eax
  float v7; // ecx
  double v8; // st7
  double v9; // st6
  int v10; // ecx
  double v11; // st5
  double v12; // st7
  double v13; // st7
  double v14; // st7
  int v15; // ecx
  int v16; // edx
  float v17; // ecx
  int result; // eax
  float v19; // edx
  int i; // [esp+8h] [ebp-28h]
  float v21; // [esp+Ch] [ebp-24h]
  float v22; // [esp+10h] [ebp-20h]
  float v23; // [esp+14h] [ebp-1Ch]
  int v24; // [esp+18h] [ebp-18h]
  int v25; // [esp+1Ch] [ebp-14h]
  int v26; // [esp+20h] [ebp-10h]
  float v27; // [esp+24h] [ebp-Ch]
  float v28; // [esp+28h] [ebp-8h]
  float v29; // [esp+2Ch] [ebp-4h]

  v29 = -3.4028235e38;
  v28 = v29;
  v27 = v29;
  v24 = 2139095039;
  v26 = 2139095039;
  v25 = 2139095039;
  for ( i = 0; i < 2; ++i )
  {
    for ( j = 0; j < 2; ++j )
    {
      for ( k = 0; k < 2; ++k )
      {
        if ( k )
        {
          v21 = *a4;
          v6 = a3;
        }
        else
        {
          v6 = a3;
          v21 = *(float *)a3;
        }
        if ( j )
          v7 = a4[1];
        else
          v7 = *(float *)(v6 + 4);
        v22 = v7;
        if ( i )
          v8 = a4[2];
        else
          v8 = *(float *)(v6 + 8);
        v9 = v21;
        v10 = 0;
        v11 = v22;
        v21 = v8 * a2[2] + v22 * a2[1] + v21 * *a2;
        v22 = v9 * a2[3] + v8 * a2[5] + v22 * a2[4];
        v12 = v9 * a2[6] + v11 * a2[7] + v8 * a2[8];
        v21 = v21 + *a1;
        v22 = v22 + a1[1];
        v23 = v12 + a1[2];
        do
        {
          v13 = *(float *)((char *)&v21 + v10);
          if ( *(float *)((char *)&v24 + v10) < v13 )
            v13 = *(float *)((char *)&v24 + v10);
          *(float *)((char *)&v24 + v10) = v13;
          v14 = *(float *)((char *)&v21 + v10);
          if ( *(float *)((char *)&v27 + v10) > v14 )
            v14 = *(float *)((char *)&v27 + v10);
          *(float *)((char *)&v27 + v10) = v14;
          v10 += 4;
        }
        while ( v10 < 12 );
      }
    }
  }
  v15 = v25;
  *(_DWORD *)a3 = v24;
  v16 = v26;
  *(_DWORD *)(a3 + 4) = v15;
  v17 = v28;
  *(_DWORD *)(a3 + 8) = v16;
  result = LODWORD(v27);
  v19 = v29;
  *a4 = v27;
  a4[1] = v17;
  a4[2] = v19;
  return result;
}

//----- (1001A4B0) --------------------------------------------------------
int __cdecl sub_1001A4B0(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // eax

  v3 = sub_1001A510(a1, a2, a3);
  v4 = off_10033620((int)aWPublicGrannyR_33, 68, 4, v3);
  return sub_1001A590(a1, a2, a3, v4);
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (1001A4F0) --------------------------------------------------------
int __cdecl sub_1001A4F0(int a1)
{
  return off_10033624((int)aWPublicGrannyR_33, 76, a1);
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (1001A510) --------------------------------------------------------
int __cdecl sub_1001A510(int a1, int a2, int a3)
{
  sub_1001A540(a1, a2, a3, &a3);
  return sub_10019D70();
}

//----- (1001A540) --------------------------------------------------------
int __cdecl sub_1001A540(int a1, int a2, int a3, int *a4)
{
  int v4; // esi
  int result; // eax

  v4 = *(_DWORD *)(a1 + 28);
  sub_10019A60(a4, 24);
  sub_10019BC0(*a4, 4, 12, v4, 4);
  result = a3;
  if ( a2 != a3 )
    return sub_10019BC0(*a4, 4, 20, v4, 4);
  return result;
}

//----- (1001A590) --------------------------------------------------------
int __cdecl sub_1001A590(int a1, int a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // ebp
  int v6; // edi
  int v7; // eax
  int v8; // eax
  int *v9; // esi
  int *v10; // edi
  char *v11; // ebp
  bool v12; // cc
  _BYTE v14[5]; // [esp+13h] [ebp-Dh] BYREF
  int v15; // [esp+18h] [ebp-8h]
  int v16; // [esp+1Ch] [ebp-4h]
  int v17; // [esp+30h] [ebp+10h]

  v4 = a3;
  v5 = a1;
  v6 = *(_DWORD *)(a1 + 28);
  v14[4] = 0;
  *(_DWORD *)v14 = a2 != a3;
  v16 = v6;
  sub_1001A540(a1, a2, a3, (int *)&v14[1]);
  if ( sub_10019D50((int)aWPublicGrannyR_33, 113, a4) )
  {
    *(_DWORD *)(*(_DWORD *)&v14[1] + 4) = v6;
    **(_DWORD **)&v14[1] = a1;
    *(_DWORD *)(*(_DWORD *)&v14[1] + 8) = a2;
    *(_DWORD *)(*(_DWORD *)&v14[1] + 16) = a3;
    if ( !v14[0] )
      *(_DWORD *)(*(_DWORD *)&v14[1] + 20) = *(_DWORD *)(*(_DWORD *)&v14[1] + 12);
    v7 = 0;
    v15 = 0;
    if ( v6 > 0 )
    {
      v17 = 0;
      while ( 1 )
      {
        v8 = 4 * v7;
        v9 = (int *)(v8 + *(_DWORD *)(*(_DWORD *)&v14[1] + 20));
        v10 = (int *)(v8 + *(_DWORD *)(*(_DWORD *)&v14[1] + 12));
        v11 = *(char **)(v17 + *(_DWORD *)(v5 + 32));
        if ( !sub_10021080(v4, v11, v9) )
          *v9 = 0;
        if ( v14[0] && !sub_10021080(a2, v11, v10) )
          *v10 = 0;
        v7 = v15 + 1;
        v12 = ++v15 < v16;
        v17 += 36;
        if ( !v12 )
          break;
        v4 = a3;
        v5 = a1;
      }
    }
  }
  return *(_DWORD *)&v14[1];
}

//----- (1001A6A0) --------------------------------------------------------
bool __cdecl sub_1001A6A0(int a1)
{
  return *(_DWORD *)(a1 + 8) != *(_DWORD *)(a1 + 16);
}

//----- (1001A6C0) --------------------------------------------------------
int __cdecl sub_1001A6C0(int a1, int a2)
{
  return a2 << 6;
}

//----- (1001A6D0) --------------------------------------------------------
void __cdecl sub_1001A6D0(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5)
{
  int v5; // esi
  int v6; // ecx
  int v8; // edi
  float *v9; // eax

  v5 = a3;
  if ( a3 < 0 || (v6 = a1[1], a3 >= v6) )
  {
    sub_10017FE0(3, 37, "%s(%d): FirstBoneIndex %d is out of range [0, %d)", aWPublicGrannyR_33, 171, a3, a1[1]);
  }
  else if ( a3 + a4 < 0 || a3 + a4 >= v6 + 1 )
  {
    sub_10017FE0(
      3,
      37,
      "%s(%d): FirstBoneIndex + BoneCount %d is out of range [0, %d)",
      aWPublicGrannyR_33,
      172,
      a3 + a4,
      v6 + 1);
  }
  else if ( a3 < a4 )
  {
    do
    {
      v8 = *(_DWORD *)(a1[3] + 4 * v5);
      v9 = (float *)sub_10025C40(a2, *(_DWORD *)(a1[5] + 4 * v5));
      sub_10018630(a5, (float *)(*(_DWORD *)(a1[2] + 8) + 156 * v8 + 76), v9);
      a5 += 64;
      ++v5;
    }
    while ( v5 < a4 );
  }
}

//----- (1001A7A0) --------------------------------------------------------
int __cdecl sub_1001A7A0(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (1001A7B0) --------------------------------------------------------
int __cdecl sub_1001A7B0(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (1001A7C0) --------------------------------------------------------
int __cdecl sub_1001A7C0(int a1)
{
  return *(_DWORD *)(a1 + 20);
}

//----- (1001A7D0) --------------------------------------------------------
int __cdecl sub_1001A7D0(int a1, int a2, unsigned int a3, int a4, int a5)
{
  _DWORD *v5; // edi
  int v6; // ebx
  unsigned int v7; // ebp
  int v8; // esi
  int v9; // eax
  int v10; // esi
  int v11; // eax
  int v13; // [esp+10h] [ebp-Ch]
  int v14; // [esp+14h] [ebp-8h]
  int v15; // [esp+18h] [ebp-4h]
  int v16; // [esp+24h] [ebp+8h]

  v5 = (_DWORD *)a5;
  v14 = sub_100259D0(a5);
  v6 = sub_10025A20(v5);
  v7 = 3 * a2;
  v8 = a1 + 3 * a2;
  v13 = sub_100019C0(v5);
  sub_10019A60(&a5, 3240);
  sub_10019B90(a5, 1060, v8 * v13);
  sub_10019BC0(a5, 1052, 1064, v8, 4);
  sub_10019BC0(a5, 1052, 1068, v8, 4);
  sub_10019BC0(a5, 1092, 1096, a4, 4);
  sub_10019BC0(a5, 3152, 3156, a2, 16);
  sub_10019BC0(a5, 3160, 3168, a3, 4);
  sub_10019BC0(a5, 3172, 3176, 3 * a2, 16);
  v16 = sub_100019C0(asc_10033B70);
  v9 = sub_100019C0(&dword_10033C10);
  v10 = v16 + v6 * v9;
  v15 = v9;
  sub_10019B90(a5, 3220, v10);
  sub_10019B90(a5, 3224, v10);
  sub_10019B90(a5, 3228, v10);
  sub_10019B90(a5, 3236, v13);
  sub_10019B90(a5, 3232, v10);
  v11 = sub_100019F0((int *)asc_10033B70);
  sub_10019B90(a5, 3200, 32 * v6 + v11);
  if ( sub_10019C60((int)aWPublicGrannyR_34, 246) )
  {
    *(_DWORD *)a5 = 981668463;
    *(_DWORD *)(a5 + 4) = 981668463;
    *(_DWORD *)(a5 + 8) = 981668463;
    *(_DWORD *)(a5 + 12) = 981668463;
    sub_10019DE0(256, 0.001, (float *)(a5 + 16));
    *(_DWORD *)(a5 + 1040) = v5;
    *(_DWORD *)(a5 + 1044) = v13;
    *(_DWORD *)(a5 + 1048) = v6;
    *(_DWORD *)(a5 + 1056) = a1;
    *(_DWORD *)(a5 + 1072) = 0;
    *(_DWORD *)(a5 + 1076) = a1;
    *(_DWORD *)(a5 + 1092) = a4;
    *(_DWORD *)(a5 + 3180) = 0;
    *(_DWORD *)(a5 + 3164) = 0;
    sub_10019DC0(a3, -1, *(void **)(a5 + 3168));
    sub_10019DC0(v7, -1, *(void **)(a5 + 1064));
    sub_10019DC0(4 * *(_DWORD *)(a5 + 3172), -1, *(void **)(a5 + 3176));
    *(_DWORD *)(a5 + 1100) = v14;
    *(_DWORD *)(a5 + 3208) = v16;
    *(_DWORD *)(a5 + 3212) = v15;
    *(_DWORD *)(a5 + 3216) = v10;
    sub_1001AB40((_DWORD *)a5);
    sub_1001AB10(a5);
    sub_1001AAD0(a5);
  }
  return a5;
}
// 10033C10: using guessed type _DWORD dword_10033C10;

//----- (1001AAD0) --------------------------------------------------------
int __cdecl sub_1001AAD0(int a1)
{
  int *v1; // esi
  int v2; // ebx
  int v3; // eax
  int result; // eax

  v1 = (int *)(a1 + 3220);
  v2 = 3;
  do
  {
    *(_DWORD *)(a1 + 3184) = 0;
    v3 = *v1;
    *(v1 - 8) = 0;
    result = sub_10001B60(*(_DWORD **)(a1 + 3200), v3);
    ++v1;
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (1001AB10) --------------------------------------------------------
int __cdecl sub_1001AB10(int a1)
{
  *(_DWORD *)(a1 + 1080) = 0;
  *(_DWORD *)(a1 + 1084) = 0;
  *(_DWORD *)(a1 + 1088) = 0;
  return sub_10019DE0(*(_DWORD *)(a1 + 1092), 0.0, *(float **)(a1 + 1096));
}

//----- (1001AB40) --------------------------------------------------------
char *__cdecl sub_1001AB40(_DWORD *a1)
{
  _DWORD *v1; // ebx
  char *result; // eax
  char *v3; // esi
  _DWORD *v4; // ebp

  v1 = (_DWORD *)a1[800];
  for ( result = asc_10033B70; *(_DWORD *)result; v1 += 8 )
  {
    v3 = result;
    result += 32;
    qmemcpy(v1, v3, 0x20u);
  }
  v4 = (_DWORD *)a1[260];
  a1[801] = v1;
  if ( *v4 )
  {
    do
    {
      if ( !sub_10025940((_BYTE *)v4[1]) )
      {
        qmemcpy(v1, v4, 0x20u);
        *v1 = 10;
        v1[3] = 4;
        v1 += 8;
      }
      result = (char *)v4[8];
      v4 += 8;
    }
    while ( result );
  }
  *v1 = 0;
  return result;
}

//----- (1001ABD0) --------------------------------------------------------
BOOL __cdecl sub_1001ABD0(int a1, int *a2, int *a3)
{
  int *v3; // ecx
  int *v4; // ebp
  _DWORD *v5; // esi
  bool v6; // zf
  int v7; // edi
  int v8; // ebx

  v3 = a3;
  v4 = a2;
  v5 = (_DWORD *)a1;
  v6 = a1 == 0;
  *a2 = 0;
  *v3 = 0;
  if ( !v6 )
  {
    a1 = 0;
    a2 = 0;
    v7 = sub_1001AC60((int)v5);
    v8 = sub_1001ACE0(v5);
    sub_10019A60(&a1, v7);
    sub_10019A60(&a2, v8);
    sub_10019C60((int)aWPublicGrannyR_34, 520);
    sub_1001ADD0((int)v5, a1, v4, (int)a2, a3);
  }
  return *v4 && *a3;
}

//----- (1001AC60) --------------------------------------------------------
int __cdecl sub_1001AC60(int a1)
{
  sub_1001AC90(a1, &a1);
  return sub_10019D70();
}

//----- (1001AC90) --------------------------------------------------------
int __cdecl sub_1001AC90(int a1, int *a2)
{
  int v2; // ebx
  int v3; // eax

  v2 = *(_DWORD *)(a1 + 1076);
  sub_10019A60(a2, 20);
  v3 = sub_100019F0(*(int **)(a1 + 1040));
  sub_10019B90(*a2, 0, v3);
  return sub_10019BC0(*a2, 4, 8, v2, *(_DWORD *)(a1 + 1044));
}

//----- (1001ACE0) --------------------------------------------------------
int __cdecl sub_1001ACE0(_DWORD *a1)
{
  sub_1001AD10(a1, (int *)&a1);
  return sub_10019D70();
}

//----- (1001AD10) --------------------------------------------------------
int __cdecl sub_1001AD10(_DWORD *a1, int *a2)
{
  int v2; // ebx
  int v3; // ebp
  int v4; // edi

  v2 = a1[795];
  v3 = a1[791];
  v4 = a1[269];
  sub_10019A60(a2, 72);
  sub_10019BC0(*a2, 0, 4, v3, 12);
  v2 *= 3;
  sub_10019BC0(*a2, 8, 12, v2, 4);
  sub_10019BC0(*a2, 16, 20, 0, 2);
  sub_10019BC0(*a2, 24, 28, v4, 4);
  sub_10019BC0(*a2, 32, 36, v4, 4);
  return sub_10019BC0(*a2, 40, 44, v2, 4);
}

//----- (1001ADA0) --------------------------------------------------------
int __cdecl sub_1001ADA0(int a1)
{
  return *(_DWORD *)(a1 + 1076);
}

//----- (1001ADB0) --------------------------------------------------------
int __cdecl sub_1001ADB0(int a1)
{
  return *(_DWORD *)(a1 + 1064);
}

//----- (1001ADC0) --------------------------------------------------------
int __cdecl sub_1001ADC0(int a1)
{
  return *(_DWORD *)(a1 + 1068);
}

//----- (1001ADD0) --------------------------------------------------------
void __cdecl sub_1001ADD0(int a1, int a2, int *a3, int a4, int *a5)
{
  int v6; // ebp
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  _DWORD *v12; // esi
  int v13; // eax
  int *v14; // [esp-8h] [ebp-18h]
  int v15; // [esp-4h] [ebp-14h]
  int v16; // [esp+14h] [ebp+4h]
  int v17; // [esp+1Ch] [ebp+Ch]
  int v18; // [esp+24h] [ebp+14h]

  v6 = 0;
  *a3 = 0;
  *a5 = 0;
  if ( a1 )
  {
    sub_1001AC90(a1, a3);
    if ( sub_10019D50((int)aWPublicGrannyR_34, 580, a2) )
    {
      sub_1001AD10((_DWORD *)a1, a5);
      if ( sub_10019D50((int)aWPublicGrannyR_34, 583, a4) )
      {
        *(_DWORD *)(*a3 + 12) = 0;
        *(_DWORD *)(*a3 + 16) = 0;
        *(_DWORD *)(*a5 + 64) = 0;
        *(_DWORD *)(*a5 + 68) = 0;
        *(_DWORD *)(*a5 + 48) = 0;
        *(_DWORD *)(*a5 + 52) = 0;
        *(_DWORD *)(*a5 + 56) = 0;
        *(_DWORD *)(*a5 + 60) = 0;
        v15 = *(_DWORD *)*a3;
        v14 = *(int **)(a1 + 1040);
        v8 = sub_100019F0(v14);
        sub_10019E10(v8, v14, v15);
        sub_10019E10(*(_DWORD *)(a1 + 1044) * *(_DWORD *)(*a3 + 4), *(_BYTE **)(a1 + 1060), *(_DWORD *)(*a3 + 8));
        v18 = *(_DWORD *)(*a5 + 12);
        v9 = 0;
        v17 = 0;
        if ( *(int *)(a1 + 3160) > 0 )
        {
          v10 = 0;
          do
          {
            v11 = *(_DWORD *)(*(_DWORD *)(a1 + 3168) + 4 * v9);
            if ( v11 != -1 )
            {
              v12 = (_DWORD *)(v10 + *(_DWORD *)(*a5 + 4));
              *v12 = v9;
              v16 = v10 + 12;
              v12[1] = v6;
              v13 = sub_1001B290(a1, v11, (_DWORD *)(v18 + 12 * v6));
              v10 = v16;
              v12[2] = v13;
              v6 += v13;
              v9 = v17;
            }
            v17 = ++v9;
          }
          while ( v9 < *(_DWORD *)(a1 + 3160) );
        }
        sub_10019E30(*(_DWORD *)(*a5 + 24), *(_DWORD **)(a1 + 1064), *(_DWORD *)(*a5 + 28));
        sub_10019E30(*(_DWORD *)(*a5 + 32), *(_DWORD **)(a1 + 1068), *(_DWORD *)(*a5 + 36));
        sub_1001AF70(a1, v6, *(int **)(*a5 + 12), *(int **)(*a5 + 44));
      }
    }
    off_10033624((int)aWPublicGrannyR_34, 655, a1);
  }
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (1001AF70) --------------------------------------------------------
int __cdecl sub_1001AF70(int a1, int a2, int *a3, int *a4)
{
  int *v4; // ebx
  int i; // ebp
  int *v7; // ebx
  int result; // eax
  int *v9; // edi
  int *v11; // edi
  int *v12; // ebp
  int v13; // [esp-14h] [ebp-2Ch]
  int v14; // [esp-14h] [ebp-2Ch]
  int v15; // [esp-Ch] [ebp-24h]
  int v16; // [esp-Ch] [ebp-24h]
  int v17; // [esp-4h] [ebp-1Ch]
  int v18; // [esp-4h] [ebp-1Ch]
  int v19; // [esp+10h] [ebp-8h]
  int v20; // [esp+14h] [ebp-4h]
  int v21; // [esp+14h] [ebp-4h]
  int v22; // [esp+1Ch] [ebp+4h]
  int v23; // [esp+1Ch] [ebp+4h]
  int j; // [esp+24h] [ebp+Ch]
  int v25; // [esp+28h] [ebp+10h]

  v4 = a3;
  for ( i = 0; i < a2; ++i )
  {
    v17 = *v4;
    v7 = v4 + 1;
    v19 = sub_1001B0E0(a1, v17);
    v15 = *v7++;
    v22 = sub_1001B0E0(a1, v15);
    v13 = *v7;
    v4 = v7 + 1;
    v20 = sub_1001B0E0(a1, v13);
    sub_1001B100(a1, 4 * i, v19, v22);
    sub_1001B100(a1, (4 * i) | 1, v22, v20);
    sub_1001B100(a1, (4 * i) | 2, v20, v19);
  }
  result = a2;
  v9 = a3;
  for ( j = 0; j < a2; ++j )
  {
    v18 = *v9;
    v11 = v9 + 1;
    v25 = sub_1001B0E0(a1, v18);
    v16 = *v11++;
    v23 = sub_1001B0E0(a1, v16);
    v14 = *v11;
    v9 = v11 + 1;
    v21 = sub_1001B0E0(a1, v14);
    *a4 = sub_1001B1D0(a1, 4 * j, v25, v23);
    v12 = a4 + 1;
    *v12++ = sub_1001B1D0(a1, (4 * j) | 1, v23, v21);
    *v12 = sub_1001B1D0(a1, (4 * j) | 2, v21, v25);
    a4 = v12 + 1;
    result = j + 1;
  }
  return result;
}

//----- (1001B0E0) --------------------------------------------------------
int __cdecl sub_1001B0E0(int a1, int a2)
{
  int v2; // ecx
  int result; // eax

  v2 = *(_DWORD *)(a1 + 1056);
  for ( result = a2; result >= v2; result = *(_DWORD *)(*(_DWORD *)(a1 + 1064) + 4 * result) )
    ;
  return result;
}

//----- (1001B100) --------------------------------------------------------
int __cdecl sub_1001B100(int a1, int a2, int a3, int a4)
{
  int v4; // esi
  int v5; // edi
  int result; // eax
  int v7; // ecx
  int v8; // ebx
  int v9; // edx
  int v10; // [esp+14h] [ebp+4h]

  v4 = *(_DWORD *)(a1 + 3176);
  v5 = *(_DWORD *)(a1 + 3172);
  result = sub_1001B1B0(&a3, &a4);
  v7 = -1;
  v8 = 0;
  v10 = result;
  if ( v5 <= 0 )
    return result;
  while ( 1 )
  {
    v9 = (v8 + v10) % v5;
    result = v4 + 16 * v9;
    if ( v7 == -1 && *(_DWORD *)result == a3 && *(_DWORD *)(result + 4) == a4 )
    {
      for ( result = *(_DWORD *)(result + 12); result != -1; result = *(_DWORD *)(16 * result + v4 + 12) )
        v9 = result;
      v7 = v9;
      goto LABEL_9;
    }
    if ( *(_DWORD *)result == -1 )
      break;
LABEL_9:
    if ( ++v8 >= v5 )
      return result;
  }
  *(_DWORD *)(result + 8) = a2;
  *(_DWORD *)result = a3;
  *(_DWORD *)(result + 4) = a4;
  *(_DWORD *)(result + 12) = -1;
  if ( v7 != -1 )
    *(_DWORD *)(16 * v7 + v4 + 12) = v9;
  return result;
}

//----- (1001B1B0) --------------------------------------------------------
int __cdecl sub_1001B1B0(int *a1, int *a2)
{
  int v2; // ecx

  v2 = *a2;
  if ( *a1 > *a2 )
  {
    *a2 = *a1;
    *a1 = v2;
  }
  return *a1 | (*a2 << 16);
}

//----- (1001B1D0) --------------------------------------------------------
int __cdecl sub_1001B1D0(int a1, int a2, int a3, int a4)
{
  int v4; // esi
  int v5; // edi
  int v6; // ebx
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  int result; // eax
  int v11; // ecx
  int v12; // edx
  int v13; // ecx
  int v14; // [esp+14h] [ebp+4h]

  v4 = *(_DWORD *)(a1 + 3176);
  v5 = *(_DWORD *)(a1 + 3172);
  v6 = 0;
  v14 = sub_1001B1B0(&a3, &a4);
  if ( v5 <= 0 )
    return -1;
  while ( 1 )
  {
    v7 = 16 * ((v6 + v14) % v5);
    v8 = *(_DWORD *)(v7 + v4);
    v9 = v4 + v7;
    if ( v8 == a3 && *(_DWORD *)(v9 + 4) == a4 )
      break;
    if ( v8 != -1 && ++v6 < v5 )
      continue;
    return -1;
  }
  v11 = (v6 + v14) % v5;
  result = *(_DWORD *)(16 * v11 + v4 + 8);
  v12 = v4 + 16 * v11;
  if ( result != a2 )
  {
    do
    {
      v11 = *(_DWORD *)(v12 + 12);
      v12 = v4 + 16 * v11;
    }
    while ( *(_DWORD *)(v12 + 8) != a2 );
  }
  v13 = *(_DWORD *)(16 * v11 + v4 + 12);
  if ( v13 != -1 )
    return *(_DWORD *)(16 * v13 + v4 + 8);
  return result;
}

//----- (1001B290) --------------------------------------------------------
int __cdecl sub_1001B290(int a1, int a2, _DWORD *a3)
{
  int v3; // ecx
  int result; // eax
  _DWORD *v6; // ecx
  _DWORD *v7; // edx

  v3 = a2;
  for ( result = 0; v3 != -1; ++result )
  {
    v6 = (_DWORD *)(*(_DWORD *)(a1 + 3156) + 16 * v3);
    *a3 = *v6;
    v7 = a3 + 1;
    *v7++ = v6[1];
    *v7 = v6[2];
    v3 = v6[3];
    a3 = v7 + 1;
  }
  return result;
}

//----- (1001B2E0) --------------------------------------------------------
float *__cdecl sub_1001B2E0(float *a1, float a2)
{
  float *result; // eax

  result = a1;
  *a1 = a2;
  return result;
}

//----- (1001B2F0) --------------------------------------------------------
int __cdecl sub_1001B2F0(int a1, float a2)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 4) = a2;
  return result;
}

//----- (1001B300) --------------------------------------------------------
int __cdecl sub_1001B300(int a1, float a2)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 12) = a2;
  return result;
}

//----- (1001B310) --------------------------------------------------------
int __cdecl sub_1001B310(int a1, int a2, float a3)
{
  int result; // eax

  result = a2;
  *(float *)(a1 + 4 * a2 + 16) = a3;
  return result;
}

//----- (1001B330) --------------------------------------------------------
_DWORD *__cdecl sub_1001B330(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *result; // eax

  result = a1;
  a1[270] = a2;
  a1[271] = a3;
  a1[272] = a4;
  return result;
}

//----- (1001B360) --------------------------------------------------------
float *__cdecl sub_1001B360(int a1, int a2, float a3)
{
  float *result; // eax

  result = (float *)(*(_DWORD *)(a1 + 1096) + 4 * a2);
  *result = a3 + *result;
  return result;
}

//----- (1001B380) --------------------------------------------------------
int __usercall sub_1001B380@<eax>(int a1@<ebx>, double a2@<st0>, int *a3)
{
  int v4; // eax
  int v5; // edi
  char *v6; // edi
  _DWORD *v7; // eax
  int v8; // edx

  v4 = a3[268];
  v5 = v4 * a3[261];
  a3[268] = v4 + 1;
  v6 = (char *)(a3[265] + v5);
  sub_1001B410(a3);
  sub_10010650(a1, a2, (int)&unk_10035668, (int)(a3 + 270), a3[260], v6);
  sub_10010D60(a1, a2, (int)&unk_10035C28, (int)(a3 + 276), a3[260], v6);
  v7 = (_DWORD *)sub_10010600(a3[260], 0, aBoneweights);
  if ( v7 )
    sub_10025300(v7, (int)&v6[v8]);
  return sub_1001AB10((int)a3);
}
// 1001B3FA: variable 'v8' is possibly undefined

//----- (1001B410) --------------------------------------------------------
void __cdecl sub_1001B410(int *a1)
{
  int *v1; // edi
  int v2; // ebx
  char *v3; // esi
  int v4; // ebp
  int v5; // edx
  int v6; // ecx
  int *v7; // eax
  char *v8; // edi
  double v9; // st7
  int v10; // eax
  double v11; // st7
  int i; // eax
  int v13; // [esp+10h] [ebp-8h]

  v1 = a1;
  v2 = a1[275];
  v3 = (char *)(a1 + 276);
  sub_10019DC0(v2, 0, a1 + 532);
  sub_10019DE0(v2, 0.0, (float *)a1 + 276);
  v4 = 0;
  v13 = 0;
  if ( a1[273] > 0 )
  {
    do
    {
      v5 = 0;
      if ( v2 > 0 )
      {
        while ( *(float *)&v3[4 * v5] >= (double)*(float *)(v1[274] + 4 * v4) )
        {
          if ( ++v5 >= v2 )
            goto LABEL_11;
        }
        v6 = v2 - 1;
        if ( v2 - 1 > v5 )
        {
          v7 = &v1[v6 + 531];
          v8 = (char *)(v3 - (char *)(v1 + 532));
          do
          {
            *(_DWORD *)&v3[4 * v6] = *(int *)((char *)v7 + (_DWORD)v8);
            v7[1] = *v7;
            --v6;
            --v7;
          }
          while ( v6 > v5 );
          v4 = v13;
          v1 = a1;
        }
        *(_DWORD *)&v3[4 * v5] = *(_DWORD *)(v1[274] + 4 * v4);
        v1[v5 + 532] = v4;
      }
LABEL_11:
      v13 = ++v4;
    }
    while ( v4 < v1[273] );
  }
  v9 = 0.0;
  v10 = 0;
  if ( v2 <= 0 )
    goto LABEL_18;
  do
    v9 = v9 + *(float *)&v3[4 * v10++];
  while ( v10 < v2 );
  if ( v9 <= 0.0 )
  {
LABEL_18:
    if ( v2 )
      *(_DWORD *)v3 = 1065353216;
  }
  else
  {
    v11 = 1.0 / v9;
    for ( i = 0; i < v2; *(float *)&v3[4 * i - 4] = v11 * *(float *)&v3[4 * i - 4] )
      ++i;
  }
}
// 1002A170: using guessed type float flt_1002A170;

//----- (1001B530) --------------------------------------------------------
int __cdecl sub_1001B530(int a1, int a2, int a3)
{
  int result; // eax

  result = a3;
  *(_DWORD *)(a1 + 4 * a2 + 3188) = a3;
  return result;
}

//----- (1001B550) --------------------------------------------------------
_DWORD *__cdecl sub_1001B550(int a1, int a2, int a3, int a4, int a5)
{
  _DWORD *result; // eax

  result = *(_DWORD **)(a1 + 4 * a2 + 3220);
  *result = a3;
  result[1] = a4;
  result[2] = a5;
  return result;
}

//----- (1001B580) --------------------------------------------------------
_DWORD *__cdecl sub_1001B580(int a1, int a2, int a3, int a4, int a5)
{
  _DWORD *result; // eax

  result = (_DWORD *)(*(_DWORD *)(a1 + 4 * a2 + 3220) + 12);
  *result = a3;
  result[1] = a4;
  result[2] = a5;
  return result;
}

//----- (1001B5B0) --------------------------------------------------------
_DWORD *__cdecl sub_1001B5B0(int a1, int a2, int a3, int a4, int a5)
{
  _DWORD *result; // eax

  result = (_DWORD *)(*(_DWORD *)(a1 + 4 * a2 + 3220) + 24);
  *result = a3;
  result[1] = a4;
  result[2] = a5;
  return result;
}

//----- (1001B5E0) --------------------------------------------------------
_DWORD *__cdecl sub_1001B5E0(int a1, int a2, int a3, int a4, int a5)
{
  _DWORD *result; // eax

  result = (_DWORD *)(*(_DWORD *)(a1 + 4 * a2 + 3220) + 36);
  *result = a3;
  result[1] = a4;
  result[2] = a5;
  return result;
}

//----- (1001B610) --------------------------------------------------------
_DWORD *__cdecl sub_1001B610(int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // edx
  int v5; // ecx
  _DWORD *result; // eax
  int v7; // esi
  int v8; // ecx
  int v9; // edx

  v4 = a3;
  v5 = *(_DWORD *)(a1 + 3204);
  for ( result = (_DWORD *)(*(_DWORD *)(a1 + 4 * a2 + 3220) + 48); v4; result += v7 )
  {
    v7 = *(_DWORD *)(v5 + 12);
    v5 += 32;
    --v4;
  }
  v8 = *(_DWORD *)(v5 + 12);
  if ( v8 )
  {
    v9 = v8;
    do
    {
      *result++ = *a4++;
      --v9;
    }
    while ( v9 );
  }
  return result;
}

//----- (1001B660) --------------------------------------------------------
int __cdecl sub_1001B660(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 3184) = a2;
  return result;
}

//----- (1001B670) --------------------------------------------------------
int __usercall sub_1001B670@<eax>(double a1@<st0>, _DWORD *a2)
{
  int v2; // ebp
  int v3; // ebx
  int i; // esi
  int v5; // eax

  v2 = a2[795];
  a2[795] = v2 + 1;
  v3 = a2[789] + 16 * v2;
  for ( i = 0; i < 3; ++i )
    *(_DWORD *)(v3 + 4 * i) = sub_1001B6F0(a1, (int)a2, v2, i);
  v5 = *(_DWORD *)(a2[792] + 4 * a2[796]);
  *(_DWORD *)(v3 + 12) = v5;
  if ( v5 == -1 )
    ++a2[791];
  *(_DWORD *)(a2[792] + 4 * a2[796]) = v2;
  return sub_1001AAD0((int)a2);
}

//----- (1001B6F0) --------------------------------------------------------
int __usercall sub_1001B6F0@<eax>(double a1@<st0>, int a2, int a3, int a4)
{
  int v4; // ebx
  int v6; // ebp
  int v7; // edi
  int v8; // eax
  int v9; // ecx
  char *v10; // ebx
  int v12; // [esp+14h] [ebp+4h]

  v4 = a4;
  sub_10010650(
    a4,
    a1,
    *(_DWORD *)(a2 + 3200),
    *(_DWORD *)(a2 + 4 * a4 + 3220),
    *(_DWORD *)(a2 + 1040),
    *(char **)(a2 + 3236));
  sub_10010650(
    v4,
    a1,
    *(_DWORD *)(a2 + 1040),
    *(_DWORD *)(a2 + 3236),
    *(_DWORD *)(a2 + 3200),
    *(char **)(a2 + 4 * v4 + 3220));
  v7 = *(_DWORD *)(a2 + 4 * a4 + 3188);
  v12 = v7;
  v6 = v7;
  if ( *(_DWORD *)(*(_DWORD *)(a2 + 1064) + 4 * v7) == -1 )
  {
LABEL_6:
    v8 = *(_DWORD *)(a2 + 1044);
    v9 = *(_DWORD *)(a2 + 1060);
    v10 = (char *)(v9 + v7 * v8);
    sub_10019E10(v8, (_BYTE *)(v9 + v6 * v8), (int)v10);
    sub_10010D60((int)v10, a1, *(_DWORD *)(a2 + 3200), *(_DWORD *)(a2 + 4 * a4 + 3220), *(_DWORD *)(a2 + 1040), v10);
    *(_DWORD *)(*(_DWORD *)(a2 + 1064) + 4 * v12) = v7;
    *(_DWORD *)(*(_DWORD *)(a2 + 1064) + 4 * v7) = v6;
    *(_DWORD *)(*(_DWORD *)(a2 + 1068) + 4 * v7) = a3;
  }
  else
  {
    while ( !sub_1001B810(v4, a1, a2, v4, v7) )
    {
      v12 = v7;
      v7 = *(_DWORD *)(*(_DWORD *)(a2 + 1064) + 4 * v7);
      if ( v7 == v6 )
      {
        v7 = *(_DWORD *)(a2 + 1076);
        *(_DWORD *)(a2 + 1076) = v7 + 1;
        goto LABEL_6;
      }
      v4 = a4;
    }
  }
  return v7;
}

//----- (1001B810) --------------------------------------------------------
BOOL __usercall sub_1001B810@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5)
{
  int v6; // edi
  int v7; // ebp
  bool v8; // al
  float *v9; // ebx
  _DWORD *v10; // edi
  int v11; // ebp
  float *v12; // esi
  bool v13; // al
  int v14; // ecx
  bool v16; // [esp+13h] [ebp-5h]
  float *v17; // [esp+14h] [ebp-4h]
  bool v18; // [esp+1Ch] [ebp+4h]
  bool v19; // [esp+20h] [ebp+8h]
  bool v20; // [esp+24h] [ebp+Ch]

  v6 = *(_DWORD *)(a3 + 3232);
  sub_10010650(
    a1,
    a2,
    *(_DWORD *)(a3 + 1040),
    *(_DWORD *)(a3 + 1060) + a5 * *(_DWORD *)(a3 + 1044),
    *(_DWORD *)(a3 + 3200),
    (char *)v6);
  v7 = *(_DWORD *)(a3 + 4 * a4 + 3220);
  v18 = sub_1001B930(*(float *)a3, 3, (float *)v6, *(_DWORD *)(a3 + 4 * a4 + 3220));
  v20 = sub_1001B930(*(float *)(a3 + 4), 3, (float *)(v6 + 12), v7 + 12);
  v19 = sub_1001B930(*(float *)(a3 + 8), 3, (float *)(v6 + 24), v7 + 24);
  v8 = sub_1001B930(*(float *)(a3 + 12), 3, (float *)(v6 + 36), v7 + 36);
  v9 = (float *)(v6 + 48);
  v10 = *(_DWORD **)(a3 + 3204);
  v11 = v7 + 48;
  v12 = (float *)(a3 + 16);
  v16 = v8;
  v13 = 1;
  v17 = v12;
  do
  {
    if ( !*v10 )
      break;
    v13 = sub_1001B930(*v12, v10[3], v9, v11);
    v14 = 4 * v10[3];
    v12 = v17 + 1;
    v9 = (float *)((char *)v9 + v14);
    v11 += v14;
    v10 += 8;
    ++v17;
  }
  while ( v13 );
  return v18 && v20 && v19 && v16 && v13;
}

//----- (1001B930) --------------------------------------------------------
BOOL __cdecl sub_1001B930(float a1, int a2, float *a3, int a4)
{
  int v4; // edx
  double i; // st7
  double v8; // st6

  v4 = a2;
  for ( i = 0.0; v4; i = i + v8 * v8 )
  {
    a4 += 4;
    v8 = *a3++ - *(float *)(a4 - 4);
    --v4;
  }
  return i <= a1 * a1;
}

//----- (1001B980) --------------------------------------------------------
void *__cdecl sub_1001B980(_DWORD *a1, _DWORD *a2, int a3)
{
  void *result; // eax
  _DWORD v4[6]; // [esp+4h] [ebp-18h] BYREF

  if ( !sub_10012250(a1, a2, a3, v4) )
    return 0;
  result = (void *)off_10033620((int)aWPublicGrannyR_37, 43, 4, 24);
  if ( result )
    qmemcpy(result, v4, 0x18u);
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (1001B9E0) --------------------------------------------------------
int __cdecl sub_1001B9E0(int a1)
{
  return off_10033624((int)aWPublicGrannyR_37, 56, a1);
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (1001BA00) --------------------------------------------------------
int __cdecl sub_1001BA00(int a1, int a2, int a3, int a4, int a5, int a6)
{
  void *v6; // esi
  unsigned __int64 v7; // kr00_8
  _QWORD *v8; // eax
  bool v9; // cf
  int result; // eax
  unsigned __int64 v11; // [esp+8h] [ebp-8h]

  if ( (byte_10047444 & 1) == 0 )
  {
    byte_10047444 |= 1u;
    dword_10047448 = (int)sub_100218A0((int)aDeformmesh);
  }
  v6 = off_1003440C;
  off_1003440C = (_UNKNOWN *)dword_10047448;
  v11 = __rdtsc();
  if ( a2 )
    (*(void (__cdecl **)(int, int, int, int, int, _DWORD))(a1 + 8))(a4, a5, a6, a2, a3, *(_DWORD *)(a1 + 20));
  else
    (*(void (__cdecl **)(int, int, int, int, _DWORD))(a1 + 4))(a4, a5, a6, a3, *(_DWORD *)(a1 + 20));
  v7 = __rdtsc() - v11;
  v8 = off_1003440C;
  ++*((_DWORD *)off_1003440C + 1);
  v8[1] += v7;
  off_1003440C = v6;
  v9 = __CFADD__((_DWORD)v7, *((_DWORD *)v6 + 4));
  *((_DWORD *)v6 + 4) += v7;
  result = HIDWORD(v7) + v9 + *((_DWORD *)v6 + 5);
  *((_DWORD *)v6 + 5) = result;
  return result;
}
// 1003440C: using guessed type _UNKNOWN *off_1003440C;
// 10047444: using guessed type char byte_10047444;
// 10047448: using guessed type int dword_10047448;

//----- (1001BAE0) --------------------------------------------------------
unsigned int __cdecl sub_1001BAE0(int a1, int a2, unsigned int a3)
{
  int v3; // edi
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // esi
  unsigned int v8; // esi
  unsigned int v9; // esi
  unsigned int v10; // esi

  v3 = a3;
  if ( a3 >> 4 > 0xE )
    v4 = (a3 >> 4) - 7;
  else
    v4 = 7;
  v5 = 4 * v4 + 360;
  if ( a3 >> 3 > 0x24 )
    v6 = (a3 >> 3) - 29;
  else
    v6 = 7;
  if ( a3 >> 2 > 0x30 )
    v7 = (a3 >> 2) - 41;
  else
    v7 = 7;
  v8 = v5 + 4 * v6 + sub_1000E070(a1, a2) + 4 * (v7 + 8 * a3);
  v9 = 65 * sub_1000E070(64, 65) + v8;
  if ( a3 >= 4 )
    v3 = 4;
  v10 = sub_1000E070(v3 - 1, v3) + v9;
  return v10 + sub_1000E070(a3 >> 2, (a3 >> 2) + 1);
}

//----- (1001BB90) --------------------------------------------------------
unsigned int __cdecl sub_1001BB90(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // ecx

  v3 = 65;
  if ( (unsigned int)(a1 + 1) > 0x41 )
    v3 = a1 + 1;
  if ( (a3 >> 2) + 1 > v3 )
    v3 = (a3 >> 2) + 1;
  return sub_1000E0B0(v3);
}

//----- (1001BBC0) --------------------------------------------------------
int __cdecl sub_1001BBC0(int a1, int a2, int a3, int a4, unsigned int a5)
{
  int v6; // eax
  unsigned int v7; // edx
  int v8; // ebp
  int v9; // eax
  int v10; // eax
  int v11; // edi
  int *v12; // ebx
  int v13; // eax
  int v14; // ecx
  unsigned int v15; // eax
  unsigned int v17; // [esp-30h] [ebp-40h]
  char *v18; // [esp-28h] [ebp-38h]
  unsigned int v19; // [esp-24h] [ebp-34h]
  char *v20; // [esp-1Ch] [ebp-2Ch]
  unsigned int v21; // [esp-18h] [ebp-28h]
  char *v22; // [esp-10h] [ebp-20h]
  int v23; // [esp-4h] [ebp-14h]
  unsigned int v24; // [esp+14h] [ebp+4h]
  int v25; // [esp+1Ch] [ebp+Ch]

  *(_DWORD *)(a1 + 272) = a3 + 1;
  *(_DWORD *)(a1 + 280) = a5;
  v6 = 4;
  if ( a5 < 4 )
    v6 = a5;
  *(_DWORD *)(a1 + 284) = v6;
  v7 = a5 >> 2;
  *(_DWORD *)(a1 + 288) = (a5 >> 2) + 1;
  *(_DWORD *)(a1 + 308) = 0;
  *(_DWORD *)(a1 + 312) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 276) = a4;
  *(_DWORD *)(a1 + 344) = -1;
  *(_DWORD *)(a1 + 332) = a5 >> 4;
  v8 = 7;
  if ( a5 >> 4 > 0xE )
    v8 = (a5 >> 4) - 7;
  *(_DWORD *)(a1 + 332) = v8;
  *(_DWORD *)(a1 + 336) = a5 >> 3;
  v9 = 7;
  if ( a5 >> 3 > 0x24 )
    v9 = (a5 >> 3) - 29;
  *(_DWORD *)(a1 + 336) = v9;
  *(_DWORD *)(a1 + 340) = v7;
  v10 = 7;
  if ( v7 > 0x30 )
    v10 = v7 - 41;
  *(_DWORD *)(a1 + 340) = v10;
  *(_DWORD *)(a1 + 292) = a1 + 360;
  sub_10019D80(a3, 4 * v8, 0, (char *)(a1 + 360));
  v22 = (char *)(*(_DWORD *)(a1 + 292) + 4 * *(_DWORD *)(a1 + 332));
  v21 = 4 * *(_DWORD *)(a1 + 336);
  *(_DWORD *)(a1 + 296) = v22;
  sub_10019D80(a3, v21, 0, v22);
  v20 = (char *)(*(_DWORD *)(a1 + 296) + 4 * *(_DWORD *)(a1 + 336));
  v19 = 4 * *(_DWORD *)(a1 + 340);
  *(_DWORD *)(a1 + 300) = v20;
  sub_10019D80(a3, v19, 0, v20);
  v18 = (char *)(*(_DWORD *)(a1 + 300) + 4 * *(_DWORD *)(a1 + 340));
  v17 = 32 * *(_DWORD *)(a1 + 280);
  *(_DWORD *)(a1 + 304) = v18;
  sub_10019D80(a3, v17, 0, v18);
  *(_DWORD *)a1 = sub_1000E0C0(*(_DWORD *)(a1 + 304) + 32 * *(_DWORD *)(a1 + 280), a2, a3, a4);
  v11 = *(_DWORD *)a1 + sub_1000E070(a3, a4);
  v24 = sub_1000E070(64, 65);
  v12 = (int *)(a1 + 4);
  v25 = 65;
  do
  {
    *v12 = sub_1000E0C0(v11, a2, 64, 65);
    v11 += v24;
    ++v12;
    --v25;
  }
  while ( v25 );
  v13 = sub_1000E0C0(v11, a2, *(_DWORD *)(a1 + 284) - 1, *(_DWORD *)(a1 + 284));
  v14 = *(_DWORD *)(a1 + 284);
  *(_DWORD *)(a1 + 264) = v13;
  v23 = *(_DWORD *)(a1 + 288);
  v15 = sub_1000E070(v14 - 1, v14);
  *(_DWORD *)(a1 + 268) = sub_1000E0C0(v11 + v15, a2, v23 - 1, v23);
  return a1;
}

//----- (1001BDE0) --------------------------------------------------------
_DWORD *__cdecl sub_1001BDE0(int *a1, _DWORD *a2)
{
  unsigned int v2; // esi
  unsigned int v3; // ebx
  int *v4; // edi
  unsigned int v5; // esi
  int v6; // ebp
  unsigned int v7; // eax
  unsigned int v8; // eax
  _DWORD *result; // eax
  int v10; // [esp+10h] [ebp-4h]

  *a2 = a1[68] + (a1[70] << 9);
  v2 = sub_1000E250(a1[67]) + 1;
  v3 = sub_1000E250(*a1) + 1;
  if ( v2 > a1[70] )
    v2 = a1[70];
  if ( v3 > a1[69] )
    v3 = a1[69];
  a2[1] = v3 + (v2 << 9);
  v4 = a1 + 1;
  v10 = 4;
  do
  {
    v5 = 0;
    v6 = 16;
    do
    {
      v7 = sub_1000E250(*v4) + 1;
      if ( v7 > v5 )
        v5 = v7;
      ++v4;
      --v6;
    }
    while ( v6 );
    if ( v5 > 0x41 )
      v5 = 65;
    v3 = v5 + (v3 << 8);
    --v10;
  }
  while ( v10 );
  v8 = sub_1000E250(a1[65]) + 1;
  if ( v8 > v5 )
    v5 = v8;
  if ( v5 > 0x41 )
    v5 = 65;
  result = a2;
  a2[2] = v5 + (v3 & 0xFFFFFF00);
  return result;
}

//----- (1001BED0) --------------------------------------------------------
int __cdecl sub_1001BED0(int a1, int a2, unsigned int *a3, unsigned int a4)
{
  unsigned int *v4; // ebx
  double v6; // st7
  unsigned __int8 *v7; // eax
  int v8; // ecx
  unsigned int v9; // edi
  double v10; // st7
  int v11; // ecx
  double v12; // st7
  unsigned int v13; // edi
  double v14; // st7
  double v15; // st7
  unsigned int v16; // eax
  double v17; // st7
  int v18; // edx
  int v19; // edi
  int v20; // ecx
  unsigned int v21; // edi
  double v22; // st7
  int v23; // eax
  double v24; // st7
  double v25; // st7
  int v26; // ecx
  int v27; // ecx
  unsigned int v28; // edi
  unsigned int v29; // ecx
  unsigned int v30; // eax
  unsigned int v31; // eax
  unsigned int v32; // eax
  unsigned int v33; // edi
  int v34; // ecx
  int v35; // ecx
  unsigned int v36; // [esp-Ch] [ebp-5Ch]
  unsigned int v37; // [esp-Ch] [ebp-5Ch]
  unsigned int v38; // [esp+1Ch] [ebp-34h]
  int v39; // [esp+20h] [ebp-30h] BYREF
  unsigned int i; // [esp+24h] [ebp-2Ch]
  unsigned int v41; // [esp+28h] [ebp-28h] BYREF
  unsigned int v42; // [esp+2Ch] [ebp-24h]
  double v43; // [esp+30h] [ebp-20h]
  double v44; // [esp+38h] [ebp-18h]
  double v45; // [esp+40h] [ebp-10h]
  double v46; // [esp+48h] [ebp-8h]

  v4 = a3;
  if ( !a4 )
    return 0;
  v46 = sub_1000EE80(*(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 320) + 4), 0, 0x41u);
  v6 = sub_1000EE80(*(_DWORD *)a1, *(unsigned __int8 *)a3, *(_DWORD *)(a1 + 272));
  v7 = *(unsigned __int8 **)(a1 + 344);
  v45 = v6 + v46;
  if ( a3 == (unsigned int *)v7 )
  {
    v8 = *(_DWORD *)(a1 + 352);
    v38 = *(_DWORD *)(a1 + 348);
    v41 = *(_DWORD *)(a1 + 356);
    v39 = v8;
  }
  else
  {
    if ( !*(_DWORD *)(a1 + 312) )
      *(_DWORD *)(a1 + 324) = sub_1001C380((int)a3, a4);
    v38 = sub_1001C3B0((_DWORD *)a1, a3, a4, v45, &v41, &v39);
  }
  sub_1001C6F0((_DWORD *)a1, a3, a4);
  if ( v38 >= 2 )
  {
    v9 = (unsigned int)a3 - v41 - 1;
    v42 = v9;
    if ( v38 > 5 )
    {
LABEL_19:
      if ( (unsigned int)sub_1000E270((int)a3, *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 320) + 4), a2, v39 + 1) > 0x10000 )
        sub_1000DD90(a2, v39 + 1, 0x41u);
      v27 = *(_DWORD *)(a1 + 264);
      v42 = v9 & 3;
      if ( (unsigned int)sub_1000E270((int)a3, v27, a2, v42) > 0x10000 )
        sub_1000DD90(a2, v42, *(_DWORD *)(a1 + 284));
      v28 = v9 >> 2;
      if ( (unsigned int)sub_1000E270((int)a3, *(_DWORD *)(a1 + 268), a2, v28) > 0x10000 )
        sub_1000DD90(a2, v28, *(_DWORD *)(a1 + 316));
      *(_DWORD *)(a1 + 320) = v39 + 1;
      v29 = v38 + *(_DWORD *)(a1 + 312);
      *(_DWORD *)(a1 + 312) = v29;
      v30 = *(_DWORD *)(a1 + 280);
      if ( v30 > v29 )
        v30 = v29;
      *(_DWORD *)(a1 + 316) = (v30 >> 2) + 1;
      i = v38 - 1;
      do
      {
        v4 = (unsigned int *)((char *)v4 + 1);
        v31 = --a4;
        if ( a4 > 2 )
          sub_1001C6F0((_DWORD *)a1, v4, v31);
        --i;
      }
      while ( i );
      return v38;
    }
    v43 = sub_1000EE80(*(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 320) + 4), v39 + 1, 0x41u);
    v10 = sub_1000EE80(*(_DWORD *)(a1 + 264), v9 & 3, *(_DWORD *)(a1 + 284));
    v11 = *(_DWORD *)(a1 + 268);
    v36 = *(_DWORD *)(a1 + 316);
    v43 = v10 + v43;
    v12 = sub_1000EE80(v11, v9 >> 2, v36);
    v43 = v12 + v43;
    v13 = 1;
    v44 = v45;
    do
    {
      if ( v44 > v43 )
        break;
      sub_1000EE30(*(_DWORD *)a1, *((unsigned __int8 *)a3 + v13 - 1), 1);
      v14 = sub_1000EE80(*(_DWORD *)a1, *((unsigned __int8 *)a3 + v13++), *(_DWORD *)(a1 + 272));
      v44 = v14 + v44 + v46;
    }
    while ( v13 < v38 );
    for ( i = 1; i < v13; ++i )
      sub_1000EE30(*(_DWORD *)a1, *((unsigned __int8 *)a3 + i - 1), -1);
    if ( v44 >= v43 )
    {
      *(_DWORD *)(a1 + 344) = (char *)a3 + 1;
      v15 = sub_1000EE80(*(_DWORD *)a1, *((unsigned __int8 *)a3 + 1), *(_DWORD *)(a1 + 272));
      v16 = sub_1001C3B0(
              (_DWORD *)a1,
              *(unsigned int **)(a1 + 344),
              a4 - 1,
              v15 + v46,
              (unsigned int *)(a1 + 356),
              (int *)(a1 + 352));
      *(_DWORD *)(a1 + 348) = v16;
      if ( v16 < 2 )
        goto LABEL_18;
      v17 = sub_1000EE80(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 352) + 1, 0x41u);
      v18 = *(_DWORD *)(a1 + 356);
      v19 = *(_DWORD *)(a1 + 344);
      v20 = *(_DWORD *)(a1 + 264);
      v46 = v17 + v45;
      v21 = v19 - v18 - 1;
      v22 = sub_1000EE80(v20, v21 & 3, *(_DWORD *)(a1 + 284));
      v23 = *(_DWORD *)(a1 + 268);
      v37 = *(_DWORD *)(a1 + 316);
      v46 = v22 + v46;
      v24 = sub_1000EE80(v23, v21 >> 2, v37);
      v25 = v24 + v46;
      v26 = *(_DWORD *)(a1 + 348) + 1;
      *(_QWORD *)&v46 = (unsigned int)v26;
      LODWORD(v46) = v38;
      if ( (double)*(__int64 *)&v46 / v43 >= (double)(unsigned int)v26 / v25 )
      {
LABEL_18:
        v9 = v42;
        goto LABEL_19;
      }
    }
  }
  v32 = *(_DWORD *)(a1 + 280);
  v33 = *(_DWORD *)(a1 + 312) + 1;
  *(_DWORD *)(a1 + 312) = v33;
  if ( v32 > v33 )
    v32 = v33;
  v34 = *(_DWORD *)(a1 + 320);
  *(_DWORD *)(a1 + 316) = (v32 >> 2) + 1;
  if ( (unsigned int)sub_1000E270((int)a3, *(_DWORD *)(a1 + 4 * v34 + 4), a2, 0) > 0x10000 )
    sub_1000DD90(a2, 0, 0x41u);
  v35 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 320) = 0;
  if ( (unsigned int)sub_1000E270((int)a3, v35, a2, *(unsigned __int8 *)a3) > 0x10000 )
    sub_1000DD90(a2, *(unsigned __int8 *)a3, *(_DWORD *)(a1 + 272));
  return 1;
}
// 1001C041: conditional instruction was optimized away because %var_34.4 is in (2..5)
// 1001C2B4: conditional instruction was optimized away because edi.4>=2u

//----- (1001C380) --------------------------------------------------------
unsigned int __cdecl sub_1001C380(int a1, unsigned int a2)
{
  unsigned int result; // eax

  if ( a2 <= 1 )
    return 0;
  result = 0;
  do
  {
    if ( *(_BYTE *)(result + a1) != *(_BYTE *)(result + a1 + 1) )
      break;
    ++result;
  }
  while ( result < a2 - 1 );
  return result;
}
// 1001C394: conditional instruction was optimized away because %arg_4.4>=2u

//----- (1001C3B0) --------------------------------------------------------
unsigned int __cdecl sub_1001C3B0(_DWORD *a1, unsigned int *a2, unsigned int a3, double a4, unsigned int *a5, int *a6)
{
  unsigned int *v6; // ebp
  unsigned int result; // eax
  unsigned int *v8; // eax
  unsigned int v9; // ecx
  unsigned int *v10; // eax
  unsigned int v11; // ecx
  unsigned int *v12; // eax
  unsigned int v13; // ecx
  unsigned int v14; // [esp+10h] [ebp-4h] BYREF

  v6 = a5;
  result = 0;
  v14 = 0;
  *a5 = 0;
  if ( a3 < 3 )
    goto LABEL_13;
  v8 = *(unsigned int **)(a1[75] + 4 * sub_1001C6D0(*a2, a1[85]));
  if ( v8 )
  {
    v9 = dword_10033D04;
    if ( a3 <= dword_10033D04 )
      v9 = a3;
    sub_1001C4E0(a1, v8, 2, a2, a3, v9, &v14, v6, a6, &a4);
  }
  result = v14;
  if ( v14 <= 3 )
  {
    v10 = *(unsigned int **)(a1[74] + 4 * sub_1001C6D0(*a2 & 0xFFFFFF, a1[84]));
    if ( v10 )
    {
      v11 = a3;
      if ( a3 > 3 )
        v11 = 3;
      sub_1001C4E0(a1, v10, 1, a2, a3, v11, &v14, v6, a6, &a4);
    }
    result = v14;
  }
  if ( result <= 2 )
  {
LABEL_13:
    if ( a3 >= 2 )
    {
      v12 = *(unsigned int **)(a1[73] + 4 * sub_1001C6D0(*(unsigned __int16 *)a2, a1[83]));
      if ( v12 )
      {
        v13 = a3;
        if ( a3 > 2 )
          v13 = 2;
        sub_1001C4E0(a1, v12, 0, a2, a3, v13, &v14, v6, a6, &a4);
      }
      return v14;
    }
  }
  return result;
}
// 10033D04: using guessed type int dword_10033D04;

//----- (1001C4E0) --------------------------------------------------------
unsigned int *__cdecl sub_1001C4E0(
        _DWORD *a1,
        unsigned int *a2,
        int a3,
        _BYTE *a4,
        unsigned int a5,
        unsigned int a6,
        unsigned int *a7,
        unsigned int *a8,
        int *a9,
        double *a10)
{
  unsigned int *result; // eax
  unsigned int v11; // ebp
  unsigned int v12; // eax
  unsigned int v13; // ebx
  _BYTE *v14; // eax
  _BYTE *v15; // ecx
  unsigned int v16; // esi
  int v17; // ebx
  unsigned int v18; // edi
  double v19; // st7
  double v20; // [esp+10h] [ebp-10h]
  double v21; // [esp+10h] [ebp-10h]

  do
  {
    result = a2;
    if ( a6 == *a7 && *a2 + a2[1] <= *a8 )
      break;
    v11 = *a2;
    if ( *(_BYTE *)*a2 == *a4 )
    {
      v12 = a2[1];
      v13 = a1[81];
      if ( v12 < v13 )
      {
        v16 = v12 + 1;
      }
      else
      {
        v14 = (_BYTE *)(v12 + v11 + 1);
        v15 = &a4[v13 + 1];
        v16 = v13 + 1;
        if ( v14 < v15 )
        {
          v11 = (unsigned int)&v14[-v13 - 1];
          if ( *v14 == *v15 )
          {
            v16 = v13 + 1;
            do
            {
              ++v14;
              ++v15;
              ++v16;
            }
            while ( v16 < a6 && *v14 == *v15 );
          }
        }
        else
        {
          v11 = (unsigned int)(a4 - 1);
        }
      }
      if ( v16 >= *a7 )
      {
        if ( v16 > a5 )
          v16 = a5;
        if ( v16 <= 0x3D )
        {
          v17 = v16 - 2;
        }
        else if ( v16 <= dword_10033CF8 )
        {
          v16 = 61;
          v17 = 59;
        }
        else if ( v16 < dword_10033CFC )
        {
          v16 = dword_10033CF8;
          v17 = 60;
        }
        else if ( v16 < dword_10033D00 )
        {
          v16 = dword_10033CFC;
          v17 = 61;
        }
        else if ( v16 < dword_10033D04 )
        {
          v16 = dword_10033D00;
          v17 = 62;
        }
        else
        {
          v16 = dword_10033D04;
          v17 = 63;
        }
        v18 = (unsigned int)&a4[-v11 - 1];
        v20 = sub_1000EE80(a1[a1[80] + 1], v17 + 1, 0x41u);
        v21 = sub_1000EE80(a1[66], v18 & 3, a1[71]) + v20;
        v19 = (sub_1000EE80(a1[67], v18 >> 2, a1[79]) + v21) / (double)v16;
        if ( v19 < *a10 )
        {
          result = a7;
          *a10 = v19;
          *a7 = v16;
          *a8 = v11;
          *a9 = v17;
          goto LABEL_32;
        }
        if ( v19 == *a10 && v11 > *a8 )
        {
          result = (unsigned int *)a9;
          *a7 = v16;
          *a8 = v11;
          *a9 = v17;
LABEL_32:
          if ( v16 >= a6 )
            return result;
        }
      }
    }
    a2 = (unsigned int *)a2[a3 + 2];
    result = a2;
  }
  while ( a2 );
  return result;
}
// 10033CF8: using guessed type int dword_10033CF8;
// 10033CFC: using guessed type int dword_10033CFC;
// 10033D00: using guessed type int dword_10033D00;
// 10033D04: using guessed type int dword_10033D04;

//----- (1001C6D0) --------------------------------------------------------
unsigned int __cdecl sub_1001C6D0(unsigned int a1, unsigned int a2)
{
  unsigned int result; // eax

  for ( result = a1; result >= a2; result = result % a2 + result / a2 )
    ;
  return result;
}

//----- (1001C6F0) --------------------------------------------------------
unsigned int __cdecl sub_1001C6F0(_DWORD *a1, unsigned int *a2, unsigned int a3)
{
  int v3; // ecx
  unsigned __int16 **v4; // esi
  unsigned int v5; // edx
  unsigned int *v6; // eax
  unsigned __int16 **v7; // edx
  unsigned __int16 **v8; // ebx
  unsigned __int16 *v9; // ecx
  unsigned __int16 ***v10; // eax
  unsigned __int16 *v11; // eax
  unsigned int v12; // eax
  int v13; // edx
  unsigned __int16 **v14; // ecx
  _DWORD *v15; // eax
  unsigned __int16 *v16; // eax
  unsigned int v17; // eax
  unsigned int v18; // eax
  unsigned __int16 *v19; // eax
  unsigned __int16 ***v20; // eax
  unsigned __int16 *v21; // eax
  unsigned __int16 ***v22; // eax
  unsigned __int16 *v23; // eax
  unsigned __int16 ***v24; // eax
  unsigned int v25; // eax
  unsigned int v26; // eax
  unsigned int v27; // eax
  unsigned __int16 *v28; // eax
  unsigned __int16 *v29; // eax
  unsigned __int16 *v30; // eax
  unsigned int v31; // eax
  unsigned int result; // eax

  v3 = a1[76];
  v4 = (unsigned __int16 **)(v3 + 32 * a1[77]);
  v5 = (unsigned int)(a1[77] + 1) % a1[70];
  a1[77] = v5;
  v6 = (unsigned int *)*v4;
  v7 = (unsigned __int16 **)(v3 + 32 * v5);
  v8 = v7;
  if ( *v4 )
  {
    if ( (unsigned int)v4[1] >= 4 )
    {
      *v7 = (unsigned __int16 *)((char *)v6 + 1);
      v17 = (unsigned int)v4[1];
      if ( v17 > 2 )
        v18 = v17 - 1;
      else
        v18 = 0;
      v7[1] = (unsigned __int16 *)v18;
      v7[2] = 0;
      v7[3] = 0;
      v7[4] = 0;
      v19 = v4[5];
      if ( v19 )
      {
        *((_DWORD *)v19 + 2) = v7;
        v7[5] = v4[5];
        v4[5] = 0;
      }
      else
      {
        v20 = (unsigned __int16 ***)(a1[73] + 4 * sub_1001C6D0(**v4, a1[83]));
        if ( *v20 == v4 )
          *v20 = v8;
      }
      v21 = v4[6];
      if ( v21 )
      {
        *((_DWORD *)v21 + 3) = v8;
        v8[6] = v4[6];
        v4[6] = 0;
      }
      else
      {
        v22 = (unsigned __int16 ***)(a1[74] + 4 * sub_1001C6D0(*(_DWORD *)*v4 & 0xFFFFFF, a1[84]));
        if ( *v22 == v4 )
          *v22 = 0;
      }
      v23 = v4[7];
      if ( v23 )
      {
        *((_DWORD *)v23 + 4) = v8;
        v8[7] = v4[7];
        v4[7] = 0;
        goto LABEL_28;
      }
    }
    else
    {
      v9 = v4[5];
      if ( v9 )
      {
        *((_DWORD *)v9 + 2) = 0;
        v4[5] = 0;
      }
      else
      {
        v10 = (unsigned __int16 ***)(a1[73] + 4 * sub_1001C6D0(*(unsigned __int16 *)v6, a1[83]));
        if ( *v10 == v4 )
          *v10 = 0;
      }
      v11 = v4[6];
      if ( v11 )
      {
        *((_DWORD *)v11 + 3) = 0;
        v4[6] = 0;
      }
      else
      {
        v12 = sub_1001C6D0(*(_DWORD *)*v4 & 0xFFFFFF, a1[84]);
        v13 = a1[74];
        v14 = *(unsigned __int16 ***)(v13 + 4 * v12);
        v15 = (_DWORD *)(v13 + 4 * v12);
        if ( v14 == v4 )
          *v15 = 0;
      }
      v16 = v4[7];
      if ( v16 )
      {
        *((_DWORD *)v16 + 4) = 0;
        v4[7] = 0;
LABEL_28:
        *v4 = 0;
        goto LABEL_29;
      }
    }
    v24 = (unsigned __int16 ***)(a1[75] + 4 * sub_1001C6D0(*(_DWORD *)*v4, a1[85]));
    if ( *v24 == v4 )
      *v24 = 0;
    goto LABEL_28;
  }
LABEL_29:
  if ( a1[82] <= 2u )
  {
    *v4 = (unsigned __int16 *)a2;
    v25 = sub_1001C6D0(*(unsigned __int16 *)a2, a1[83]);
    v4[2] = *(unsigned __int16 **)(a1[73] + 4 * v25);
    *(_DWORD *)(a1[73] + 4 * v25) = v4;
    v26 = sub_1001C6D0(*a2 & 0xFFFFFF, a1[84]);
    v4[3] = *(unsigned __int16 **)(a1[74] + 4 * v26);
    *(_DWORD *)(a1[74] + 4 * v26) = v4;
    v27 = sub_1001C6D0(*a2, a1[85]);
    v4[4] = *(unsigned __int16 **)(a1[75] + 4 * v27);
    *(_DWORD *)(a1[75] + 4 * v27) = v4;
    v28 = v4[2];
    if ( v28 )
      *((_DWORD *)v28 + 5) = v4;
    v29 = v4[3];
    if ( v29 )
      *((_DWORD *)v29 + 6) = v4;
    v30 = v4[4];
    if ( v30 )
      *((_DWORD *)v30 + 7) = v4;
    sub_1001C9C0((_DWORD **)v4, 0xFFFF, 0);
    sub_1001C9C0((_DWORD **)v4, 0xFFFFFFF, 1);
    v4[1] = (unsigned __int16 *)a1[81];
    a1[82] = a1[81];
  }
  v31 = a1[81];
  if ( v31 && (v31 >= a3 || *((_BYTE *)a2 + v31 + 1) != *(_BYTE *)a2) )
    a1[81] = v31 - 1;
  result = a1[82];
  if ( result )
    a1[82] = --result;
  if ( !a1[81] )
  {
    result = sub_1001C380((int)a2 + 1, a3 - 1);
    a1[81] = result;
  }
  return result;
}

//----- (1001C9C0) --------------------------------------------------------
_DWORD **__cdecl sub_1001C9C0(_DWORD **a1, int a2, int a3)
{
  _DWORD **result; // eax
  int v4; // esi
  _DWORD **v5; // edx

  result = (_DWORD **)a1[a3 + 2];
  v4 = a2 & **a1;
  if ( result )
  {
    do
    {
      v5 = (_DWORD **)result[a3 + 2];
      if ( v4 == (a2 & **result) )
      {
        result[a3 + 5][a3 + 2] = v5;
        if ( v5 )
          v5[a3 + 5] = result[a3 + 5];
        result[a3 + 5] = 0;
        result[a3 + 2] = 0;
      }
      result = v5;
    }
    while ( v5 );
  }
  return result;
}

//----- (1001CA20) --------------------------------------------------------
unsigned int __cdecl sub_1001CA20(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi
  unsigned int v4; // esi
  int v5; // eax
  unsigned int v6; // esi

  v3 = sub_1000E090(a2) + 296;
  v4 = 65 * sub_1000E090(65) + v3;
  v5 = 4;
  if ( a3 < 4 )
    v5 = a3;
  v6 = sub_1000E090(v5) + v4;
  return v6 + sub_1000E090((a3 >> 2) + 1);
}

//----- (1001CA70) --------------------------------------------------------
int *__cdecl sub_1001CA70(int *a1, _DWORD *a2)
{
  unsigned int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // esi
  int v7; // ebx
  int *v8; // ebp
  int v9; // esi
  int v10; // ebx
  int v11; // eax
  int v12; // edx
  unsigned int v13; // eax
  int v15; // [esp-8h] [ebp-20h]
  int v16; // [esp-4h] [ebp-1Ch]
  int v17; // [esp+10h] [ebp-8h]
  unsigned int v18; // [esp+14h] [ebp-4h]
  unsigned int v19; // [esp+1Ch] [ebp+4h]

  a1[68] = *a2 & 0x1FF;
  v3 = *a2 >> 9;
  a1[69] = v3;
  if ( v3 >= 4 )
    v3 = 4;
  v4 = ((unsigned int)a1[69] >> 2) + 1;
  a1[70] = v3;
  v5 = a1[68];
  a1[71] = v4;
  a1[73] = 0;
  a1[72] = 0;
  v6 = a2[1] & 0x1FF;
  *a1 = sub_1000E0C0((int)(a1 + 74), 0, v5 - 1, v6);
  v19 = 0;
  v7 = *a1 + sub_1000E090(v6);
  v8 = a1 + 1;
  do
  {
    v9 = (unsigned __int8)(a2[2] >> (24 - v19));
    v18 = sub_1000E090(v9);
    v17 = 16;
    do
    {
      *v8 = sub_1000E0C0(v7, 0, 64, v9);
      v7 += v18;
      ++v8;
      --v17;
    }
    while ( v17 );
    v19 += 8;
  }
  while ( v19 < 0x20 );
  a1[65] = sub_1000E0C0(v7, 0, 64, v9);
  v10 = v18 + v7;
  v11 = sub_1000E0C0(v10, 0, a1[70] - 1, a1[70]);
  v12 = a1[71];
  a1[66] = v11;
  v16 = a2[1] >> 9;
  v15 = v12 - 1;
  v13 = sub_1000E090(a1[70]);
  a1[67] = sub_1000E0C0(v10 + v13, 0, v15, v16);
  return a1;
}

//----- (1001CBE0) --------------------------------------------------------
int __usercall sub_1001CBE0@<eax>(int a1@<ebx>, unsigned int *a2, int *a3, _BYTE *a4)
{
  unsigned int v5; // ebx
  unsigned int v6; // eax
  int v7; // ebx
  _WORD *v8; // ebp
  unsigned int v9; // eax
  unsigned int v10; // ebp
  unsigned int v11; // eax
  unsigned int v12; // eax
  _WORD *v14; // ebx
  __int16 v15; // ax
  char *v16; // [esp+10h] [ebp+4h]

  v5 = sub_1000E6F0(a1, a2[a2[73] + 1], (int)a3);
  if ( v5 > 0x10000 )
  {
    v6 = sub_1000E020(a3, 0x41u);
    *(_WORD *)v5 = v6;
    v5 = v6;
  }
  a2[73] = v5;
  if ( v5 )
  {
    if ( v5 < 0x3D )
      v7 = v5 + 1;
    else
      v7 = dword_10033C04[v5];
    v8 = (_WORD *)sub_1000E6F0(v7, a2[66], (int)a3);
    if ( (unsigned int)v8 > 0x10000 )
    {
      v9 = sub_1000E020(a3, a2[70]);
      *v8 = v9;
      v8 = (_WORD *)v9;
    }
    v16 = (char *)v8 + 1;
    v10 = sub_1000E6F0(v7, a2[67], (int)a3);
    if ( v10 > 0x10000 )
    {
      v11 = a2[69];
      if ( v11 > a2[72] )
        v11 = a2[72];
      v12 = sub_1000E020(a3, (v11 >> 2) + 1);
      *(_WORD *)v10 = v12;
      v10 = v12;
    }
    a2[72] += v7;
    sub_1001CD30(a4, (_BYTE *)(&a4[-4 * v10] - v16), v7);
    return v7;
  }
  else
  {
    v14 = (_WORD *)sub_1000E6F0(0, *a2, (int)a3);
    if ( (unsigned int)v14 > 0x10000 )
    {
      v15 = sub_1000E020(a3, a2[68]);
      *v14 = v15;
      LOBYTE(v14) = v15;
    }
    *a4 = (_BYTE)v14;
    ++a2[72];
    return 1;
  }
}
// 10033C04: using guessed type int dword_10033C04[];

//----- (1001CD30) --------------------------------------------------------
_BYTE *__cdecl sub_1001CD30(_BYTE *a1, _BYTE *a2, int a3)
{
  _BYTE *result; // eax
  _BYTE *v5; // [esp+4h] [ebp-4h]

  result = a2;
  v5 = a2;
  while ( a3 )
  {
    *a1++ = *v5;
    result = ++v5;
    --a3;
  }
  return result;
}

//----- (1001CD80) --------------------------------------------------------
int __cdecl sub_1001CD80(int *a1, int a2, int a3)
{
  unsigned int v3; // eax
  unsigned int v4; // eax

  sub_10019A60(a1, 52);
  v3 = sub_1001BB90(255, 256, 0x3FFF8u);
  sub_10019B90(*a1, 12, v3);
  v4 = sub_1001BAE0(255, 256, 0x3FFF8u);
  sub_10019B90(*a1, 16, v4);
  return sub_10019B90(*a1, 20, ((unsigned int)(9 * a2 + 7) >> 3) + 4 * (3 * a3 + 9));
}

//----- (1001CE00) --------------------------------------------------------
int __usercall sub_1001CE00@<eax>(int a1@<ebx>, _DWORD *a2, int a3)
{
  char *v3; // ecx
  int result; // eax

  v3 = (char *)a2[5];
  *a2 = a3;
  a2[1] = 0;
  a2[2] = v3;
  sub_10019D80(a1, 12 * a3, 0, v3);
  result = a2[2] + 12 * *a2;
  a2[9] = 0;
  a2[8] = 0;
  a2[12] = 0;
  a2[11] = 0;
  a2[7] = result;
  a2[6] = result;
  a2[10] = 0x7FFFFFFF;
  return result;
}

//----- (1001CE50) --------------------------------------------------------
int sub_1001CE50()
{
  return 8;
}

//----- (1001CE60) --------------------------------------------------------
_DWORD *__cdecl sub_1001CE60(_DWORD *a1, unsigned int a2, unsigned int *a3)
{
  unsigned int v3; // esi
  int *i; // ebx
  int v6; // eax
  int v7; // eax
  _DWORD *v9; // [esp-4h] [ebp-14h]

  v3 = a2;
  for ( i = (int *)sub_1001BBC0(a1[4], a1[3], 255, 256, 0x3FFF8u); v3; a3 = (unsigned int *)((char *)a3 + v6) )
  {
    v6 = sub_1001BED0((int)i, (int)(a1 + 6), a3, v3);
    v3 -= v6;
  }
  v7 = a1[1];
  v9 = (_DWORD *)(a1[2] + 12 * v7);
  a1[1] = v7 + 1;
  return sub_1001BDE0(i, v9);
}

//----- (1001CED0) --------------------------------------------------------
unsigned int __cdecl sub_1001CED0(int a1, _DWORD *a2)
{
  int v2; // ecx
  unsigned int v3; // ecx
  unsigned int v4; // esi
  unsigned int v5; // ecx
  unsigned int v6; // edi
  int v7; // ecx
  bool v8; // zf
  int v9; // ecx
  unsigned int v10; // ecx
  int v11; // edi
  int v12; // ecx
  unsigned int v13; // edx
  unsigned int v14; // esi
  unsigned int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // edx
  unsigned int v19; // ecx
  int v20; // ecx

  if ( (*(_DWORD *)(a1 + 44) & 0x20000000) != 0 )
    *(_DWORD *)(a1 + 32) |= 1 << *(_DWORD *)(a1 + 36);
  v2 = *(_DWORD *)(a1 + 36) + 1;
  *(_DWORD *)(a1 + 36) = v2;
  if ( v2 == 32 )
  {
    **(_DWORD **)(a1 + 24) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 24) += 4;
    *(_DWORD *)(a1 + 36) = 0;
    *(_DWORD *)(a1 + 32) = 0;
  }
  v3 = *(_DWORD *)(a1 + 48) + 1;
  *(_DWORD *)(a1 + 48) = v3;
  v4 = -((~*(_DWORD *)(a1 + 44) & 0x20000000) != 0);
  if ( v3 > 0x20 )
  {
    do
    {
      v5 = *(_DWORD *)(a1 + 36);
      v6 = v4 << v5;
      v5 += 32;
      *(_DWORD *)(a1 + 36) = v5;
      *(_DWORD *)(a1 + 32) |= v6;
      if ( v5 >= 0x20 )
      {
        **(_DWORD **)(a1 + 24) = *(_DWORD *)(a1 + 32);
        v7 = *(_DWORD *)(a1 + 36);
        v8 = v7 == 32;
        v9 = v7 - 32;
        *(_DWORD *)(a1 + 24) += 4;
        *(_DWORD *)(a1 + 36) = v9;
        if ( v8 )
          *(_DWORD *)(a1 + 32) = 0;
        else
          *(_DWORD *)(a1 + 32) = v4 >> (32 - v9);
      }
      v10 = *(_DWORD *)(a1 + 48) - 32;
      *(_DWORD *)(a1 + 48) = v10;
    }
    while ( v10 > 0x20 );
  }
  v11 = *(_DWORD *)(a1 + 48);
  v12 = *(_DWORD *)(a1 + 36);
  v13 = v4 & dword_1002A3A8[v11];
  v14 = v13 << v12;
  v15 = v11 + v12;
  *(_DWORD *)(a1 + 36) = v15;
  *(_DWORD *)(a1 + 32) |= v14;
  if ( v15 >= 0x20 )
  {
    **(_DWORD **)(a1 + 24) = *(_DWORD *)(a1 + 32);
    v16 = *(_DWORD *)(a1 + 36);
    v8 = v16 == 32;
    v17 = v16 - 32;
    *(_DWORD *)(a1 + 24) += 4;
    *(_DWORD *)(a1 + 36) = v17;
    if ( v8 )
      *(_DWORD *)(a1 + 32) = 0;
    else
      *(_DWORD *)(a1 + 32) = v13 >> (v11 - v17);
  }
  v18 = -*(_DWORD *)(a1 + 36) & 0x1F;
  *(_DWORD *)(a1 + 48) = 0;
  if ( v18 )
  {
    v19 = v18 + *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = v19;
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 32);
    if ( v19 >= 0x20 )
    {
      **(_DWORD **)(a1 + 24) = *(_DWORD *)(a1 + 32);
      v20 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(a1 + 24) += 4;
      *(_DWORD *)(a1 + 36) = v20 - 32;
      *(_DWORD *)(a1 + 32) = 0;
    }
  }
  *a2 = *(_DWORD *)(a1 + 20);
  return ((unsigned int)(*(_DWORD *)(a1 + 36) + 8 * (*(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 28))) >> 3)
       + 12 * *(_DWORD *)a1;
}
// 1002A3A8: using guessed type int dword_1002A3A8[6];

//----- (1001D060) --------------------------------------------------------
int __cdecl sub_1001D060(int a1, _DWORD *a2, int a3, int a4, int a5, _BYTE *a6)
{
  int v7; // esi
  unsigned int v8; // eax
  int v9; // edx
  int v10; // ebx
  unsigned int v11; // eax
  int v13; // edi
  int *i; // ebp
  int v15; // eax
  bool v16; // cc
  int *v18; // [esp+10h] [ebp-2Ch]
  _DWORD v19[3]; // [esp+14h] [ebp-28h]
  int v20[2]; // [esp+20h] [ebp-1Ch] BYREF
  unsigned int v21; // [esp+28h] [ebp-14h]
  int v22; // [esp+2Ch] [ebp-10h]
  int v23; // [esp+30h] [ebp-Ch]
  int v24; // [esp+34h] [ebp-8h]
  int v25; // [esp+38h] [ebp-4h]
  int v26; // [esp+44h] [ebp+8h]
  _DWORD *v27; // [esp+48h] [ebp+Ch]

  v7 = 0;
  v20[0] = (int)(a2 + 9);
  v20[1] = (int)(a2 + 9);
  v22 = 0;
  v21 = 0;
  v25 = 0;
  v23 = 0x7FFFFFFF;
  v24 = 0;
  v8 = a2[9];
  v21 = v8 >> 31;
  v20[0] = (int)(a2 + 10);
  v8 &= ~0x80000000;
  v9 = (16 * (unsigned __int8)byte_1002A4B4[v8 & 0xF]) | (unsigned __int8)byte_1002A4B4[(unsigned __int8)v8 >> 4];
  v10 = (unsigned __int8)byte_1002A4B4[(v8 >> 8) & 0xF];
  v22 = 1;
  v25 = (unsigned __int8)byte_1002A4C4[(v8 >> 28) & 7] | (8
                                                        * ((unsigned __int8)byte_1002A4B4[HIBYTE(v8) & 0xF] | (16 * ((unsigned __int8)byte_1002A4B4[(v8 >> 20) & 0xF] | (16 * ((unsigned __int8)byte_1002A4B4[HIWORD(v8) & 0xF] | (16 * ((unsigned __int8)byte_1002A4B4[(unsigned __int16)v8 >> 12] | (16 * (v10 | (16 * v9)))))))))));
  v11 = sub_1001CA20(255, 256, 0x3FFF8u);
  v18 = (int *)off_10033620((int)aWPublicGrannyR_24, 1403, 4, v11);
  v19[0] = a3;
  v19[1] = a4;
  v19[2] = a5;
  v26 = 0;
  v27 = a2;
  do
  {
    v13 = v19[v26];
    for ( i = sub_1001CA70(v18, v27); v7 < v13; a6 += v15 )
    {
      v15 = sub_1001CBE0((int)a6, (unsigned int *)i, v20, a6);
      v7 += v15;
    }
    v16 = ++v26 < 3;
    v27 += 3;
  }
  while ( v16 );
  return off_10033624((int)aWPublicGrannyR_24, 1440, (int)v18);
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (1001D220) --------------------------------------------------------
void __usercall sub_1001D220(int a1@<ebx>, char *a2)
{
  sub_10019D80(a1, 0x30u, 0, a2);
}

//----- (1001D240) --------------------------------------------------------
void __cdecl sub_1001D240(float *a1, float *a2, float *a3, float *a4, float a5, int a6)
{
  float v6; // edx
  double v7; // st7
  double v8; // st6
  float v9; // eax
  float v10; // ecx
  long double v11; // st7
  double v12; // st7
  double v13; // st6
  double v14; // st7
  double v15; // st6
  double v16; // st5
  double v17; // st5
  double v18; // st7
  long double v19; // st7
  long double v20; // st7
  long double v21; // st7
  long double v22; // st7
  double v23; // st6
  long double v24; // st7
  float *v25; // ebx
  long double v26; // st7
  double v27; // st7
  double v28; // st6
  long double v29; // st7
  double v30; // st7
  long double v31; // st7
  long double v32; // st7
  long double v33; // st7
  double v34; // st7
  float v35; // [esp+4h] [ebp-4Ch]
  float v36; // [esp+4h] [ebp-4Ch]
  float v37; // [esp+8h] [ebp-48h]
  float v38; // [esp+Ch] [ebp-44h]
  float v39; // [esp+Ch] [ebp-44h]
  float v40; // [esp+10h] [ebp-40h]
  float v41; // [esp+10h] [ebp-40h]
  float v42; // [esp+14h] [ebp-3Ch]
  float v43; // [esp+14h] [ebp-3Ch]
  float v44; // [esp+18h] [ebp-38h]
  float v45; // [esp+18h] [ebp-38h]
  float v46; // [esp+1Ch] [ebp-34h] BYREF
  float v47; // [esp+20h] [ebp-30h]
  float v48; // [esp+24h] [ebp-2Ch]
  float v49; // [esp+28h] [ebp-28h]
  float v50[9]; // [esp+2Ch] [ebp-24h] BYREF
  float v51; // [esp+58h] [ebp+8h]
  int v52; // [esp+58h] [ebp+8h]
  float v53; // [esp+60h] [ebp+10h]

  v6 = a2[3];
  v7 = a2[1];
  v8 = -*a2;
  v48 = a2[2];
  v46 = v8;
  v47 = -v7;
  v49 = v6;
  v48 = -v48;
  sub_100189A0(v50, &v46);
  sub_10018BC0(&v46, &v46, a4);
  v9 = v47;
  v10 = v48;
  *(float *)(a6 + 36) = v46;
  *(float *)(a6 + 40) = v9;
  *(float *)(a6 + 44) = v10;
  v11 = 1.0 / sqrt(sub_1001D620((float *)(a6 + 36)));
  *(float *)(a6 + 36) = v11 * *(float *)(a6 + 36);
  *(float *)(a6 + 40) = v11 * *(float *)(a6 + 40);
  *(float *)(a6 + 44) = v11 * *(float *)(a6 + 44);
  v12 = *a3 - *a1;
  v13 = a3[1] - a1[1];
  v38 = a3[2] - a1[2];
  v51 = v12;
  v53 = v13;
  v35 = v50[2] * v38 + v50[1] * v13 + v50[0] * v12;
  v14 = v50[5] * v38 + v50[4] * v13 + v50[3] * v51;
  v15 = v50[8] * v38 + v50[7] * v53 + v50[6] * v51;
  v16 = v15 * *(float *)(a6 + 44) + v14 * *(float *)(a6 + 40) + v35 * *(float *)(a6 + 36);
  *(float *)(a6 + 8) = v16;
  v17 = -v16;
  v36 = v17 * *(float *)(a6 + 36) + v35;
  v37 = v17 * *(float *)(a6 + 40) + v14;
  v39 = v17 * *(float *)(a6 + 44) + v15;
  v18 = sub_1001D620(&v46);
  v19 = atan2(sqrt(v18), v49);
  v20 = v19 + v19;
  *(float *)(a6 + 4) = v20;
  v21 = cos(v20);
  v22 = 1.0 - v21 + 1.0 - v21;
  if ( v22 <= 0.0 )
  {
    *(_DWORD *)a6 = 0;
    goto LABEL_7;
  }
  v23 = v39 * v39 + v37 * v37 + v36 * v36;
  *(float *)&v52 = v23;
  v24 = sqrt(v23 / v22);
  *(float *)a6 = v24;
  if ( v24 <= 0.000099999997 )
  {
LABEL_7:
    *(_DWORD *)(a6 + 20) = 0;
    *(_DWORD *)(a6 + 16) = 0;
    *(_DWORD *)(a6 + 12) = 0;
    *(_DWORD *)(a6 + 32) = 0;
    *(_DWORD *)(a6 + 28) = 0;
    *(_DWORD *)(a6 + 24) = 0;
    goto LABEL_8;
  }
  *(float *)(a6 + 24) = v36;
  *(float *)(a6 + 28) = v37;
  *(float *)(a6 + 32) = v39;
  v25 = (float *)(a6 + 12);
  v26 = 1.0 / sqrt(sub_1001D620((float *)(a6 + 24)));
  *(float *)(a6 + 24) = v26 * *(float *)(a6 + 24);
  *(float *)(a6 + 28) = v26 * *(float *)(a6 + 28);
  *(float *)(a6 + 32) = v26 * *(float *)(a6 + 32);
  v27 = *(float *)(a6 + 36) * *(float *)(a6 + 32) - *(float *)(a6 + 24) * *(float *)(a6 + 44);
  v28 = *(float *)(a6 + 24) * *(float *)(a6 + 40) - *(float *)(a6 + 36) * *(float *)(a6 + 28);
  *(float *)(a6 + 12) = *(float *)(a6 + 44) * *(float *)(a6 + 28) - *(float *)(a6 + 40) * *(float *)(a6 + 32);
  *(float *)(a6 + 16) = v27;
  *(float *)(a6 + 20) = v28;
  v29 = 1.0 / sqrt(sub_1001D620((float *)(a6 + 12)));
  *(float *)(a6 + 12) = v29 * *(float *)(a6 + 12);
  *(float *)(a6 + 16) = v29 * *(float *)(a6 + 16);
  *(float *)(a6 + 20) = v29 * *(float *)(a6 + 20);
  v30 = -1.0;
  if ( fabs(*(float *)(a6 + 4)) > 3.1415927 )
    v30 = 1.0;
  v31 = v30 * sqrt(*(float *)a6 * *(float *)a6 - *(float *)&v52 * 0.25);
  v40 = v36 * 0.5;
  v41 = v31 * *v25 + v40;
  v42 = v37 * 0.5;
  v43 = v31 * *(float *)(a6 + 16) + v42;
  v44 = v39 * 0.5;
  v45 = 0.0 - (v31 * *(float *)(a6 + 20) + v44);
  *(float *)(a6 + 20) = v45;
  *v25 = 0.0 - v41;
  *(float *)(a6 + 16) = 0.0 - v43;
  v32 = 1.0 / sqrt(sub_1001D620((float *)(a6 + 12)));
  *v25 = v32 * *v25;
  *(float *)(a6 + 16) = v32 * *(float *)(a6 + 16);
  *(float *)(a6 + 20) = v32 * *(float *)(a6 + 20);
  sub_1001D5E0((float *)(a6 + 24), (float *)(a6 + 36), (float *)(a6 + 12));
  v33 = 1.0 / sqrt(sub_1001D620((float *)(a6 + 24)));
  *(float *)(a6 + 24) = v33 * *(float *)(a6 + 24);
  *(float *)(a6 + 28) = v33 * *(float *)(a6 + 28);
  *(float *)(a6 + 32) = v33 * *(float *)(a6 + 32);
LABEL_8:
  if ( a5 > 0.0 )
  {
    v34 = 1.0 / a5;
    *(float *)(a6 + 4) = v34 * *(float *)(a6 + 4);
    *(float *)(a6 + 8) = v34 * *(float *)(a6 + 8);
  }
}
// 1002A170: using guessed type float flt_1002A170;

//----- (1001D5E0) --------------------------------------------------------
float *__cdecl sub_1001D5E0(float *a1, float *a2, float *a3)
{
  double v3; // st7
  double v4; // st6
  float *result; // eax

  v3 = *a3 * a2[2] - a3[2] * *a2;
  v4 = a3[1] * *a2 - a2[1] * *a3;
  result = a1;
  *a1 = a3[2] * a2[1] - a3[1] * a2[2];
  a1[1] = v3;
  a1[2] = v4;
  return result;
}

//----- (1001D620) --------------------------------------------------------
double __cdecl sub_1001D620(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (1001D650) --------------------------------------------------------
float *__cdecl sub_1001D650(float *a1, float a2, float *a3)
{
  double v3; // st7
  float *result; // eax
  long double v5; // st7
  long double v6; // st7

  v3 = a2 * a1[2];
  result = a3;
  *a3 = v3 * a1[9];
  a3[1] = v3 * a1[10];
  a3[2] = v3 * a1[11];
  v5 = (cos(a2 * a1[1]) - 1.0) * *a1;
  *a3 = v5 * a1[3] + *a3;
  a3[1] = v5 * a1[4] + a3[1];
  a3[2] = v5 * a1[5] + a3[2];
  v6 = sin(a2 * a1[1]) * *a1;
  *a3 = v6 * a1[6] + *a3;
  a3[1] = v6 * a1[7] + a3[1];
  a3[2] = v6 * a1[8] + a3[2];
  return result;
}

//----- (1001D6D0) --------------------------------------------------------
float *__cdecl sub_1001D6D0(float *a1, float a2, float *a3)
{
  float *result; // eax
  double v4; // st7

  result = a1;
  v4 = a2 * a1[1];
  *a3 = v4 * a1[9];
  a3[1] = v4 * a1[10];
  a3[2] = v4 * a1[11];
  return result;
}

//----- (1001D700) --------------------------------------------------------
float *__cdecl sub_1001D700(float *a1, float a2, float *a3, float *a4)
{
  long double v4; // st7
  long double v5; // st6
  int v7[3]; // [esp+8h] [ebp-1Ch] BYREF
  float v8[4]; // [esp+14h] [ebp-10h] BYREF

  sub_1001D650(a1, a2, (float *)v7);
  sub_10018C80((float *)v7, a4);
  *a3 = *(float *)v7 + *a3;
  a3[1] = *(float *)&v7[1] + a3[1];
  a3[2] = *(float *)&v7[2] + a3[2];
  v4 = a2 * a1[1] * 0.5;
  v5 = sin(v4);
  v8[0] = v5 * a1[9];
  v8[1] = v5 * a1[10];
  v8[2] = v5 * a1[11];
  v8[3] = cos(v4);
  return sub_10018BC0(a4, a4, v8);
}

//----- (1001D790) --------------------------------------------------------
unsigned int *__cdecl sub_1001D790(int a1)
{
  bool v1; // zf
  unsigned int *result; // eax
  unsigned int i; // ecx
  unsigned int *v4; // [esp+0h] [ebp-4h] BYREF

  v4 = 0;
  sub_10019A60(&v4, 8);
  sub_10019BC0((int)v4, 0, 4, a1, 8);
  v1 = sub_10019C60((int)aWPublicGrannyR_14, 53) == 0;
  result = v4;
  if ( !v1 )
  {
    for ( i = 0; i < *v4; ++i )
    {
      *(_DWORD *)(result[1] + 8 * i) = -1;
      *(_DWORD *)(v4[1] + 8 * i + 4) = 0;
      result = v4;
    }
  }
  return result;
}

//----- (1001D810) --------------------------------------------------------
int __cdecl sub_1001D810(int a1)
{
  return off_10033624((int)aWPublicGrannyR_14, 70, a1);
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (1001D830) --------------------------------------------------------
void __cdecl sub_1001D830(unsigned int *a1, unsigned int a2, int a3)
{
  _DWORD *v3; // eax

  v3 = sub_1001D870(a1, a2);
  if ( v3 )
  {
    *v3 = a2;
    v3[1] = a3;
  }
  else
  {
    sub_10017FE0(3, 22, "%s(%d): Out of space in pointer hash table", aWPublicGrannyR_14, 127);
  }
}

//----- (1001D870) --------------------------------------------------------
_DWORD *__cdecl sub_1001D870(unsigned int *a1, unsigned int a2)
{
  unsigned int v2; // ecx
  unsigned int v3; // edx
  unsigned int v4; // edi
  _DWORD *result; // eax
  int v6; // esi

  v2 = *a1;
  if ( !*a1 )
  {
    sub_10017FE0(3, 22, "%s(%d): Hash value insert attempt on pointer hash table with 0 size", aWPublicGrannyR_14, 108);
    return 0;
  }
  v3 = a2 % v2;
  v4 = a2 % v2;
  if ( a2 % v2 >= v2 )
  {
LABEL_7:
    v6 = 0;
    if ( v3 )
    {
      for ( result = (_DWORD *)a1[1]; *result != a2 && *result != -1; result += 2 )
      {
        if ( ++v6 >= v3 )
          return 0;
      }
      return result;
    }
    return 0;
  }
  result = (_DWORD *)(a1[1] + 8 * v3);
  while ( *result != a2 && *result != -1 )
  {
    ++v4;
    result += 2;
    if ( v4 >= v2 )
      goto LABEL_7;
  }
  return result;
}

//----- (1001D8F0) --------------------------------------------------------
bool __cdecl sub_1001D8F0(unsigned int *a1, unsigned int a2, int a3)
{
  _DWORD *v3; // eax
  bool v4; // zf

  v3 = sub_1001D870(a1, a2);
  if ( v3 )
  {
    v4 = *v3 == -1;
    *v3 = a2;
    v3[1] = a3;
    return v4;
  }
  else
  {
    sub_10017FE0(3, 22, "%s(%d): Out of space in pointer hash table", aWPublicGrannyR_14, 146);
    return 0;
  }
}

//----- (1001D940) --------------------------------------------------------
char __cdecl sub_1001D940(unsigned int *a1, unsigned int a2, _DWORD *a3)
{
  _DWORD *v3; // eax

  v3 = sub_1001D870(a1, a2);
  if ( !v3 || *v3 == -1 )
    return 0;
  *a3 = v3[1];
  return 1;
}

//----- (1001D970) --------------------------------------------------------
void *__cdecl sub_1001D970(int a1)
{
  if ( !a1 )
    return &unk_1002A270;
  if ( a1 == 1 )
    return &unk_1002A294;
  return &unk_1002A300;
}

//----- (1001D990) --------------------------------------------------------
char *__cdecl sub_1001D990(int a1)
{
  if ( a1 >= 4 )
    return aUnknownS3tcTex;
  else
    return off_10033EEC[a1];
}
// 10033EEC: using guessed type char *off_10033EEC[4];

//----- (1001D9B0) --------------------------------------------------------
int __cdecl sub_1001D9B0(_WORD *a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  unsigned int v7; // ebx
  int v8; // ebp
  unsigned int i; // ebx
  int v11; // [esp+14h] [ebp+4h]
  int v12; // [esp+18h] [ebp+8h]
  unsigned int v13; // [esp+1Ch] [ebp+Ch]
  unsigned int v14; // [esp+20h] [ebp+10h]

  v7 = (4 * (a3 - a4)) >> 2;
  v12 = a3 >> 2;
  v14 = a4 >> 2;
  v8 = 0;
  sub_1001F1F0();
  if ( a5 >> 2 )
  {
    v11 = 4 * v7;
    v13 = a5 >> 2;
    do
    {
      for ( i = v14; i; --i )
      {
        v8 += sub_1001F310(a1, a2, v12);
        a1 += 4;
        a2 += 16;
      }
      a2 += v11;
      --v13;
    }
    while ( v13 );
  }
  return v8;
}

//----- (1001DA40) --------------------------------------------------------
int __cdecl sub_1001DA40(int a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  unsigned int v7; // ebx
  int v8; // ebp
  unsigned int i; // ebx
  int v11; // [esp+14h] [ebp+4h]
  int v12; // [esp+18h] [ebp+8h]
  unsigned int v13; // [esp+1Ch] [ebp+Ch]
  unsigned int v14; // [esp+20h] [ebp+10h]

  v7 = (4 * (a3 - a4)) >> 2;
  v12 = a3 >> 2;
  v14 = a4 >> 2;
  v8 = 0;
  sub_1001F1F0();
  if ( a5 >> 2 )
  {
    v11 = 4 * v7;
    v13 = a5 >> 2;
    do
    {
      for ( i = v14; i; --i )
      {
        v8 += sub_1001FE30(a1, a2, v12);
        a1 += 8;
        a2 += 16;
      }
      a2 += v11;
      --v13;
    }
    while ( v13 );
  }
  return v8;
}

//----- (1001DAD0) --------------------------------------------------------
int __cdecl sub_1001DAD0(_WORD *a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  unsigned int v7; // ebp
  int v8; // ebx
  int v9; // ebp
  int v10; // edx
  int v11; // ecx
  int v12; // eax
  int v13; // esi
  int v14; // ebx
  int v15; // eax
  int v16; // edx
  int v17; // ecx
  int v18; // esi
  int v19; // ebx
  int v20; // ecx
  int v21; // eax
  int v22; // edx
  int v23; // esi
  int v24; // ebx
  _WORD *v25; // edi
  int v26; // ebx
  int v27; // esi
  int v29; // [esp+10h] [ebp-4h]
  unsigned int v30; // [esp+18h] [ebp+4h]
  unsigned int v31; // [esp+1Ch] [ebp+8h]
  int v32; // [esp+20h] [ebp+Ch]
  unsigned int v33; // [esp+24h] [ebp+10h]

  v7 = (4 * (a3 - a4)) >> 2;
  v32 = a3 >> 2;
  v33 = a4 >> 2;
  v8 = 0;
  sub_1001F1F0();
  if ( a5 >> 2 )
  {
    v29 = 4 * v7;
    v30 = a5 >> 2;
    do
    {
      if ( v33 )
      {
        v9 = 4 * v32;
        v31 = v33;
        do
        {
          *a1 = *(_BYTE *)(a2 + 7) & 0xF0 | (*(_DWORD *)a2 >> 28) | *(_WORD *)(a2 + 14) & 0xF000 | (*(_DWORD *)(a2 + 8) >> 20) & 0xF00;
          v10 = dword_10047650[(*(unsigned __int8 *)(a2 + 7) - dword_10047450[*(_DWORD *)(a2 + 4) >> 28]) & 0x1FF]
              + dword_10047650[(*(unsigned __int8 *)(a2 + 3) - dword_10047450[*(_DWORD *)a2 >> 28]) & 0x1FF]
              + dword_10047650[(*(unsigned __int8 *)(a2 + 15)
                              - (unsigned __int16)dword_10047450[*(_DWORD *)(a2 + 12) >> 28]) & 0x1FF];
          v11 = *(unsigned __int8 *)(a2 + 11);
          v12 = *(_DWORD *)(a2 + 8) >> 28;
          v13 = v9 + a2;
          v14 = dword_10047650[(v11 - dword_10047450[v12]) & 0x1FF] + v10 + v8;
          a1[1] = *(_BYTE *)(v13 + 7) & 0xF0 | (*(_DWORD *)v13 >> 28) | *(_WORD *)(v13 + 14) & 0xF000 | (*(_DWORD *)(v13 + 8) >> 20) & 0xF00;
          v15 = dword_10047650[(*(unsigned __int8 *)(v13 + 7) - dword_10047450[*(_DWORD *)(v13 + 4) >> 28]) & 0x1FF]
              + dword_10047650[(*(unsigned __int8 *)(v13 + 3) - dword_10047450[*(_DWORD *)v13 >> 28]) & 0x1FF]
              + dword_10047650[(*(unsigned __int8 *)(v13 + 15)
                              - (unsigned __int16)dword_10047450[*(_DWORD *)(v13 + 12) >> 28]) & 0x1FF];
          v16 = *(unsigned __int8 *)(v13 + 11);
          v17 = *(_DWORD *)(v13 + 8) >> 28;
          v18 = v9 + v13;
          v19 = dword_10047650[(v16 - dword_10047450[v17]) & 0x1FF] + v15 + v14;
          a1[2] = *(_BYTE *)(v18 + 7) & 0xF0 | (*(_DWORD *)v18 >> 28) | *(_WORD *)(v18 + 14) & 0xF000 | (*(_DWORD *)(v18 + 8) >> 20) & 0xF00;
          v20 = dword_10047650[(*(unsigned __int8 *)(v18 + 7) - dword_10047450[*(_DWORD *)(v18 + 4) >> 28]) & 0x1FF]
              + dword_10047650[(*(unsigned __int8 *)(v18 + 3) - dword_10047450[*(_DWORD *)v18 >> 28]) & 0x1FF]
              + dword_10047650[(*(unsigned __int8 *)(v18 + 15)
                              - (unsigned __int16)dword_10047450[*(_DWORD *)(v18 + 12) >> 28]) & 0x1FF];
          v21 = *(unsigned __int8 *)(v18 + 11);
          v22 = *(_DWORD *)(v18 + 8) >> 28;
          v23 = v9 + v18;
          v24 = dword_10047650[(v21 - dword_10047450[v22]) & 0x1FF] + v20 + v19;
          v25 = a1 + 4;
          *(v25 - 1) = *(_BYTE *)(v23 + 7) & 0xF0 | (*(_DWORD *)v23 >> 28) | *(_WORD *)(v23 + 14) & 0xF000 | (*(_DWORD *)(v23 + 8) >> 20) & 0xF00;
          v26 = dword_10047650[(*(unsigned __int8 *)(v23 + 11) - dword_10047450[*(_DWORD *)(v23 + 8) >> 28]) & 0x1FF]
              + dword_10047650[(*(unsigned __int8 *)(v23 + 7) - dword_10047450[*(_DWORD *)(v23 + 4) >> 28]) & 0x1FF]
              + dword_10047650[(*(unsigned __int8 *)(v23 + 3) - dword_10047450[*(_DWORD *)v23 >> 28]) & 0x1FF]
              + dword_10047650[(*(unsigned __int8 *)(v23 + 15)
                              - (unsigned __int16)dword_10047450[*(_DWORD *)(v23 + 12) >> 28]) & 0x1FF]
              + v24;
          v27 = v23 - 12 * v32;
          v8 = sub_1001F310(v25, v27, v32) + v26;
          a1 = v25 + 4;
          a2 = v27 + 16;
          --v31;
        }
        while ( v31 );
      }
      a2 += v29;
      --v30;
    }
    while ( v30 );
  }
  return v8;
}
// 10047450: using guessed type int dword_10047450[16];
// 10047650: using guessed type int dword_10047650[512];

//----- (1001DE70) --------------------------------------------------------
int __cdecl sub_1001DE70(int a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  int v8; // ebp
  int v9; // ebx
  unsigned int v10; // eax
  _WORD *v11; // esi
  int v13; // [esp+14h] [ebp+4h]
  unsigned int v14; // [esp+18h] [ebp+8h]
  unsigned int v15; // [esp+1Ch] [ebp+Ch]
  unsigned int v16; // [esp+1Ch] [ebp+Ch]
  unsigned int v17; // [esp+20h] [ebp+10h]

  v15 = (4 * (a3 - a4)) >> 2;
  v8 = a3 >> 2;
  v14 = a4 >> 2;
  v9 = 0;
  sub_1001F1F0();
  if ( a5 >> 2 )
  {
    v13 = 4 * v15;
    v17 = a5 >> 2;
    do
    {
      if ( v14 )
      {
        v16 = v14;
        do
        {
          v10 = sub_10020670(a1, a2 + 3, 4 * v8);
          v11 = (_WORD *)(a1 + 8);
          v9 += sub_1001F310(v11, a2, v8) + v10;
          a1 = (int)(v11 + 4);
          a2 += 16;
          --v16;
        }
        while ( v16 );
      }
      a2 += v13;
      --v17;
    }
    while ( v17 );
  }
  return v9;
}

//----- (1001DF20) --------------------------------------------------------
int __cdecl sub_1001DF20(_WORD *a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5, _DWORD *a6)
{
  int v6; // esi
  unsigned int v7; // ebp
  _WORD *v8; // edi
  unsigned int v9; // ebx
  unsigned int v10; // edx
  int v11; // ebx
  int v12; // ecx
  int v13; // eax
  int v14; // edx
  int v15; // esi
  unsigned int v16; // ebp
  int v17; // edx
  int v18; // ecx
  int v19; // eax
  int v20; // esi
  unsigned int v21; // ebp
  int v22; // eax
  int v23; // edx
  int v24; // ecx
  int v25; // esi
  unsigned int v26; // ebp
  _WORD *v27; // edi
  int v28; // esi
  unsigned int v29; // eax
  bool v30; // zf
  int result; // eax
  int v32; // esi
  int v33; // edi
  unsigned int v34; // ebx
  unsigned int v35; // eax
  int v36; // eax
  _WORD *v37; // ecx
  int v38; // esi
  unsigned int v39; // edx
  __int16 v40; // bx
  int v41; // eax
  unsigned int v42; // edx
  __int16 v43; // bx
  int v44; // eax
  unsigned int v45; // edx
  int v46; // eax
  unsigned int v47; // [esp+10h] [ebp-18h]
  unsigned int v48; // [esp+14h] [ebp-14h]
  unsigned int v49; // [esp+18h] [ebp-10h]
  unsigned int v50; // [esp+1Ch] [ebp-Ch]
  unsigned int v51; // [esp+1Ch] [ebp-Ch]
  unsigned int v52; // [esp+20h] [ebp-8h]
  unsigned int v53; // [esp+2Ch] [ebp+4h]
  unsigned int v54; // [esp+30h] [ebp+8h]
  int v55; // [esp+34h] [ebp+Ch]
  int v56; // [esp+38h] [ebp+10h]
  int v57; // [esp+3Ch] [ebp+14h]

  v6 = a2;
  v7 = 0;
  v8 = a1;
  v9 = (4 * (a3 - a4)) >> 2;
  v55 = a3 >> 2;
  v48 = a4 >> 2;
  v56 = 0;
  v47 = 0;
  sub_1001F1F0();
  v10 = a5 >> 2;
  v52 = a5 >> 2;
  if ( !(a5 >> 2) )
    goto LABEL_9;
  v57 = 4 * v9;
  v50 = v10;
  do
  {
    if ( v48 )
    {
      v11 = 4 * v55;
      v49 = v48;
      do
      {
        *v8 = (*(_DWORD *)v6 >> 28) | *(_BYTE *)(v6 + 7) & 0xF0 | *(_WORD *)(v6 + 14) & 0xF000 | (*(_DWORD *)(v6 + 8) >> 20) & 0xF00;
        v12 = dword_10047650[(*(unsigned __int8 *)(v6 + 11) - dword_10047450[*(_DWORD *)(v6 + 8) >> 28]) & 0x1FF]
            + dword_10047650[(*(unsigned __int8 *)(v6 + 7) - dword_10047450[*(_DWORD *)(v6 + 4) >> 28]) & 0x1FF]
            + dword_10047650[(*(unsigned __int8 *)(v6 + 15)
                            - (unsigned __int16)dword_10047450[*(_DWORD *)(v6 + 12) >> 28]) & 0x1FF];
        v13 = *(unsigned __int8 *)(v6 + 3);
        v14 = *(_DWORD *)v6 >> 28;
        v15 = v11 + v6;
        v16 = dword_10047650[(v13 - dword_10047450[v14]) & 0x1FF] + v12 + v7;
        v8[1] = (*(_DWORD *)v15 >> 28) | *(_BYTE *)(v15 + 7) & 0xF0 | *(_WORD *)(v15 + 14) & 0xF000 | (*(_DWORD *)(v15 + 8) >> 20) & 0xF00;
        v17 = dword_10047650[(*(unsigned __int8 *)(v15 + 11) - dword_10047450[*(_DWORD *)(v15 + 8) >> 28]) & 0x1FF]
            + dword_10047650[(*(unsigned __int8 *)(v15 + 7) - dword_10047450[*(_DWORD *)(v15 + 4) >> 28]) & 0x1FF]
            + dword_10047650[(*(unsigned __int8 *)(v15 + 15)
                            - (unsigned __int16)dword_10047450[*(_DWORD *)(v15 + 12) >> 28]) & 0x1FF];
        v18 = *(unsigned __int8 *)(v15 + 3);
        v19 = *(_DWORD *)v15 >> 28;
        v20 = v11 + v15;
        v21 = dword_10047650[(v18 - dword_10047450[v19]) & 0x1FF] + v17 + v16;
        v8[2] = (*(_DWORD *)v20 >> 28) | *(_BYTE *)(v20 + 7) & 0xF0 | *(_WORD *)(v20 + 14) & 0xF000 | (*(_DWORD *)(v20 + 8) >> 20) & 0xF00;
        v22 = dword_10047650[(*(unsigned __int8 *)(v20 + 11) - dword_10047450[*(_DWORD *)(v20 + 8) >> 28]) & 0x1FF]
            + dword_10047650[(*(unsigned __int8 *)(v20 + 7) - dword_10047450[*(_DWORD *)(v20 + 4) >> 28]) & 0x1FF]
            + dword_10047650[(*(unsigned __int8 *)(v20 + 15)
                            - (unsigned __int16)dword_10047450[*(_DWORD *)(v20 + 12) >> 28]) & 0x1FF];
        v23 = *(unsigned __int8 *)(v20 + 3);
        v24 = *(_DWORD *)v20 >> 28;
        v25 = v11 + v20;
        v26 = dword_10047650[(v23 - dword_10047450[v24]) & 0x1FF] + v22 + v21;
        v8[3] = (*(_DWORD *)v25 >> 28) | *(_BYTE *)(v25 + 7) & 0xF0 | *(_WORD *)(v25 + 14) & 0xF000 | (*(_DWORD *)(v25 + 8) >> 20) & 0xF00;
        v27 = v8 + 4;
        v7 = dword_10047650[(*(unsigned __int8 *)(v25 + 3) - dword_10047450[*(_DWORD *)v25 >> 28]) & 0x1FF]
           + dword_10047650[(*(unsigned __int8 *)(v25 + 11) - dword_10047450[*(_DWORD *)(v25 + 8) >> 28]) & 0x1FF]
           + dword_10047650[(*(unsigned __int8 *)(v25 + 7) - dword_10047450[*(_DWORD *)(v25 + 4) >> 28]) & 0x1FF]
           + dword_10047650[(*(unsigned __int8 *)(v25 + 15)
                           - (unsigned __int16)dword_10047450[*(_DWORD *)(v25 + 12) >> 28]) & 0x1FF]
           + v26;
        v28 = v25 - 12 * v55;
        v29 = sub_1001F310(v27, v28, v55);
        v8 = v27 + 4;
        v6 = v28 + 16;
        v30 = v49 == 1;
        v56 += v29;
        --v49;
      }
      while ( !v30 );
      v10 = v52;
    }
    v6 += v57;
    --v50;
  }
  while ( v50 );
  if ( v7 )
  {
    v32 = a2;
    v33 = (int)a1;
    if ( !v10 )
      goto LABEL_17;
    v51 = v10;
    do
    {
      v34 = v48;
      if ( v48 )
      {
        do
        {
          v35 = sub_10020670(v33, v32 + 3, 4 * v55);
          v33 += 16;
          v32 += 16;
          --v34;
          v47 += v35;
        }
        while ( v34 );
        v10 = v52;
      }
      v32 += v57;
      --v51;
    }
    while ( v51 );
    if ( v47 > v7 )
    {
      v36 = a2;
      v37 = a1;
      if ( v10 )
      {
        v53 = v10;
        do
        {
          if ( v48 )
          {
            v38 = 4 * v55;
            v54 = v48;
            do
            {
              v37 += 8;
              *(v37 - 8) = (*(_DWORD *)v36 >> 28) | *(_WORD *)(v36 + 14) & 0xF000 | *(_BYTE *)(v36 + 7) & 0xF0 | (*(_DWORD *)(v36 + 8) >> 20) & 0xF00;
              v39 = *(_DWORD *)(v36 + v38 + 8);
              v40 = *(_BYTE *)(v36 + v38 + 7) & 0xF0;
              v41 = v38 + v36;
              *(v37 - 7) = (*(_DWORD *)v41 >> 28) | *(_WORD *)(v41 + 14) & 0xF000 | v40 | (v39 >> 20) & 0xF00;
              v42 = *(_DWORD *)(v41 + v38 + 8);
              v43 = *(_BYTE *)(v41 + v38 + 7) & 0xF0;
              v44 = v38 + v41;
              *(v37 - 6) = (*(_DWORD *)v44 >> 28) | *(_WORD *)(v44 + 14) & 0xF000 | v43 | (v42 >> 20) & 0xF00;
              LOBYTE(v43) = *(_BYTE *)(v44 + v38 + 7);
              v45 = *(_DWORD *)(v44 + v38 + 8);
              v46 = v38 + v44;
              *(v37 - 5) = (*(_DWORD *)v46 >> 28) | *(_WORD *)(v46 + 14) & 0xF000 | v43 & 0xF0 | (v45 >> 20) & 0xF00;
              v36 = 16 - 12 * v55 + v46;
              --v54;
            }
            while ( v54 );
          }
          v36 += v57;
          --v53;
        }
        while ( v53 );
      }
      *a6 = 2;
      return v56 + v7;
    }
    else
    {
LABEL_17:
      *a6 = 4;
      return v56 + v47;
    }
  }
  else
  {
LABEL_9:
    result = v56;
    *a6 = 2;
  }
  return result;
}
// 10047450: using guessed type int dword_10047450[16];
// 10047650: using guessed type int dword_10047650[512];

//----- (1001E4B0) --------------------------------------------------------
unsigned int __cdecl sub_1001E4B0(_DWORD *a1, unsigned __int16 *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v5; // edx
  unsigned int result; // eax
  unsigned __int16 *v7; // edi
  unsigned __int16 v8; // cx
  int v9; // eax
  int v10; // ebp
  unsigned int v11; // ecx
  unsigned int v12; // eax
  unsigned int v13; // ecx
  _DWORD *v14; // esi
  _DWORD *v15; // esi
  _DWORD *v16; // esi
  int v17; // edx
  int v18; // edx
  bool v19; // zf
  unsigned int v20; // [esp+8h] [ebp-2Ch]
  unsigned int v21; // [esp+Ch] [ebp-28h]
  _DWORD v22[2]; // [esp+24h] [ebp-10h]
  unsigned int v23; // [esp+2Ch] [ebp-8h]
  unsigned int v24; // [esp+30h] [ebp-4h]

  sub_1001F1F0();
  v5 = a3 >> 2;
  result = a4 >> 2;
  if ( a4 >> 2 )
  {
    v7 = a2;
    v21 = a4 >> 2;
    do
    {
      if ( v5 )
      {
        v20 = v5;
        do
        {
          v8 = v7[1];
          v9 = dword_10047490[v8 >> 11] | dword_10047550[(v8 >> 5) & 0x3F];
          v10 = dword_10048250[v8 & 0x1F];
          v11 = *((_DWORD *)v7 + 1);
          v12 = v10 | v9 | 0xFF000000;
          v22[0] = dword_10048250[*v7 & 0x1F] | dword_10047490[*v7 >> 11] | dword_10047550[(*v7 >> 5) & 0x3F] | 0xFF000000;
          v22[1] = v12;
          if ( v22[0] <= v12 )
          {
            v23 = ((LOBYTE(v22[0]) + (unsigned int)(unsigned __int8)v12) >> 1) | (((v12 >> 1) & 0x7F80)
                                                                                + ((v22[0] >> 1) & 0x7F80)) & 0xFFFFFF00 | (((v12 >> 1) & 0x7F8000) + ((v22[0] >> 1) & 0x7F8000)) & 0xFFFF0000 | 0xFF000000;
            v24 = 0;
          }
          else
          {
            v23 = (((unsigned __int8)v12 + 2 * (unsigned int)LOBYTE(v22[0])) / 3) | ((((BYTE1(v12)
                                                                                      + 2 * (unsigned int)BYTE1(v22[0]))
                                                                                     / 3) | ((((BYTE2(v12)
                                                                                              + 2
                                                                                              * (unsigned int)BYTE2(v22[0]))
                                                                                             / 3) | 0xFFFFFF00) << 8)) << 8);
            v24 = ((LOBYTE(v22[0]) + 2 * (unsigned int)(unsigned __int8)v12) / 3) | ((((BYTE1(v22[0])
                                                                                      + 2 * (unsigned int)BYTE1(v12))
                                                                                     / 3) | ((((BYTE2(v22[0])
                                                                                              + 2
                                                                                              * (unsigned int)BYTE2(v12))
                                                                                             / 3) | 0xFFFFFF00) << 8)) << 8);
          }
          *a1 = v22[v11 & 3];
          v13 = v11 >> 2;
          a1[1] = v22[v13 & 3];
          v13 >>= 2;
          a1[2] = v22[v13 & 3];
          v13 >>= 2;
          a1[3] = v22[v13 & 3];
          v13 >>= 2;
          a1[a3] = v22[v13 & 3];
          v14 = &a1[a3];
          v13 >>= 2;
          v14[1] = v22[v13 & 3];
          v13 >>= 2;
          v14[2] = v22[v13 & 3];
          v13 >>= 2;
          v14[3] = v22[v13 & 3];
          v13 >>= 2;
          v15 = &v14[a3];
          *v15 = v22[v13 & 3];
          v13 >>= 2;
          v15[1] = v22[v13 & 3];
          v13 >>= 2;
          v15[2] = v22[v13 & 3];
          v13 >>= 2;
          v15[3] = v22[v13 & 3];
          v16 = &v15[a3];
          v13 >>= 2;
          v17 = v22[v13 & 3];
          v13 >>= 2;
          *v16 = v17;
          v18 = v22[v13 & 3];
          v13 >>= 2;
          v16[1] = v18;
          v16[2] = v22[v13 & 3];
          v16[3] = v22[(v13 >> 2) & 3];
          a1 = &v16[-3 * a3 + 4];
          v7 = a2 + 4;
          v19 = v20 == 1;
          a2 += 4;
          --v20;
        }
        while ( !v19 );
        v5 = a3 >> 2;
      }
      a1 += 3 * a3;
      result = --v21;
    }
    while ( v21 );
  }
  return result;
}
// 10047490: using guessed type int dword_10047490[32];
// 10047550: using guessed type int dword_10047550[64];
// 10048250: using guessed type int dword_10048250[32];

//----- (1001E800) --------------------------------------------------------
unsigned int __cdecl sub_1001E800(int *a1, int *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v5; // ecx
  unsigned int result; // eax
  int *v7; // ebx
  unsigned int v8; // edi
  unsigned __int16 v9; // cx
  int v10; // eax
  int v11; // ebp
  unsigned int v12; // ecx
  unsigned int v13; // eax
  unsigned int v14; // edi
  unsigned int v15; // ecx
  int *v16; // esi
  int v17; // eax
  int v18; // eax
  unsigned int v19; // eax
  int *v20; // esi
  int v21; // edi
  int v22; // edi
  int v23; // edi
  int v24; // edi
  int *v25; // esi
  int v26; // edx
  int v27; // ecx
  bool v28; // zf
  unsigned int v29; // [esp+Ch] [ebp-2Ch]
  unsigned int v30; // [esp+10h] [ebp-28h]
  _DWORD v31[2]; // [esp+28h] [ebp-10h]
  unsigned int v32; // [esp+30h] [ebp-8h]
  unsigned int v33; // [esp+34h] [ebp-4h]

  sub_1001F1F0();
  v5 = a3 >> 2;
  result = a4 >> 2;
  if ( a4 >> 2 )
  {
    v7 = a2;
    v30 = a4 >> 2;
    do
    {
      if ( v5 )
      {
        v29 = v5;
        do
        {
          v8 = *v7;
          v9 = *((_WORD *)v7 + 5);
          v10 = dword_10047490[v9 >> 11] | dword_10047550[(v9 >> 5) & 0x3F];
          v11 = dword_10048250[v9 & 0x1F];
          v12 = v7[3];
          v13 = v11 | v10;
          v31[0] = dword_10048250[v7[2] & 0x1F] | dword_10047490[*((unsigned __int16 *)v7 + 4) >> 11] | dword_10047550[(*((unsigned __int16 *)v7 + 4) >> 5) & 0x3F];
          v31[1] = v13;
          if ( v31[0] <= v13 )
          {
            v32 = ((LOBYTE(v31[0]) + (unsigned int)(unsigned __int8)v13) >> 1) | (((v13 >> 1) & 0x7F80)
                                                                                + ((v31[0] >> 1) & 0x7F80)) & 0xFFFFFF00 | (((v13 >> 1) & 0x7F8000) + ((v31[0] >> 1) & 0x7F8000)) & 0xFFFF0000;
            v33 = 0xFFFF;
          }
          else
          {
            v32 = (((unsigned __int8)v13 + 2 * (unsigned int)LOBYTE(v31[0])) / 3) | ((((BYTE1(v13)
                                                                                      + 2 * (unsigned int)BYTE1(v31[0]))
                                                                                     / 3) | (((BYTE2(v13)
                                                                                             + 2
                                                                                             * (unsigned int)BYTE2(v31[0]))
                                                                                            / 3) << 8)) << 8);
            v33 = ((LOBYTE(v31[0]) + 2 * (unsigned int)(unsigned __int8)v13) / 3) | ((((BYTE1(v31[0])
                                                                                      + 2 * (unsigned int)BYTE1(v13))
                                                                                     / 3) | (((BYTE2(v31[0])
                                                                                             + 2
                                                                                             * (unsigned int)BYTE2(v13))
                                                                                            / 3) << 8)) << 8);
          }
          *a1 = dword_10047510[v8 & 0xF] | v31[v12 & 3];
          v14 = v8 >> 4;
          v15 = v12 >> 2;
          a1[1] = dword_10047510[v14 & 0xF] | v31[v15 & 3];
          v14 >>= 4;
          v15 >>= 2;
          a1[2] = dword_10047510[v14 & 0xF] | v31[v15 & 3];
          v14 >>= 4;
          v15 >>= 2;
          a1[3] = dword_10047510[v14 & 0xF] | v31[v15 & 3];
          v15 >>= 2;
          v14 >>= 4;
          v16 = &a1[a3];
          *v16 = dword_10047510[v14 & 0xF] | v31[v15 & 3];
          v15 >>= 2;
          v14 >>= 4;
          v17 = dword_10047510[v14 & 0xF] | v31[v15 & 3];
          v15 >>= 2;
          v16[1] = v17;
          v14 >>= 4;
          v18 = dword_10047510[v14 & 0xF] | v31[v15 & 3];
          v15 >>= 2;
          v16[2] = v18;
          v16[3] = v31[v15 & 3] | dword_10047510[v14 >> 4];
          v19 = a2[1];
          v15 >>= 2;
          v20 = &v16[a3];
          v21 = dword_10047510[v19 & 0xF] | v31[v15 & 3];
          v15 >>= 2;
          *v20 = v21;
          v19 >>= 4;
          v22 = dword_10047510[v19 & 0xF] | v31[v15 & 3];
          v15 >>= 2;
          v20[1] = v22;
          v19 >>= 4;
          v23 = dword_10047510[v19 & 0xF] | v31[v15 & 3];
          v15 >>= 2;
          v20[2] = v23;
          v19 >>= 4;
          v24 = dword_10047510[v19 & 0xF] | v31[v15 & 3];
          v15 >>= 2;
          v20[3] = v24;
          v25 = &v20[a3];
          v19 >>= 4;
          *v25 = dword_10047510[v19 & 0xF] | v31[v15 & 3];
          v15 >>= 2;
          v19 >>= 4;
          v25[1] = dword_10047510[v19 & 0xF] | v31[v15 & 3];
          v15 >>= 2;
          v19 >>= 4;
          v26 = v31[v15 & 3];
          v27 = v31[(v15 >> 2) & 3];
          v25[2] = dword_10047510[v19 & 0xF] | v26;
          v25[3] = dword_10047510[v19 >> 4] | v27;
          a1 = &v25[-3 * a3 + 4];
          v7 = a2 + 4;
          v28 = v29 == 1;
          a2 += 4;
          --v29;
        }
        while ( !v28 );
        v5 = a3 >> 2;
      }
      a1 += 3 * a3;
      result = --v30;
    }
    while ( v30 );
  }
  return result;
}
// 10047490: using guessed type int dword_10047490[32];
// 10047510: using guessed type int dword_10047510[16];
// 10047550: using guessed type int dword_10047550[64];
// 10048250: using guessed type int dword_10048250[32];

//----- (1001EC40) --------------------------------------------------------
unsigned int __cdecl sub_1001EC40(int *a1, unsigned __int8 *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v5; // ecx
  unsigned int result; // eax
  unsigned int v7; // edi
  unsigned __int16 v8; // bp
  unsigned int v9; // ebx
  unsigned int v10; // edx
  unsigned int v11; // ecx
  int v12; // eax
  unsigned int v13; // ecx
  unsigned int v14; // edi
  int *v15; // esi
  int v16; // eax
  int *v17; // esi
  unsigned int v18; // eax
  int v19; // edi
  int v20; // edi
  int v21; // edi
  int v22; // edi
  unsigned int *v23; // esi
  int v24; // edx
  int v25; // edx
  int v26; // ecx
  bool v27; // zf
  unsigned int v28; // [esp+10h] [ebp-4Ch]
  unsigned int v29; // [esp+14h] [ebp-48h]
  unsigned int v30; // [esp+2Ch] [ebp-30h]
  unsigned int v31; // [esp+30h] [ebp-2Ch]
  unsigned int v32; // [esp+34h] [ebp-28h]
  unsigned int v33; // [esp+38h] [ebp-24h]
  int v34; // [esp+3Ch] [ebp-20h]
  unsigned int v35; // [esp+40h] [ebp-1Ch]
  unsigned int v36; // [esp+44h] [ebp-18h]
  unsigned int v37; // [esp+48h] [ebp-14h]
  unsigned int v38; // [esp+4Ch] [ebp-10h]
  unsigned int v39; // [esp+50h] [ebp-Ch]
  unsigned int v40; // [esp+54h] [ebp-8h]
  unsigned int v41; // [esp+58h] [ebp-4h]

  sub_1001F1F0();
  v5 = a3 >> 2;
  result = a4 >> 2;
  if ( a4 >> 2 )
  {
    v29 = a4 >> 2;
    do
    {
      if ( v5 )
      {
        v28 = v5;
        do
        {
          v7 = *(_DWORD *)(a2 + 2);
          v8 = *((_WORD *)a2 + 5);
          v9 = *a2;
          v35 = a2[1];
          v10 = dword_10048250[v8 & 0x1F] | dword_10047490[v8 >> 11] | dword_10047550[(v8 >> 5) & 0x3F];
          v11 = *((_DWORD *)a2 + 3);
          v30 = dword_10048250[*((_WORD *)a2 + 4) & 0x1F] | dword_10047490[*((unsigned __int16 *)a2 + 4) >> 11] | dword_10047550[(*((unsigned __int16 *)a2 + 4) >> 5) & 0x3F];
          v31 = v10;
          if ( v30 <= v10 )
          {
            v32 = (((unsigned __int8)v30 + (unsigned int)(unsigned __int8)v31) >> 1) | (((v10 >> 1) & 0x7F80)
                                                                                      + ((v30 >> 1) & 0x7F80)) & 0xFFFFFF00 | (((v10 >> 1) & 0x7F8000) + ((v30 >> 1) & 0x7F8000)) & 0xFFFF0000;
            v33 = 0xFFFF;
          }
          else
          {
            v32 = (((unsigned __int8)v10 + 2 * (unsigned int)(unsigned __int8)v30) / 3) | ((((BYTE1(v10)
                                                                                            + 2
                                                                                            * (unsigned int)BYTE1(v30))
                                                                                           / 3) | (((BYTE2(v10) + 2 * (unsigned int)BYTE2(v30))
                                                                                                  / 3) << 8)) << 8);
            v33 = (((unsigned __int8)v30 + 2 * (unsigned int)(unsigned __int8)v10) / 3) | ((((BYTE1(v30)
                                                                                            + 2
                                                                                            * (unsigned int)BYTE1(v10))
                                                                                           / 3) | (((BYTE2(v30) + 2 * (unsigned int)BYTE2(v10))
                                                                                                  / 3) << 8)) << 8);
          }
          if ( v9 <= v35 )
          {
            v36 = ((v35 + 4 * v9) / 5) << 24;
            v37 = ((3 * v9 + 2 * v35) / 5) << 24;
            v38 = ((3 * v35 + 2 * v9) / 5) << 24;
            v39 = ((v9 + 4 * v35) / 5) << 24;
            v40 = 0;
            v41 = -16777216;
          }
          else
          {
            v36 = ((v35 + 6 * v9) / 7) << 24;
            v37 = ((5 * v9 + 2 * v35) / 7) << 24;
            v38 = ((3 * v35 + 4 * v9) / 7) << 24;
            v39 = ((3 * v9 + 4 * v35) / 7) << 24;
            v40 = ((5 * v35 + 2 * v9) / 7) << 24;
            v41 = ((v9 + 6 * v35) / 7) << 24;
          }
          v34 = v9 << 24;
          v12 = *(&v30 + (v11 & 3));
          v35 <<= 24;
          *a1 = *(&v34 + (v7 & 7)) | v12;
          v13 = v11 >> 2;
          v14 = v7 >> 3;
          a1[1] = *(&v34 + (v14 & 7)) | *(&v30 + (v13 & 3));
          v13 >>= 2;
          v14 >>= 3;
          a1[2] = *(&v34 + (v14 & 7)) | *(&v30 + (v13 & 3));
          v13 >>= 2;
          v14 >>= 3;
          a1[3] = *(&v34 + (v14 & 7)) | *(&v30 + (v13 & 3));
          v13 >>= 2;
          v14 >>= 3;
          a1[a3] = *(&v34 + (v14 & 7)) | *(&v30 + (v13 & 3));
          v15 = &a1[a3];
          v13 >>= 2;
          v14 >>= 3;
          v15[1] = *(&v34 + (v14 & 7)) | *(&v30 + (v13 & 3));
          v13 >>= 2;
          v14 >>= 3;
          v16 = *(&v34 + (v14 & 7)) | *(&v30 + (v13 & 3));
          v13 >>= 2;
          v15[2] = v16;
          v14 >>= 3;
          v15[3] = *(&v34 + (v14 & 7)) | *(&v30 + (v13 & 3));
          v13 >>= 2;
          v17 = &v15[a3];
          v18 = (v14 >> 3) | (*((unsigned __int16 *)a2 + 3) << 8);
          v19 = *(&v34 + ((v14 >> 3) & 7)) | *(&v30 + (v13 & 3));
          v13 >>= 2;
          *v17 = v19;
          v18 >>= 3;
          v20 = *(&v34 + (v18 & 7)) | *(&v30 + (v13 & 3));
          v13 >>= 2;
          v17[1] = v20;
          v18 >>= 3;
          v21 = *(&v34 + (v18 & 7)) | *(&v30 + (v13 & 3));
          v13 >>= 2;
          v17[2] = v21;
          v18 >>= 3;
          v22 = *(&v34 + (v18 & 7)) | *(&v30 + (v13 & 3));
          v13 >>= 2;
          v17[3] = v22;
          v23 = (unsigned int *)&v17[a3];
          v18 >>= 3;
          *v23 = *(&v34 + (v18 & 7)) | *(&v30 + (v13 & 3));
          v13 >>= 2;
          v18 >>= 3;
          v24 = *(&v34 + (v18 & 7)) | *(&v30 + (v13 & 3));
          v13 >>= 2;
          v23[1] = v24;
          v18 >>= 3;
          v25 = *(&v30 + (v13 & 3));
          v26 = *(&v30 + ((v13 >> 2) & 3));
          v23[2] = *(&v34 + (v18 & 7)) | v25;
          v23[3] = *(&v34 + (v18 >> 3)) | v26;
          a1 = (int *)&v23[-3 * a3 + 4];
          v27 = v28 == 1;
          a2 += 16;
          --v28;
        }
        while ( !v27 );
        v5 = a3 >> 2;
      }
      a1 += 3 * a3;
      result = --v29;
    }
    while ( v29 );
  }
  return result;
}
// 10047490: using guessed type int dword_10047490[32];
// 10047550: using guessed type int dword_10047550[64];
// 10048250: using guessed type int dword_10048250[32];

//----- (1001F1F0) --------------------------------------------------------
int sub_1001F1F0()
{
  int result; // eax
  int v1; // ecx
  int v2; // esi
  int v3; // ecx
  int v4; // esi
  int v5; // ecx
  int *v6; // esi
  int i; // ecx
  int v8; // ecx
  int v9; // edx

  result = dword_100482D0;
  if ( !dword_100482D0 )
  {
    v1 = 0;
    dword_100482D0 = 1;
    v2 = 0;
    do
    {
      dword_10047450[v2] = v1 / 15;
      dword_10047510[v2] = (v1 / 15) << 24;
      v1 += 255;
      ++v2;
    }
    while ( v1 < 4080 );
    v3 = 0;
    v4 = 0;
    do
    {
      dword_10047490[v4] = (v3 / 31) << 16;
      dword_10048250[v4] = v3 / 31;
      v3 += 255;
      ++v4;
    }
    while ( v3 < 8160 );
    v5 = 0;
    v6 = &dword_10047550;
    do
    {
      *v6++ = (v5 / 63) << 8;
      v5 += 255;
    }
    while ( (int)v6 < (int)dword_10047650 );
    for ( i = 0; i < 256; ++i )
      dword_10047E50[i] = i / 3;
    result = -255;
    do
    {
      v8 = -result;
      v9 = result++ & 0x1FF;
      dword_10047650[v9] = v8;
    }
    while ( result < 0 );
    for ( ; result < 256; ++result )
      dword_10047650[result & 0x1FF] = result;
  }
  return result;
}
// 10047450: using guessed type int dword_10047450[];
// 10047490: using guessed type int dword_10047490[];
// 10047510: using guessed type int dword_10047510[];
// 10047550: using guessed type int dword_10047550;
// 10047650: using guessed type int dword_10047650[512];
// 10047E50: using guessed type int dword_10047E50[256];
// 10048250: using guessed type int dword_10048250[];
// 100482D0: using guessed type int dword_100482D0;

//----- (1001F310) --------------------------------------------------------
unsigned int __cdecl sub_1001F310(_WORD *a1, int a2, int a3)
{
  unsigned int v4; // edi
  unsigned int *v5; // esi
  int i; // edx
  unsigned int v7; // eax
  int v8; // ecx
  unsigned int v9; // eax
  unsigned int result; // eax
  __int16 v11; // ax
  unsigned int v12; // ecx
  unsigned int j; // esi
  unsigned int v14; // ebx
  unsigned int v15; // ecx
  unsigned int v16; // edx
  unsigned int v17; // ebp
  unsigned int v18; // eax
  unsigned int v19; // esi
  unsigned int v20; // eax
  unsigned int v21; // esi
  int v22; // eax
  unsigned int v23; // ebx
  unsigned int v24; // ebp
  unsigned int v25; // edx
  unsigned int v26; // ecx
  unsigned int v27; // ecx
  unsigned __int8 *v28; // ecx
  int v29; // edi
  int v30; // eax
  int v31; // ecx
  int v32; // edi
  int v33; // eax
  unsigned int v34; // edx
  unsigned int v35; // esi
  unsigned int v36; // ebx
  unsigned int v37; // eax
  unsigned int v38; // ecx
  int v39; // edx
  int v40; // ebp
  int v41; // edx
  int v42; // eax
  int v43; // ecx
  int v44; // edi
  int v45; // esi
  unsigned __int8 *v46; // eax
  int v47; // ecx
  int v48; // edi
  int v49; // ebx
  unsigned int v50; // edx
  unsigned int v51; // esi
  unsigned int v52; // eax
  unsigned int v53; // ecx
  int v54; // eax
  bool v55; // zf
  unsigned int v56; // [esp+10h] [ebp-13Ch]
  int v57; // [esp+10h] [ebp-13Ch]
  int v58; // [esp+10h] [ebp-13Ch]
  unsigned int v59; // [esp+14h] [ebp-138h]
  unsigned int v60; // [esp+18h] [ebp-134h]
  __int16 v61; // [esp+18h] [ebp-134h]
  unsigned int v62; // [esp+1Ch] [ebp-130h]
  __int16 v63; // [esp+1Ch] [ebp-130h]
  int v64; // [esp+20h] [ebp-12Ch]
  int v65; // [esp+20h] [ebp-12Ch]
  int v66; // [esp+20h] [ebp-12Ch]
  __int16 v67; // [esp+24h] [ebp-128h]
  __int16 v68; // [esp+24h] [ebp-128h]
  __int16 v69; // [esp+28h] [ebp-124h]
  __int16 v70; // [esp+28h] [ebp-124h]
  __int16 v71; // [esp+28h] [ebp-124h]
  unsigned int v72; // [esp+2Ch] [ebp-120h]
  int v73; // [esp+2Ch] [ebp-120h]
  __int16 v74; // [esp+30h] [ebp-11Ch]
  __int16 v75; // [esp+30h] [ebp-11Ch]
  int v76; // [esp+34h] [ebp-118h]
  _BYTE *v77; // [esp+34h] [ebp-118h]
  int v78; // [esp+38h] [ebp-114h]
  int v79; // [esp+38h] [ebp-114h]
  unsigned int v80; // [esp+3Ch] [ebp-110h]
  __int16 v81; // [esp+40h] [ebp-10Ch]
  __int16 v82; // [esp+40h] [ebp-10Ch]
  unsigned int v83; // [esp+44h] [ebp-108h]
  int v84; // [esp+48h] [ebp-104h]
  int v85; // [esp+48h] [ebp-104h]
  int v86; // [esp+4Ch] [ebp-100h]
  int v87; // [esp+4Ch] [ebp-100h]
  int v88; // [esp+50h] [ebp-FCh]
  int v89; // [esp+50h] [ebp-FCh]
  int v90; // [esp+54h] [ebp-F8h]
  int v91; // [esp+54h] [ebp-F8h]
  int v92; // [esp+58h] [ebp-F4h] BYREF
  unsigned int v93; // [esp+5Ch] [ebp-F0h]
  int v94; // [esp+68h] [ebp-E4h] BYREF
  unsigned int v95; // [esp+6Ch] [ebp-E0h]
  int v96; // [esp+78h] [ebp-D4h] BYREF
  unsigned int v97; // [esp+7Ch] [ebp-D0h]
  int v98; // [esp+88h] [ebp-C4h]
  unsigned int v99; // [esp+8Ch] [ebp-C0h] BYREF
  unsigned int v100; // [esp+90h] [ebp-BCh]
  _BYTE v101[65]; // [esp+CCh] [ebp-80h] BYREF
  _BYTE v102[59]; // [esp+10Dh] [ebp-3Fh] BYREF
  char v103; // [esp+148h] [ebp-4h] BYREF

  v4 = 0;
  v5 = (unsigned int *)&v103;
  v64 = 4;
  do
  {
    for ( i = 3; i >= 0; --i )
    {
      v7 = ((*(_DWORD *)(a2 + 4 * (i ^ 3)) & 0xF8) << 13) | ((*(_DWORD *)(a2 + 4 * (i ^ 3)) & 0xFC00 | (*(_DWORD *)(a2 + 4 * (i ^ 3)) >> 17) & 0x7Cu) >> 2);
      v8 = 0;
      *v5 = v7;
      if ( v4 )
      {
        while ( v7 != *(&v99 + v8) )
        {
          if ( ++v8 >= v4 )
            goto LABEL_6;
        }
        ++*(_DWORD *)&v101[4 * v8];
      }
      else
      {
LABEL_6:
        *(&v99 + v4) = v7;
        *(_DWORD *)&v101[4 * v4++] = 1;
      }
      --v5;
    }
    a2 += 4 * a3;
    --v64;
  }
  while ( v64 );
  v56 = v4;
  if ( v4 == 1 )
  {
    v9 = v99 & 0x1F | ((v99 & 0x3F00 | (v99 >> 2) & 0x7C000) >> 3);
    a1[1] = 0;
    if ( v9 )
    {
      a1[2] = 0;
      a1[3] = 0;
      *a1 = v9;
    }
    else
    {
      a1[2] = 21845;
      a1[3] = 21845;
      *a1 = -1;
    }
    return 0;
  }
  if ( v4 != 2 )
  {
    v14 = 31;
    v15 = 0;
    v93 = 0;
    v97 = 0;
    v16 = 63;
    v17 = 31;
    v92 = 31;
    v96 = 63;
    v94 = 31;
    v95 = 0;
    if ( v4 )
    {
      do
      {
        v18 = *((_BYTE *)&v99 + 4 * v15 + 2) & 0x1F;
        if ( v18 < v14 )
          v14 = *((_BYTE *)&v99 + 4 * v15 + 2) & 0x1F;
        if ( v18 > v93 )
          v93 = *((_BYTE *)&v99 + 4 * v15 + 2) & 0x1F;
        v19 = *(&v99 + v15);
        v20 = (v19 >> 8) & 0x3F;
        if ( v20 < v16 )
          v16 = (*(&v99 + v15) >> 8) & 0x3F;
        if ( v20 > v97 )
          v97 = (*(&v99 + v15) >> 8) & 0x3F;
        v21 = v19 & 0x1F;
        v72 = v21;
        if ( v21 < v17 )
          v17 = v21;
        if ( v21 > v95 )
          v95 = v21;
        ++v15;
      }
      while ( v15 < v4 );
      v94 = v17;
      v96 = v16;
      v92 = v14;
    }
    else
    {
      v21 = v72;
    }
    sub_1001FC50((int)&v99 + 2, v101, v4, &v92, 31);
    sub_1001FC50((int)&v99 + 1, v101, v4, &v96, 63);
    sub_1001FC50((int)&v99, v101, v4, &v94, 31);
    v22 = 0;
    v83 = -1;
    v76 = 0;
    do
    {
      v23 = *(&v92 + (v22 & 1));
      v24 = *(&v92 + ((v22 >> 1) & 1));
      v25 = *(&v96 + ((v22 >> 2) & 1));
      v60 = *(&v96 + ((v22 >> 3) & 1));
      v62 = *(&v94 + ((v22 >> 4) & 1));
      v86 = dword_10047E50[2 * v23 + v24];
      v90 = dword_10047E50[2 * v25 + v60];
      v26 = *(&v94 + ((v22 >> 5) & 1));
      v84 = dword_10047E50[2 * v62 + v26];
      v78 = dword_10047E50[2 * v24 + v23];
      v65 = dword_10047E50[2 * v60 + v25];
      v81 = v23;
      v70 = v24;
      v74 = v25;
      v67 = v26;
      v88 = dword_10047E50[2 * v26 + v62];
      if ( v23 <= v24 && (v23 != v24 || v25 <= v60 && (v25 != v60 || v62 <= v26)) )
      {
        v27 = 0;
        v59 = 0;
        v80 = 0;
        if ( v56 )
        {
          while ( 1 )
          {
            v28 = (unsigned __int8 *)&v99 + 4 * v27 + 1;
            v29 = v28[1];
            v30 = *v28;
            v31 = -(unsigned __int8)*(_DWORD *)(v28 - 1);
            v32 = -v29;
            v33 = -v30;
            v98 = ((_WORD)v33 + (_WORD)v25) & 0x1FF;
            v34 = dword_10047650[((_WORD)v32 + (_WORD)v23) & 0x1FF]
                + dword_10047650[v98]
                + dword_10047650[((_WORD)v31 + (_WORD)v62) & 0x1FF];
            v35 = dword_10047650[((_WORD)v32 + (_WORD)v24) & 0x1FF]
                + dword_10047650[((_WORD)v33 + (_WORD)v60) & 0x1FF]
                + dword_10047650[((_WORD)v31 + v67) & 0x1FF];
            v36 = dword_10047650[((_WORD)v32 + (_WORD)v86) & 0x1FF]
                + dword_10047650[((_WORD)v33 + (_WORD)v90) & 0x1FF]
                + dword_10047650[((_WORD)v31 + (_WORD)v84) & 0x1FF];
            v37 = dword_10047650[((_WORD)v78 + (_WORD)v32) & 0x1FF]
                + dword_10047650[((_WORD)v33 + (_WORD)v65) & 0x1FF]
                + dword_10047650[((_WORD)v88 + (_WORD)v31) & 0x1FF];
            if ( v35 >= v34 )
            {
              if ( v34 <= v36 && v34 <= v37 )
              {
                v38 = v80;
                v59 += v34 * *(_DWORD *)&v101[4 * v80];
                goto LABEL_63;
              }
              if ( v35 > v34 )
                goto LABEL_59;
            }
            if ( v35 > v36 || v35 > v37 )
            {
LABEL_59:
              if ( v36 <= v34 && v36 <= v35 && v36 <= v37 )
              {
                v38 = v80;
                v59 += v36 * *(_DWORD *)&v101[4 * v80];
                goto LABEL_63;
              }
              v38 = v80;
              v39 = v37 * *(_DWORD *)&v101[4 * v80];
            }
            else
            {
              v38 = v80;
              v39 = v35 * *(_DWORD *)&v101[4 * v80];
            }
            v59 += v39;
LABEL_63:
            if ( v59 >= v83 )
            {
              v22 = v76;
              v21 = v72;
              goto LABEL_70;
            }
            v27 = v38 + 1;
            v80 = v27;
            if ( v27 >= v56 )
            {
              v22 = v76;
              v21 = v72;
              break;
            }
            LOWORD(v23) = v81;
            LOWORD(v25) = v74;
            LOWORD(v24) = v70;
          }
        }
        if ( v59 < v83 )
        {
          v21 = v22;
          v83 = v59;
          v72 = v22;
          if ( !v59 )
            break;
        }
      }
LABEL_70:
      v76 = ++v22;
    }
    while ( v22 < 64 );
    v40 = *(&v92 + (v21 & 1));
    v41 = *(&v92 + ((v21 >> 1) & 1));
    v42 = *(&v96 + ((v21 >> 2) & 1));
    v43 = *(&v96 + ((v21 >> 3) & 1));
    v87 = dword_10047E50[2 * v41 + v40];
    v44 = *(&v94 + ((v21 >> 4) & 1));
    v45 = *(&v94 + ((v21 >> 5) & 1));
    v91 = dword_10047E50[2 * v43 + v42];
    v61 = v42;
    v75 = v43;
    v85 = dword_10047E50[2 * v45 + v44];
    v66 = dword_10047E50[2 * v42 + v43];
    v46 = v102;
    v71 = v40;
    v82 = v41;
    v68 = v44;
    v63 = v45;
    v79 = dword_10047E50[2 * v40 + v41];
    v89 = dword_10047E50[2 * v44 + v45];
    v58 = 0;
    v77 = v102;
    v73 = 16;
    while ( 1 )
    {
      v47 = -(unsigned __int8)*(_DWORD *)(v46 - 1);
      v48 = -v46[1];
      v49 = -*v46;
      v50 = dword_10047650[(v75 - *v46) & 0x1FF]
          + dword_10047650[((_WORD)v41 - v46[1]) & 0x1FF]
          + dword_10047650[((_WORD)v45 - (unsigned __int8)*(_DWORD *)(v46 - 1)) & 0x1FF];
      v51 = dword_10047650[(v61 - *v46) & 0x1FF]
          + dword_10047650[((_WORD)v40 - v46[1]) & 0x1FF]
          + dword_10047650[(v68 - (unsigned __int8)*(_DWORD *)(v46 - 1)) & 0x1FF];
      v52 = dword_10047650[((_WORD)v91 - *v46) & 0x1FF]
          + dword_10047650[((_WORD)v87 - v46[1]) & 0x1FF]
          + dword_10047650[((_WORD)v85 - (unsigned __int8)*(_DWORD *)(v46 - 1)) & 0x1FF];
      v53 = dword_10047650[((_WORD)v66 + (_WORD)v49) & 0x1FF]
          + dword_10047650[((_WORD)v79 + (_WORD)v48) & 0x1FF]
          + dword_10047650[((_WORD)v89 + (_WORD)v47) & 0x1FF];
      if ( v51 < v50 )
        goto LABEL_79;
      if ( v50 <= v52 && v50 <= v53 )
      {
        v54 = 4 * v58;
        goto LABEL_86;
      }
      if ( v51 <= v50 )
      {
LABEL_79:
        if ( v51 <= v52 && v51 <= v53 )
        {
          v58 = (4 * v58) | 1;
          goto LABEL_87;
        }
      }
      if ( v52 <= v50 && v52 <= v51 && v52 <= v53 )
      {
        v58 = (4 * v58) | 2;
        goto LABEL_87;
      }
      v54 = (4 * v58) | 3;
LABEL_86:
      v58 = v54;
LABEL_87:
      v46 = v77 + 4;
      v55 = v73 == 1;
      v77 += 4;
      --v73;
      if ( v55 )
      {
        *a1 = v63 | (32 * (v75 | (v82 << 6)));
        a1[1] = v68 | (32 * (v61 | (v71 << 6)));
        result = v83;
        *((_DWORD *)a1 + 1) = v58;
        return result;
      }
      LOWORD(v40) = v71;
      LOWORD(v45) = v63;
      LOWORD(v41) = v82;
    }
  }
  v11 = v99;
  LOWORD(v12) = v100;
  if ( v99 < v100 )
  {
    v11 = v100;
    v12 = v99;
    v99 = v100;
    v100 = v12;
  }
  v57 = 0;
  v69 = BYTE2(v100);
  for ( j = 0; j < 0x10; ++j )
  {
    if ( dword_10047650[(HIBYTE(v11) - (unsigned __int16)(unsigned __int8)v102[4 * j]) & 0x1FF]
       + dword_10047650[(BYTE2(v99) - (unsigned __int16)(unsigned __int8)v102[4 * j + 1]) & 0x1FF]
       + dword_10047650[((unsigned __int8)v11 - (unsigned __int16)(unsigned __int8)*(_DWORD *)&v101[4 * j + 64]) & 0x1FF] > (unsigned int)(dword_10047650[(BYTE1(v12) - (unsigned __int16)(unsigned __int8)v102[4 * j]) & 0x1FF] + dword_10047650[(BYTE2(v100) - (unsigned __int16)(unsigned __int8)v102[4 * j + 1]) & 0x1FF] + dword_10047650[((unsigned __int8)v12 - (unsigned __int16)(unsigned __int8)*(_DWORD *)&v101[4 * j + 64]) & 0x1FF]) )
      v57 = (4 * v57) | 1;
    else
      v57 *= 4;
  }
  *a1 = (unsigned __int8)v11 | (unsigned __int16)(32 * (HIBYTE(v11) | (BYTE2(v99) << 6)));
  a1[1] = (unsigned __int8)v12 | (unsigned __int16)(32 * (BYTE1(v12) | (unsigned __int16)(v69 << 6)));
  *((_DWORD *)a1 + 1) = v57;
  return 0;
}
// 1001F647: variable 'v72' is possibly undefined
// 10047650: using guessed type int dword_10047650[512];
// 10047E50: using guessed type int dword_10047E50[256];

//----- (1001FC50) --------------------------------------------------------
unsigned int __cdecl sub_1001FC50(int a1, _DWORD *a2, unsigned int a3, _DWORD *a4, int a5)
{
  _DWORD *v5; // esi
  int v6; // edx
  unsigned int v7; // ecx
  unsigned int result; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  unsigned int v12; // ebp
  unsigned int v13; // ebx
  unsigned int v14; // edi
  _DWORD *v15; // esi
  int i; // eax
  unsigned int v17; // ecx
  unsigned int v18; // eax
  unsigned int v19; // eax
  unsigned int v20; // ecx
  int v21; // edx
  unsigned int v22; // ecx
  int v23; // ecx
  int v24; // [esp+4h] [ebp-24h]
  int *v25; // [esp+8h] [ebp-20h]
  int v26; // [esp+Ch] [ebp-1Ch]
  int v27; // [esp+10h] [ebp-18h]
  int v28; // [esp+14h] [ebp-14h]
  int v29; // [esp+18h] [ebp-10h]
  unsigned int v30; // [esp+1Ch] [ebp-Ch]
  __int16 v31; // [esp+20h] [ebp-8h]
  unsigned int v32; // [esp+3Ch] [ebp+14h]

  v5 = a4;
  v6 = a4[1];
  v7 = *a4;
  result = v6 - *a4;
  if ( result < 3 )
  {
    if ( result < 2 )
      return result;
    v6 = a5;
    if ( v7 < a5 - 3 )
    {
      a4[3] = v7 + 3;
      goto LABEL_6;
    }
    *a4 = a5 - 3;
  }
  a4[3] = v6;
LABEL_6:
  a4[1] = *a4 + 1;
  v9 = 1;
  a4[2] = a4[3] - 1;
  v32 = -1;
  v30 = 1;
  v26 = 0;
  v29 = 1;
  v25 = a4;
  do
  {
    v24 = v9;
    if ( v9 >= 4 )
      goto LABEL_35;
    v10 = *v25;
    v27 = *v25;
    while ( 1 )
    {
      v11 = v5[v9];
      v12 = dword_10047E50[2 * v10 + v11];
      v13 = dword_10047E50[2 * v11 + v10];
      v14 = 0;
      v31 = v11;
      v28 = 0;
      if ( a3 )
      {
        v15 = a2;
        for ( i = a1 - (_DWORD)a2; ; i = a1 - (_DWORD)a2 )
        {
          v17 = *((unsigned __int8 *)v15 + i);
          v18 = v17;
          if ( v17 >= v13 )
            break;
          if ( v17 < v12 )
          {
            v23 = v12 - v17;
            if ( dword_10047650[((_WORD)v27 - (_WORD)v18) & 0x1FF] <= v12 - v18 )
              v23 = dword_10047650[((_WORD)v27 - (_WORD)v18) & 0x1FF];
            v21 = v23 * *v15;
            goto LABEL_25;
          }
          v22 = v17 - v12;
          if ( v18 - v12 > v13 - v18 )
            v22 = v13 - v18;
          v14 += v22 * *v15;
LABEL_26:
          if ( v14 >= v32 )
          {
            v5 = a4;
            v9 = v24;
            goto LABEL_33;
          }
          ++v15;
          if ( ++v28 >= a3 )
          {
            v5 = a4;
            v9 = v24;
            goto LABEL_29;
          }
          LOWORD(v11) = v31;
        }
        v19 = dword_10047650[((_WORD)v11 - (_WORD)v17) & 0x1FF];
        v20 = v17 - v13;
        if ( v20 <= v19 )
          v19 = v20;
        v21 = v19 * *v15;
LABEL_25:
        v14 += v21;
        goto LABEL_26;
      }
LABEL_29:
      if ( v32 > v14 )
      {
        v32 = v14;
        v30 = v9 + v26;
        if ( !v14 )
          goto LABEL_36;
      }
LABEL_33:
      v24 = ++v9;
      if ( v9 >= 4 )
        break;
      v10 = *v25;
    }
    v9 = v29;
LABEL_35:
    v29 = ++v9;
    ++v25;
    v26 += 0x10000;
  }
  while ( v9 < 5 );
LABEL_36:
  result = (unsigned __int16)v30;
  *v5 = v5[HIWORD(v30)];
  v5[1] = v5[(unsigned __int16)v30];
  return result;
}
// 10047650: using guessed type int dword_10047650[512];
// 10047E50: using guessed type int dword_10047E50[256];

//----- (1001FE30) --------------------------------------------------------
unsigned int __cdecl sub_1001FE30(int a1, int a2, int a3)
{
  int v3; // ebp
  unsigned int v4; // edi
  unsigned int *v5; // eax
  int v6; // edx
  unsigned int *v7; // esi
  unsigned int v8; // eax
  int v9; // ecx
  bool v10; // zf
  unsigned int v12; // eax
  int v13; // esi
  int v14; // eax
  unsigned int i; // edx
  int v16; // eax
  unsigned int v17; // eax
  __int16 v18; // dx
  __int16 v19; // cx
  __int16 v20; // dx
  int v21; // eax
  unsigned int v22; // ebp
  int v23; // edx
  bool v24; // cc
  __int16 v25; // si
  unsigned int v26; // ecx
  unsigned int v27; // ebx
  unsigned int v28; // edx
  unsigned int v29; // ebp
  unsigned int v30; // eax
  unsigned int v31; // esi
  unsigned int v32; // eax
  unsigned int v33; // esi
  int v34; // eax
  unsigned int v35; // edx
  unsigned int v36; // ebx
  unsigned int v37; // ebp
  unsigned int v38; // ecx
  int v39; // ebx
  unsigned int v40; // ecx
  unsigned int v41; // edx
  unsigned int v42; // eax
  unsigned int v43; // eax
  int v44; // ebx
  int v45; // ebp
  int v46; // edx
  int v47; // edi
  int v48; // ecx
  int v49; // eax
  unsigned __int8 *v50; // esi
  int v51; // edi
  int v52; // edx
  int v53; // esi
  unsigned int v54; // eax
  unsigned int v55; // ecx
  unsigned int v56; // edx
  int v57; // [esp+10h] [ebp-12Ch]
  int v58; // [esp+10h] [ebp-12Ch]
  __int16 v59; // [esp+14h] [ebp-128h]
  unsigned int v60; // [esp+14h] [ebp-128h]
  __int16 v61; // [esp+14h] [ebp-128h]
  __int16 v62; // [esp+18h] [ebp-124h]
  unsigned int v63; // [esp+18h] [ebp-124h]
  int v64; // [esp+18h] [ebp-124h]
  unsigned int v65; // [esp+1Ch] [ebp-120h]
  unsigned int v66; // [esp+20h] [ebp-11Ch]
  unsigned int v67; // [esp+20h] [ebp-11Ch]
  int v68; // [esp+24h] [ebp-118h]
  unsigned int v69; // [esp+28h] [ebp-114h]
  int v70; // [esp+28h] [ebp-114h]
  __int16 v71; // [esp+2Ch] [ebp-110h]
  __int16 v72; // [esp+2Ch] [ebp-110h]
  __int16 v73; // [esp+2Ch] [ebp-110h]
  int v74; // [esp+30h] [ebp-10Ch]
  _BYTE *v75; // [esp+30h] [ebp-10Ch]
  __int16 v76; // [esp+34h] [ebp-108h]
  __int16 v77; // [esp+34h] [ebp-108h]
  __int16 v78; // [esp+34h] [ebp-108h]
  int v79; // [esp+38h] [ebp-104h]
  unsigned int v80; // [esp+38h] [ebp-104h]
  unsigned int v81; // [esp+38h] [ebp-104h]
  int v82; // [esp+3Ch] [ebp-100h]
  unsigned int v83; // [esp+3Ch] [ebp-100h]
  unsigned int v84; // [esp+3Ch] [ebp-100h]
  __int16 v85; // [esp+40h] [ebp-FCh]
  __int16 v86; // [esp+40h] [ebp-FCh]
  __int16 v87; // [esp+44h] [ebp-F8h]
  unsigned int v88; // [esp+48h] [ebp-F4h]
  unsigned int v89; // [esp+48h] [ebp-F4h]
  int v90; // [esp+4Ch] [ebp-F0h] BYREF
  unsigned int v91; // [esp+50h] [ebp-ECh]
  int v92; // [esp+5Ch] [ebp-E0h] BYREF
  unsigned int v93; // [esp+60h] [ebp-DCh]
  int v94; // [esp+6Ch] [ebp-D0h] BYREF
  unsigned int v95; // [esp+70h] [ebp-CCh]
  unsigned int v96; // [esp+7Ch] [ebp-C0h] BYREF
  unsigned int v97; // [esp+80h] [ebp-BCh]
  _BYTE v98[65]; // [esp+BCh] [ebp-80h] BYREF
  _BYTE v99[59]; // [esp+FDh] [ebp-3Fh] BYREF
  char v100; // [esp+138h] [ebp-4h] BYREF

  v3 = a2;
  v4 = 0;
  v79 = 0;
  v68 = 0;
  v96 = 0;
  v5 = (unsigned int *)&v100;
  v82 = 4;
  do
  {
    v6 = 3;
    v7 = v5;
    do
    {
      v8 = *(_DWORD *)(v3 + 4 * (v6 ^ 3)) & 0x80000000 | ((*(_DWORD *)(v3 + 4 * (v6 ^ 3)) & 0xF8) << 13) | ((*(_DWORD *)(v3 + 4 * (v6 ^ 3)) & 0xFC00 | (*(_DWORD *)(v3 + 4 * (v6 ^ 3)) >> 17) & 0x7Cu) >> 2);
      *v7 = v8;
      if ( (v8 & 0x80000000) != 0 )
      {
        v68 += 255 - HIBYTE(v8);
        v9 = 0;
        if ( v4 )
        {
          while ( v8 != *(&v96 + v9) )
          {
            if ( ++v9 >= v4 )
              goto LABEL_8;
          }
          ++*(_DWORD *)&v98[4 * v9];
        }
        else
        {
LABEL_8:
          *(&v96 + v4) = v8;
          *(_DWORD *)&v98[4 * v4++] = 1;
        }
      }
      else
      {
        v68 += HIBYTE(v8);
        v79 = 1;
      }
      --v6;
      --v7;
    }
    while ( v6 >= 0 );
    v3 += 4 * a3;
    v10 = v82 == 1;
    v5 = v7;
    --v82;
  }
  while ( !v10 );
  if ( !v79 )
    return sub_1001F310((_WORD *)a1, a2, a3);
  if ( v4 <= 1 )
  {
    v12 = v96 & 0x1F | ((v96 & 0x3F00 | (v96 >> 2) & 0x7C000) >> 3);
    *(_WORD *)a1 = 0;
    if ( v12 )
    {
      *(_WORD *)(a1 + 2) = v12;
      v13 = 1;
    }
    else
    {
      *(_WORD *)(a1 + 2) = -1;
      v13 = 0;
    }
    v14 = 0;
    for ( i = 0; i < 0x10; ++i )
    {
      v16 = 4 * v14;
      if ( (*(_DWORD *)&v98[4 * i + 64] & 0x80000000) != 0 )
        v14 = v13 | v16;
      else
        v14 = v16 | 3;
    }
    *(_DWORD *)(a1 + 4) = v14;
    return v68;
  }
  if ( v4 != 2 )
  {
    v26 = 0;
    v27 = 31;
    v28 = 63;
    v29 = 31;
    v94 = 31;
    v95 = 0;
    v92 = 63;
    v93 = 0;
    v90 = 31;
    v91 = 0;
    do
    {
      v30 = *((_BYTE *)&v96 + 4 * v26 + 2) & 0x1F;
      if ( v30 < v27 )
        v27 = *((_BYTE *)&v96 + 4 * v26 + 2) & 0x1F;
      if ( v30 > v95 )
        v95 = *((_BYTE *)&v96 + 4 * v26 + 2) & 0x1F;
      v31 = *(&v96 + v26);
      v32 = (v31 >> 8) & 0x3F;
      if ( v32 < v28 )
        v28 = (*(&v96 + v26) >> 8) & 0x3F;
      if ( v32 > v93 )
        v93 = (*(&v96 + v26) >> 8) & 0x3F;
      v33 = v31 & 0x1F;
      v69 = v33;
      if ( v33 < v29 )
        v29 = v33;
      if ( v33 > v91 )
        v91 = v33;
      ++v26;
    }
    while ( v26 < v4 );
    v90 = v29;
    v92 = v28;
    v94 = v27;
    sub_1001FC50((int)&v96 + 2, v98, v4, &v94, 31);
    sub_1001FC50((int)&v96 + 1, v98, v4, &v92, 63);
    sub_1001FC50((int)&v96, v98, v4, &v90, 31);
    v34 = 0;
    v67 = -1;
    v74 = 0;
    while ( 1 )
    {
      v35 = *(&v94 + (v34 & 1));
      v36 = *(&v94 + ((v34 >> 1) & 1));
      v37 = *(&v92 + ((v34 >> 2) & 1));
      v63 = *(&v90 + ((v34 >> 5) & 1));
      v60 = *(&v92 + ((v34 >> 3) & 1));
      v80 = (v36 + v35) >> 1;
      v38 = *(&v90 + ((v34 >> 4) & 1));
      v83 = (v37 + v60) >> 1;
      v87 = v35;
      v85 = v36;
      v72 = v37;
      v77 = v38;
      v88 = (v38 + v63) >> 1;
      if ( v35 <= v36 && (v35 != v36 || v37 <= v60 && (v37 != v60 || v38 <= v63)) )
        break;
LABEL_70:
      v74 = ++v34;
      if ( v34 >= 64 )
        goto LABEL_71;
    }
    v39 = 0;
    v65 = 0;
    while ( 1 )
    {
      v40 = dword_10047650[((_WORD)v35 - *((unsigned __int8 *)&v96 + 4 * v39 + 2)) & 0x1FF]
          + dword_10047650[((_WORD)v37 - *((unsigned __int8 *)&v96 + 4 * v39 + 1)) & 0x1FF]
          + dword_10047650[((_WORD)v38 - (unsigned __int8)*(&v96 + v39)) & 0x1FF];
      v41 = dword_10047650[(v85 - *((unsigned __int8 *)&v96 + 4 * v39 + 2)) & 0x1FF]
          + dword_10047650[((_WORD)v60 - *((unsigned __int8 *)&v96 + 4 * v39 + 1)) & 0x1FF]
          + dword_10047650[((_WORD)v63 - (unsigned __int8)*(&v96 + v39)) & 0x1FF];
      v42 = dword_10047650[((_WORD)v80 - *((unsigned __int8 *)&v96 + 4 * v39 + 2)) & 0x1FF]
          + dword_10047650[((_WORD)v83 - *((unsigned __int8 *)&v96 + 4 * v39 + 1)) & 0x1FF]
          + dword_10047650[((_WORD)v88 - (unsigned __int8)*(&v96 + v39)) & 0x1FF];
      if ( v41 >= v40 )
      {
        if ( v40 <= v42 )
        {
          v65 += v40 * *(_DWORD *)&v98[4 * v39];
          goto LABEL_64;
        }
        if ( v41 > v40 )
          goto LABEL_62;
      }
      if ( v41 > v42 )
LABEL_62:
        v43 = v42 * *(_DWORD *)&v98[4 * v39] + v65;
      else
        v43 = v41 * *(_DWORD *)&v98[4 * v39] + v65;
      v65 = v43;
LABEL_64:
      if ( v65 >= v67 )
      {
        v34 = v74;
        v33 = v69;
        goto LABEL_70;
      }
      if ( ++v39 >= v4 )
      {
        v34 = v74;
        v33 = v69;
        if ( v65 >= v67 )
          goto LABEL_70;
        v33 = v74;
        v67 = v65;
        v69 = v74;
        if ( v65 )
          goto LABEL_70;
LABEL_71:
        v44 = *(&v94 + (v33 & 1));
        v45 = *(&v94 + ((v33 >> 1) & 1));
        v46 = *(&v92 + ((v33 >> 2) & 1));
        v47 = *(&v92 + ((v33 >> 3) & 1));
        v48 = *(&v90 + ((v33 >> 4) & 1));
        v81 = (unsigned int)(v44 + v45) >> 1;
        v84 = (unsigned int)(v47 + v46) >> 1;
        v64 = *(&v90 + ((v33 >> 5) & 1));
        v89 = (unsigned int)(v64 + v48) >> 1;
        v49 = 0;
        v50 = v99;
        v86 = v45;
        v73 = v46;
        v61 = v47;
        v78 = v48;
        v58 = 0;
        v75 = v99;
        v70 = 16;
        while ( 2 )
        {
          if ( *(int *)(v50 - 1) >= 0 )
          {
            v49 = (4 * v49) | 3;
            goto LABEL_82;
          }
          v51 = -(unsigned __int8)*(_DWORD *)(v50 - 1);
          v52 = -v50[1];
          v53 = -*v50;
          v54 = dword_10047650[((_WORD)v53 + v73) & 0x1FF]
              + dword_10047650[((_WORD)v52 + (_WORD)v44) & 0x1FF]
              + dword_10047650[((_WORD)v51 + (_WORD)v48) & 0x1FF];
          v55 = dword_10047650[((_WORD)v53 + v61) & 0x1FF]
              + dword_10047650[((_WORD)v52 + (_WORD)v45) & 0x1FF]
              + dword_10047650[((_WORD)v51 + (_WORD)v64) & 0x1FF];
          v56 = dword_10047650[((_WORD)v84 + (_WORD)v53) & 0x1FF]
              + dword_10047650[((_WORD)v52 + (_WORD)v81) & 0x1FF]
              + dword_10047650[((_WORD)v89 + (_WORD)v51) & 0x1FF];
          if ( v55 < v54 )
            goto LABEL_78;
          if ( v54 <= v56 )
          {
            v49 = 4 * v58;
LABEL_81:
            LOWORD(v45) = v86;
LABEL_82:
            v50 = v75 + 4;
            v10 = v70-- == 1;
            LOWORD(v48) = v78;
            v58 = v49;
            v75 += 4;
            if ( v10 )
            {
              *(_WORD *)a1 = v78 | (32 * (v73 | ((_WORD)v44 << 6)));
              *(_WORD *)(a1 + 2) = v64 | (32 * (v61 | ((_WORD)v45 << 6)));
              *(_DWORD *)(a1 + 4) = v49;
              return v67 + v68;
            }
            continue;
          }
          break;
        }
        if ( v55 <= v54 )
        {
LABEL_78:
          if ( v55 <= v56 )
          {
            v49 = (4 * v58) | 1;
            goto LABEL_81;
          }
        }
        v49 = (4 * v58) | 2;
        goto LABEL_81;
      }
      LOWORD(v35) = v87;
      LOWORD(v37) = v72;
      LOWORD(v38) = v77;
    }
  }
  LOWORD(v17) = v97;
  v18 = v96;
  if ( v96 > v97 )
  {
    v18 = v97;
    v17 = v96;
    v96 = v97;
    v97 = v17;
  }
  v71 = HIBYTE(v18);
  v19 = (unsigned __int8)v18;
  v76 = (unsigned __int8)v18;
  v20 = BYTE1(v17);
  v62 = (unsigned __int8)v17;
  v21 = 0;
  v22 = 0;
  v57 = 0;
  v66 = 0;
  v59 = v20;
  do
  {
    v23 = *(_DWORD *)&v98[4 * v22 + 64];
    if ( v23 < 0 )
    {
      v19 = v76;
      v21 = 4 * v57;
      v24 = dword_10047650[(BYTE2(v96) - (unsigned __int16)(unsigned __int8)v99[4 * v22 + 1]) & 0x1FF]
          + dword_10047650[(v76 - (unsigned __int8)v23) & 0x1FF]
          + dword_10047650[(v71 - (unsigned __int8)v99[4 * v22]) & 0x1FF] <= (unsigned int)(dword_10047650[(BYTE2(v97) - (unsigned __int16)(unsigned __int8)v99[4 * v22 + 1]) & 0x1FF]
                                                                                          + dword_10047650[(v62 - (unsigned __int8)v23) & 0x1FF]
                                                                                          + dword_10047650[(v59 - (unsigned __int8)v99[4 * v22]) & 0x1FF]);
      v22 = v66;
      if ( !v24 )
        v21 |= 1u;
    }
    else
    {
      v21 = (4 * v21) | 3;
    }
    ++v22;
    v57 = v21;
    v66 = v22;
  }
  while ( v22 < 0x10 );
  v25 = v19 | (32 * (v71 | (BYTE2(v96) << 6)));
  *(_WORD *)(a1 + 2) = v62 | (32 * (v59 | (BYTE2(v97) << 6)));
  *(_WORD *)a1 = v25;
  *(_DWORD *)(a1 + 4) = v21;
  return v68;
}
// 10020181: conditional instruction was optimized away because edi.4>=3u
// 100202FB: conditional instruction was optimized away because edi.4>=3u
// 10047650: using guessed type int dword_10047650[512];

//----- (10020670) --------------------------------------------------------
unsigned int __cdecl sub_10020670(int a1, int a2, int a3)
{
  unsigned int v3; // esi
  unsigned int v4; // ebx
  int i; // edi
  unsigned __int8 v6; // cl
  int v7; // eax
  bool v8; // sf
  unsigned __int8 v10; // si
  unsigned __int8 v11; // al
  unsigned __int8 v12; // di
  unsigned int v13; // edx
  unsigned int v14; // ecx
  unsigned int v15; // eax
  unsigned int v16; // ecx
  unsigned int v17; // ebp
  unsigned int v18; // edi
  unsigned int v19; // esi
  unsigned int v20; // eax
  unsigned int v21; // edx
  unsigned int v22; // edx
  __int16 v23; // ax
  unsigned int v24; // ebx
  unsigned int v25; // eax
  unsigned int v26; // edi
  unsigned int v27; // esi
  unsigned int v28; // ecx
  unsigned int v29; // ebp
  unsigned int v30; // edx
  unsigned int v31; // eax
  unsigned int v32; // esi
  unsigned int v33; // eax
  unsigned int v34; // ecx
  unsigned int v35; // ecx
  unsigned int v36; // ebx
  unsigned int v37; // ecx
  unsigned int v38; // ebp
  unsigned int v39; // edi
  unsigned int v40; // edx
  unsigned int v41; // esi
  unsigned int v42; // eax
  int v43; // eax
  int v44; // eax
  unsigned int v45; // edi
  unsigned int v46; // esi
  unsigned int v47; // ebp
  unsigned int v48; // eax
  int v49; // eax
  unsigned int v50; // [esp+10h] [ebp-68h]
  unsigned int v51; // [esp+10h] [ebp-68h]
  int v52; // [esp+14h] [ebp-64h]
  unsigned int v53; // [esp+14h] [ebp-64h]
  unsigned int v54; // [esp+18h] [ebp-60h]
  unsigned int v55; // [esp+1Ch] [ebp-5Ch]
  unsigned int v56; // [esp+20h] [ebp-58h]
  int v57; // [esp+24h] [ebp-54h]
  int v58; // [esp+28h] [ebp-50h]
  int v59; // [esp+2Ch] [ebp-4Ch]
  int v60; // [esp+2Ch] [ebp-4Ch]
  unsigned int v61; // [esp+30h] [ebp-48h]
  unsigned int v62; // [esp+30h] [ebp-48h]
  __int16 v63; // [esp+34h] [ebp-44h]
  char v64[15]; // [esp+38h] [ebp-40h] BYREF
  unsigned __int8 v65; // [esp+39h] [ebp-3Fh]
  _BYTE v66[4]; // [esp+48h] [ebp-30h] BYREF
  unsigned int v67; // [esp+4Ch] [ebp-2Ch]
  unsigned int v68; // [esp+50h] [ebp-28h]
  unsigned int v69; // [esp+54h] [ebp-24h]
  unsigned int v70; // [esp+58h] [ebp-20h]
  unsigned int v71; // [esp+5Ch] [ebp-1Ch]
  unsigned int v72; // [esp+60h] [ebp-18h]
  unsigned int v73; // [esp+64h] [ebp-14h]
  _BYTE v74[16]; // [esp+68h] [ebp-10h] BYREF
  unsigned int j; // [esp+80h] [ebp+8h]
  int v76; // [esp+80h] [ebp+8h]
  unsigned int v77; // [esp+80h] [ebp+8h]
  unsigned int v78; // [esp+80h] [ebp+8h]
  unsigned int v79; // [esp+84h] [ebp+Ch]

  v3 = 0;
  v4 = 255;
  v56 = 0;
  v61 = 255;
  v54 = 0;
  v64[0] = 0;
  v52 = 12;
  do
  {
    for ( i = 3; i >= 0; --i )
    {
      v6 = *(_BYTE *)(a2 + 4 * (i ^ 3));
      LOBYTE(v63) = v6;
      v74[v52 + i] = v6;
      if ( v6 < v4 )
        v4 = v6;
      if ( v6 > v56 )
        v56 = v6;
      if ( v6 > 1u && v6 < v61 )
        v61 = v6;
      if ( v6 < 0xFEu && v6 > v54 )
        v54 = v6;
      v7 = 0;
      if ( v3 )
      {
        while ( v6 != v64[v7] )
        {
          if ( ++v7 >= v3 )
            goto LABEL_16;
        }
        ++v66[v7];
      }
      else
      {
LABEL_16:
        v66[v3] = 1;
        v66[v3 + v64 - v66] = v6;
        ++v3;
      }
    }
    v8 = v52 - 4 < 0;
    a2 += a3;
    v52 -= 4;
  }
  while ( !v8 );
  v53 = v3;
  if ( v3 <= 1 )
  {
    *(_BYTE *)a1 = v64[0];
    *(_BYTE *)(a1 + 1) = 0;
    *(_WORD *)(a1 + 2) = 0;
    *(_WORD *)(a1 + 4) = 0;
    *(_WORD *)(a1 + 6) = 0;
    return 0;
  }
  if ( v3 == 2 )
  {
    v10 = v65;
    v11 = v65;
    v12 = v64[0];
    *(_BYTE *)a1 = v64[0];
    v13 = 0;
    v14 = 0;
    *(_BYTE *)(a1 + 1) = v11;
    do
    {
      v13 *= 8;
      if ( dword_10047650[(v12 - (unsigned __int16)(unsigned __int8)v74[v14]) & 0x1FF] > (unsigned int)dword_10047650[(v10 - (unsigned __int16)(unsigned __int8)v74[v14]) & 0x1FF] )
        v13 |= 1u;
      if ( v14 == 7 )
      {
        *(_BYTE *)(a1 + 5) = v13;
        *(_WORD *)(a1 + 6) = v13 >> 8;
      }
      ++v14;
    }
    while ( v14 < 0x10 );
    *(_WORD *)(a1 + 2) = v13;
    *(_BYTE *)(a1 + 4) = BYTE2(v13);
    return 0;
  }
  v79 = -1;
  if ( v4 )
  {
    if ( --v4 < 0xFE )
      v15 = v4 + 2;
    else
      v15 = 255;
  }
  else
  {
    v15 = 1;
  }
  v50 = v15;
  if ( v4 > v15 )
    goto LABEL_139;
  v59 = 3 * v4;
  v58 = 5 * v4;
  v57 = 6 * v4;
  do
  {
    v16 = v4 + 4;
    do
    {
      v73 = v16;
      if ( v16 <= 0xFF )
      {
        v67 = (v57 + v16) / 7;
        v69 = (3 * v16 + 4 * v4) / 7;
        v17 = (v59 + 4 * v16) / 7;
        v71 = (5 * v16 + 2 * v4) / 7;
        v68 = (v58 + 2 * v16) / 7;
        v18 = (v4 + 6 * v16) / 7;
        v55 = 0;
        for ( j = 0; j < v53; ++j )
        {
          v19 = (unsigned __int8)v64[j];
          if ( v19 < v17 )
          {
            if ( v19 < v68 )
            {
              v22 = v67;
              if ( v19 < v67 )
              {
                v20 = dword_10047650[((_WORD)v4 - (_WORD)v19) & 0x1FF];
              }
              else
              {
                v20 = v19 - v67;
                v22 = v68;
              }
            }
            else if ( v19 < v69 )
            {
              v20 = v19 - v68;
              v22 = v69;
            }
            else
            {
              v20 = v19 - v69;
              v22 = (v59 + 4 * v16) / 7;
            }
          }
          else
          {
            if ( v19 >= v18 )
            {
              v20 = (unsigned __int8)v64[j] - v18;
              v21 = dword_10047650[((_WORD)v16 - (_WORD)v19) & 0x1FF];
              goto LABEL_54;
            }
            v22 = v71;
            if ( v19 < v71 )
            {
              v20 = v19 - v17;
            }
            else
            {
              v20 = v19 - v71;
              v22 = (v4 + 6 * v16) / 7;
            }
          }
          v21 = v22 - v19;
LABEL_54:
          if ( v20 > v21 )
            v20 = v21;
          v55 += v20;
          if ( v55 >= v79 )
            goto LABEL_60;
        }
        if ( v79 > v55 )
        {
          v23 = v16 | ((_WORD)v4 << 8);
          v79 = v55;
          v63 = v23;
          if ( !v55 )
            goto LABEL_98;
        }
      }
LABEL_60:
      v16 += 4;
    }
    while ( v73 <= v56 );
    ++v4;
    v57 += 6;
    v58 += 5;
    v59 += 3;
  }
  while ( v4 <= v50 );
  if ( v79 )
  {
LABEL_139:
    if ( v61 < v54 )
    {
      v24 = v61 - 1;
      v25 = v61 - 1 < 0xFE ? v24 + 2 : 255;
      v51 = v25;
      if ( v24 <= v25 )
      {
        v60 = 3 * v24;
LABEL_69:
        v26 = v24 + 4;
        while ( 1 )
        {
          v72 = v26;
          if ( v26 <= 0xFF )
          {
            v69 = (v60 + 2 * v26) / 5;
            v27 = 0;
            v28 = (v26 + 4 * v24) / 5;
            v29 = (3 * v26 + 2 * v24) / 5;
            v30 = (v24 + 4 * v26) / 5;
            v68 = v28;
            v62 = 0;
            v76 = 0;
            if ( v53 )
            {
              while ( 1 )
              {
                v31 = (unsigned __int8)v64[v76];
                v32 = v31;
                if ( v31 < v29 )
                {
                  if ( v31 < v28 )
                  {
                    if ( v31 < v24 )
                    {
                      v33 = dword_10047650[-v31 & 0x1FF];
                      v35 = v24;
                    }
                    else
                    {
                      v35 = v68;
                      v33 = v31 - v24;
                    }
                  }
                  else if ( v31 < v69 )
                  {
                    v33 = v31 - v68;
                    v35 = v69;
                  }
                  else
                  {
                    v33 = v31 - v69;
                    v35 = (3 * v26 + 2 * v24) / 5;
                  }
                }
                else
                {
                  if ( v31 >= v26 )
                  {
                    v33 = v31 - v26;
                    v34 = dword_10047650[(255 - (_WORD)v32) & 0x1FF];
                    goto LABEL_88;
                  }
                  if ( v31 < v30 )
                  {
                    v33 = v31 - v29;
                    v35 = (v24 + 4 * v26) / 5;
                  }
                  else
                  {
                    v33 = v31 - v30;
                    v35 = v26;
                  }
                }
                v34 = v35 - v32;
LABEL_88:
                if ( v33 > v34 )
                  v33 = v34;
                v62 += v33;
                if ( v62 >= v79 )
                  goto LABEL_95;
                if ( ++v76 >= v53 )
                {
                  v27 = v62;
                  break;
                }
                v28 = v68;
              }
            }
            if ( v79 > v27 )
            {
              v79 = v27;
              v63 = v24 | ((_WORD)v26 << 8);
              if ( !v27 )
                break;
            }
          }
LABEL_95:
          v26 += 4;
          if ( v72 > v54 )
          {
            ++v24;
            v60 += 3;
            if ( v24 <= v51 )
              goto LABEL_69;
            break;
          }
        }
      }
    }
  }
  v23 = v63;
LABEL_98:
  v36 = HIBYTE(v23);
  v37 = (unsigned __int8)v23;
  *(_WORD *)a1 = v23;
  if ( (unsigned __int8)v23 < (unsigned int)HIBYTE(v23) )
  {
    v68 = (HIBYTE(v23) + 4 * (unsigned int)(unsigned __int8)v23) / 5;
    v45 = (3 * (unsigned __int8)v23 + 2 * (unsigned int)HIBYTE(v23)) / 5;
    v71 = ((unsigned __int8)v23 + 4 * (unsigned int)HIBYTE(v23)) / 5;
    v46 = (3 * HIBYTE(v23) + 2 * (unsigned int)(unsigned __int8)v23) / 5;
    v40 = 0;
    v47 = 0;
    v69 = v45;
    v78 = 0;
    while ( 1 )
    {
      v48 = (unsigned __int8)v74[v47];
      if ( v48 >= v46 )
      {
        if ( v48 < v36 )
        {
          if ( v48 < v71 )
            v49 = (v71 - v48 < -v46) + 4;
          else
            v49 = v36 - v48 < -v71 ? 1 : 5;
        }
        else
        {
          v49 = dword_10047650[(255 - (_WORD)v48) & 0x1FF] < v48 - v36 ? 7 : 1;
        }
        goto LABEL_133;
      }
      if ( v48 < v68 )
      {
        if ( v48 < v37 )
        {
          v49 = v37 - v48 < dword_10047650[-v48 & 0x1FF] ? 0 : 6;
          goto LABEL_132;
        }
        v49 = v68 - v48 < v48 - v37 ? 2 : 0;
      }
      else
      {
        if ( v48 < v45 )
        {
          v49 = (v45 - v48 < v48 - v68) + 2;
LABEL_132:
          v45 = v69;
          goto LABEL_133;
        }
        v49 = (v46 - v48 < v48 - v45) + 3;
      }
LABEL_133:
      v40 = v49 | (8 * v40);
      v44 = a1;
      if ( v78 == 7 )
      {
        *(_BYTE *)(a1 + 5) = v40;
        *(_WORD *)(a1 + 6) = v40 >> 8;
      }
      v47 = ++v78;
      if ( v78 >= 0x10 )
        goto LABEL_136;
    }
  }
  v38 = (HIBYTE(v23) + 6 * (unsigned int)(unsigned __int8)v23) / 7;
  v70 = (3 * HIBYTE(v23) + 4 * (unsigned int)(unsigned __int8)v23) / 7;
  v69 = (5 * (unsigned __int8)v23 + 2 * (unsigned int)HIBYTE(v23)) / 7;
  v39 = (3 * (unsigned __int8)v23 + 4 * (unsigned int)HIBYTE(v23)) / 7;
  v72 = (5 * HIBYTE(v23) + 2 * (unsigned int)(unsigned __int8)v23) / 7;
  v73 = ((unsigned __int8)v23 + 6 * (unsigned int)HIBYTE(v23)) / 7;
  v40 = 0;
  v41 = 0;
  v71 = v39;
  v77 = 0;
  while ( 1 )
  {
    v42 = (unsigned __int8)v74[v41];
    if ( v42 < v70 )
    {
      if ( v42 < v72 )
      {
        if ( v42 < v73 )
          v43 = v73 - v42 < dword_10047650[((_WORD)v36 - (_WORD)v42) & 0x1FF] ? 7 : 1;
        else
          v43 = 7 - (v72 - v42 < v42 - v73);
      }
      else if ( v42 < v39 )
      {
        v43 = 6 - (v39 - v42 < v42 - v72);
      }
      else
      {
        v43 = 5 - (v70 - v42 < v42 - v39);
      }
    }
    else if ( v42 < v38 )
    {
      if ( v42 < v69 )
        v43 = 4 - (v69 - v42 < v42 - v70);
      else
        v43 = 3 - (v38 - v42 < v42 - v69);
    }
    else
    {
      v43 = dword_10047650[((_WORD)v37 - (_WORD)v42) & 0x1FF] < v42 - v38 ? 0 : 2;
    }
    v40 = v43 | (8 * v40);
    v44 = a1;
    if ( v77 == 7 )
    {
      *(_BYTE *)(a1 + 5) = v40;
      *(_WORD *)(a1 + 6) = v40 >> 8;
    }
    v41 = v77 + 1;
    v77 = v41;
    if ( v41 >= 0x10 )
      break;
    v39 = v71;
  }
LABEL_136:
  *(_WORD *)(v44 + 2) = v40;
  *(_BYTE *)(v44 + 4) = BYTE2(v40);
  return v79;
}
// 10020A88: conditional instruction was optimized away because %var_48.4 is in (2..FF)
// 10020C35: variable 'v63' is possibly undefined
// 10047650: using guessed type int dword_10047650[512];

//----- (10020F50) --------------------------------------------------------
_BYTE *__cdecl sub_10020F50(int a1, int a2, int a3, int a4, int a5, void *a6)
{
  _BYTE *result; // eax
  int v7; // esi

  if ( *(_DWORD *)(a4 + 4 * a5) == -1 )
    return sub_10019E10(68, (_BYTE *)(a2 + a5 * a1), (int)a6);
  v7 = *(_DWORD *)(a5 * a3 + a4);
  for ( result = (_BYTE *)sub_10001530((int)a6, a2 + a1 * v7, a2 + a5 * a1);
        ;
        result = (_BYTE *)sub_100014D0(a6, a2 + a1 * v7) )
  {
    v7 = *(_DWORD *)(a3 * v7 + a4);
    if ( v7 == -1 )
      break;
  }
  return result;
}

//----- (10020FE0) --------------------------------------------------------
void __cdecl sub_10020FE0(int a1, char *a2, int a3, _DWORD *a4, int a5, int a6, char *a7)
{
  char *v7; // ecx
  char *v9; // edi
  char *v10; // esi
  int i; // edi

  v7 = a7;
  v9 = a2;
  v10 = a7;
  if ( a2 == a7 )
  {
    for ( i = a5; i; --i )
    {
      if ( *a4 != -1 )
      {
        sub_100014D0(v10, (int)&v7[68 * *a4]);
        v7 = a7;
      }
      a4 = (_DWORD *)((char *)a4 + a3);
      v10 += a6;
    }
  }
  else if ( a5 )
  {
    while ( 1 )
    {
      if ( *a4 == -1 )
        sub_10019E10(68, v9, (int)v10);
      else
        sub_10001530((int)v10, (int)&v7[a6 * *a4], (int)v9);
      v9 += a1;
      a4 = (_DWORD *)((char *)a4 + a3);
      v10 += a6;
      if ( !--a5 )
        break;
      v7 = a7;
    }
  }
}

//----- (10021080) --------------------------------------------------------
char __cdecl sub_10021080(int a1, char *a2, int *a3)
{
  int v3; // edx

  if ( !a1 )
    return 0;
  *a3 = 0;
  if ( *(int *)(a1 + 4) <= 0 )
    return 0;
  while ( !sub_10021AC0(a2, *(char **)(156 * *a3 + *(_DWORD *)(a1 + 8))) )
  {
    v3 = *a3 + 1;
    *a3 = v3;
    if ( v3 >= *(_DWORD *)(a1 + 4) )
      return 0;
  }
  return 1;
}

//----- (100210E0) --------------------------------------------------------
int __cdecl sub_100210E0(int a1)
{
  bool v1; // zf
  int result; // eax
  int i; // eax
  int v4; // [esp+4h] [ebp-4h] BYREF

  sub_10019A60(&v4, 16);
  sub_10019BC0(v4, 0, 8, a1, 140);
  sub_10019BC0(v4, 0, 12, a1, 4);
  v1 = sub_10019C60((int)aWPublicGrannyR_38, 65) == 0;
  result = v4;
  if ( !v1 )
  {
    *(_DWORD *)(v4 + 4) = 0;
    for ( i = 0; i < a1; ++i )
      *(_DWORD *)(*(_DWORD *)(v4 + 12) + 4 * i) = -1;
    return v4;
  }
  return result;
}

//----- (10021160) --------------------------------------------------------
_DWORD *__cdecl sub_10021160(int a1, int a2)
{
  _DWORD *result; // eax
  int v3; // eax
  int v4; // eax

  result = 0;
  if ( a1 )
  {
    v3 = sub_100211A0(a1);
    v4 = off_10033620((int)aWPublicGrannyR_38, 95, 4, v3);
    return sub_100211F0(a1, v4, a2);
  }
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (100211A0) --------------------------------------------------------
int __cdecl sub_100211A0(int a1)
{
  sub_100211C0(a1, &a1);
  return sub_10019D70();
}

//----- (100211C0) --------------------------------------------------------
int __cdecl sub_100211C0(int a1, int *a2)
{
  sub_10019A60(a2, 12);
  return sub_10019BC0(*a2, 4, 8, *(_DWORD *)(a1 + 4), 156);
}

//----- (100211F0) --------------------------------------------------------
_DWORD *__cdecl sub_100211F0(int a1, int a2, int a3)
{
  int v3; // edi
  int v4; // esi
  _DWORD *result; // eax
  _DWORD *v6; // eax
  int v7; // ebx
  _DWORD *v8; // [esp+8h] [ebp-4h] BYREF

  v3 = a1;
  v4 = 0;
  result = 0;
  v8 = 0;
  if ( a1 )
  {
    sub_100211C0(a1, (int *)&v8);
    if ( sub_10019D50((int)aWPublicGrannyR_38, 210, a2) )
    {
      *v8 = 0;
      v6 = v8;
      a1 = 0;
      if ( (int)v8[1] > 0 )
      {
        v7 = a3;
        do
        {
          sub_10021280(v3, v4, &a1, v6[2], v7);
          v6 = v8;
          ++v4;
        }
        while ( v4 < v8[1] );
      }
    }
    off_10033624((int)aWPublicGrannyR_38, 224, v3);
    return v8;
  }
  return result;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10021280) --------------------------------------------------------
void __cdecl sub_10021280(int a1, int a2, _DWORD *a3, int a4, int a5)
{
  int v5; // eax
  int v6; // ecx
  _DWORD *v7; // eax
  int v8; // edx
  int v9; // eax
  _DWORD *v10; // ebx
  int v11; // edi
  float v12[16]; // [esp+8h] [ebp-40h] BYREF

  v5 = *(_DWORD *)(a1 + 12);
  v6 = *(_DWORD *)(v5 + 4 * a2);
  v7 = (_DWORD *)(v5 + 4 * a2);
  if ( v6 == -2 )
  {
    sub_10017FE0(3, 17, "%s(%d): Circular parenting chain located at bone %d", aWPublicGrannyR_38, 126, a2);
  }
  else if ( v6 == -1 )
  {
    *v7 = -2;
    v8 = *(_DWORD *)(a1 + 8);
    v9 = *(_DWORD *)(140 * a2 + v8);
    v10 = (_DWORD *)(v8 + 140 * a2);
    v11 = -1;
    if ( v9 != -1 )
    {
      sub_10021280(a1, v9, a3, a4, a5);
      v11 = *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * *v10);
    }
    sub_10001B60(&dword_10034020, a4 + 156 * *a3);
    *(_DWORD *)(156 * *a3 + a4 + 4) = v11;
    qmemcpy((void *)(156 * *a3 + a4 + 8), v10 + 1, 0x44u);
    sub_100018D0((int)(v10 + 18), v12);
    sub_100182E0(156 * *a3 + a4 + 76, v12);
    if ( a5 )
      *(_DWORD *)(a5 + 4 * a2) = *a3;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * a2) = (*a3)++;
  }
}
// 10034020: using guessed type _DWORD dword_10034020;

//----- (100213B0) --------------------------------------------------------
void __cdecl sub_100213B0(_DWORD *a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7)
{
  int v7; // eax
  _DWORD *v8; // esi

  v7 = a1[1];
  if ( v7 >= *a1 )
  {
    sub_10017FE0(3, 17, "%s(%d): AddBone called after all allotted bones were already used", aWPublicGrannyR_38, 254);
  }
  else
  {
    a1[1] = v7 + 1;
    v8 = (_DWORD *)(a1[2] + 140 * v7);
    *v8 = -1;
    sub_10001080(v8 + 1, a2, a3, a4);
    sub_10001080(v8 + 18, a5, a6, a7);
  }
}

//----- (10021430) --------------------------------------------------------
void __cdecl sub_10021430(int *a1, int a2, int a3)
{
  if ( a2 >= *a1 )
  {
    sub_10017FE0(
      3,
      17,
      "%s(%d): SetBoneParent bone index (%d) is out of specified bone domain (%d)",
      aWPublicGrannyR_38,
      278,
      a2,
      *a1);
  }
  else if ( a3 >= *a1 )
  {
    sub_10017FE0(
      3,
      17,
      "%s(%d): SetBoneParent parent index (%d) is out of specified bone domain (%d)",
      aWPublicGrannyR_38,
      271,
      a2,
      *a1);
  }
  else
  {
    *(_DWORD *)(140 * a2 + a1[2]) = a3;
  }
}

//----- (100214A0) --------------------------------------------------------
_DWORD *__cdecl sub_100214A0(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  a1[1] = a3;
  a1[2] = 0;
  a1[3] = 0;
  return result;
}

//----- (100214C0) --------------------------------------------------------
_DWORD *__cdecl sub_100214C0(int a1)
{
  return sub_100215D0(a1, *(_DWORD *)(a1 + 8));
}

//----- (100214E0) --------------------------------------------------------
BOOL __cdecl sub_100214E0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // eax

  v2 = (_DWORD *)a1[3];
  if ( !v2 || *v2 == a1[1] )
  {
    v2 = sub_10021540(a1);
    if ( v2 )
    {
      v2[2] = a1[2];
      v2[3] = a1[3];
      a1[3] = v2;
    }
  }
  *a2 = -1;
  if ( v2 )
  {
    ++*(_DWORD *)a1[3];
    *a2 = a1[2]++;
  }
  return *a2 != -1;
}

//----- (10021540) --------------------------------------------------------
_DWORD *__cdecl sub_10021540(_DWORD *a1)
{
  int v1; // esi

  v1 = *a1 * a1[1];
  sub_10019A60(&a1, 16);
  sub_10019B90((int)a1, 4, v1);
  if ( sub_10019C60((int)aWPublicGrannyR_17, 49) )
  {
    *a1 = 0;
    a1[2] = 0;
    a1[3] = 0;
  }
  return a1;
}

//----- (100215A0) --------------------------------------------------------
int __cdecl sub_100215A0(_DWORD *a1, int a2)
{
  _DWORD *i; // ecx

  for ( i = (_DWORD *)a1[3]; i[2] > a2; i = (_DWORD *)i[3] )
    ;
  return i[1] + *a1 * (a2 - i[2]);
}

//----- (100215D0) --------------------------------------------------------
_DWORD *__cdecl sub_100215D0(int a1, int a2)
{
  _DWORD *i; // eax
  _DWORD *result; // eax

  for ( i = *(_DWORD **)(a1 + 12); i; i = *(_DWORD **)(a1 + 12) )
  {
    if ( *i > a2 )
      break;
    *(_DWORD *)(a1 + 8) -= *i;
    a2 -= *i;
    *(_DWORD *)(a1 + 12) = i[3];
    off_10033624((int)aWPublicGrannyR_17, 137, (int)i);
  }
  result = *(_DWORD **)(a1 + 12);
  if ( result )
  {
    *(_DWORD *)(a1 + 8) -= a2;
    *result -= a2;
  }
  return result;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10021620) --------------------------------------------------------
char sub_10021620()
{
  return 1;
}

//----- (10021640) --------------------------------------------------------
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
  if ( fdwReason == 1 )
  {
    DisableThreadLibraryCalls(hinstDLL);
    if ( sub_100216B0(hinstDLL) )
      return (unsigned __int8)sub_10021620();
    else
      return 0;
  }
  else
  {
    if ( !fdwReason )
      nullsub_2();
    return 1;
  }
}
// 10021630: using guessed type int nullsub_2(void);

//----- (100216B0) --------------------------------------------------------
char __cdecl sub_100216B0(HMODULE hModule)
{
  CHAR v1; // al
  CHAR *v2; // esi
  CHAR *i; // ecx
  CHAR Filename[512]; // [esp+8h] [ebp-600h] BYREF
  CHAR Buffer[512]; // [esp+208h] [ebp-400h] BYREF
  CHAR v7[512]; // [esp+408h] [ebp-200h] BYREF

  GetModuleFileNameA(hModule, Filename, 0x200u);
  v1 = Filename[0];
  v2 = Filename;
  for ( i = Filename; v1; ++i )
  {
    if ( v1 == 92 || v1 == 47 )
      LOBYTE(v2) = (_BYTE)i + 1;
    v1 = i[1];
  }
  GetWindowsDirectoryA(Buffer, 0x200u);
  GetSystemDirectoryA(v7, 0x200u);
  if ( !sub_10021A60(Filename, Buffer) && !sub_10021A60(Filename, v7) )
    return 1;
  sub_10022670(0x8000, (int)Text, (int)aSHasBeenIncorr, (char)v2);
  MessageBoxA(0, Text, Caption, 0x10u);
  return 0;
}

//----- (100217A0) --------------------------------------------------------
int GrannyGetCounterCount()
{
  return dword_10056308;
}
// 10056308: using guessed type int dword_10056308;

//----- (100217B0) --------------------------------------------------------
char *__cdecl sub_100217B0(int a1)
{
  return (char *)&unk_10050308 + 48 * a1;
}

//----- (100217C0) --------------------------------------------------------
double sub_100217C0()
{
  LARGE_INTEGER *v0; // eax
  DWORD LowPart; // ecx
  LONG HighPart; // edx
  DWORD v3; // esi
  LONG v4; // eax
  LARGE_INTEGER *v5; // eax
  DWORD v6; // ecx
  LONG v7; // edx
  DWORD v8; // esi
  double v9; // st7
  double result; // st7
  LARGE_INTEGER v11[2]; // [esp+0h] [ebp-48h] BYREF
  __int64 v12; // [esp+10h] [ebp-38h]
  unsigned __int64 v13; // [esp+18h] [ebp-30h] BYREF
  DWORD v14; // [esp+20h] [ebp-28h]
  LONG v15; // [esp+24h] [ebp-24h]
  unsigned __int64 v16; // [esp+28h] [ebp-20h] BYREF
  DWORD v17; // [esp+30h] [ebp-18h]
  LONG v18; // [esp+34h] [ebp-14h]
  LARGE_INTEGER v19[2]; // [esp+38h] [ebp-10h] BYREF

  if ( dbl_10056310 != 0.0 )
    return dbl_10056310;
  *(double *)&v12 = COERCE_DOUBLE(__rdtsc());
  v0 = sub_10022A60(v11);
  LowPart = v0->LowPart;
  HighPart = v0->HighPart;
  v3 = v0[1].LowPart;
  v4 = v0[1].HighPart;
  v16 = __PAIR64__(HighPart, LowPart);
  v17 = v3;
  v18 = v4;
  sub_10022B20(1.0);
  v11[0].QuadPart = __rdtsc();
  v5 = sub_10022A60(v19);
  v6 = v5->LowPart;
  v7 = v5->HighPart;
  v8 = v5[1].LowPart;
  v15 = v5[1].HighPart;
  v14 = v8;
  v12 = v11[0].QuadPart - v12;
  v13 = __PAIR64__(v7, v6);
  *(double *)&v12 = (double)v12;
  v9 = sub_10022AA0(&v16, &v13);
  result = *(double *)&v12 / v9;
  dbl_10056310 = result;
  return result;
}
// 10056310: using guessed type double dbl_10056310;

//----- (100218A0) --------------------------------------------------------
_DWORD *__cdecl sub_100218A0(int a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)((char *)&unk_10050308 + 48 * dword_10056308++);
  *result = a1;
  return result;
}
// 10056308: using guessed type int dword_10056308;

//----- (100218C0) --------------------------------------------------------
void GrannyResetCounters()
{
  unsigned int *v0; // eax
  int v1; // edi
  int v2; // ecx
  unsigned int v3; // edx
  unsigned int v4; // ecx
  signed __int64 v5; // kr00_8

  if ( dword_10056308 > 0 )
  {
    v0 = (unsigned int *)&unk_10050328;
    v1 = dword_10056308;
    do
    {
      v2 = *(v0 - 7);
      if ( (int)*(v0 - 2) < v2 )
        *(v0 - 2) = v2;
      v3 = *(v0 - 5);
      v4 = *(v0 - 6);
      if ( *(_QWORD *)v0 < __SPAIR64__(v3, v4) )
      {
        *v0 = v4;
        v0[1] = v3;
      }
      v5 = __PAIR64__(v3, v4) - *((_QWORD *)v0 - 2);
      if ( *((_QWORD *)v0 + 1) < v5 )
        *((_QWORD *)v0 + 1) = v5;
      *(v0 - 7) = 0;
      *(v0 - 6) = 0;
      *(v0 - 5) = 0;
      *(v0 - 4) = 0;
      *(v0 - 3) = 0;
      v0 += 12;
      --v1;
    }
    while ( v1 );
  }
}
// 10056308: using guessed type int dword_10056308;

//----- (10021930) --------------------------------------------------------
_DWORD *__usercall GrannyResetCounterPeaks@<eax>(_DWORD *result@<eax>)
{
  int v1; // edx

  v1 = dword_10056308;
  if ( dword_10056308 > 0 )
  {
    result = &unk_10050328;
    do
    {
      *(result - 2) = 0;
      *result = 0;
      result[1] = 0;
      result[2] = 0;
      result[3] = 0;
      result += 12;
      --v1;
    }
    while ( v1 );
  }
  return result;
}
// 10056308: using guessed type int dword_10056308;

//----- (10021960) --------------------------------------------------------
void __cdecl sub_10021960(int a1, int a2)
{
  char *v2; // esi
  __int64 v3; // kr00_8
  double v4; // [esp+8h] [ebp-8h]
  double v5; // [esp+8h] [ebp-8h]
  double v6; // [esp+8h] [ebp-8h]

  v2 = sub_100217B0(a1);
  *(_DWORD *)a2 = *(_DWORD *)v2;
  *(_DWORD *)(a2 + 4) = *((_DWORD *)v2 + 1);
  v4 = (double)*((__int64 *)v2 + 1);
  *(double *)(a2 + 8) = v4 / sub_100217C0();
  v3 = *((_QWORD *)v2 + 1) - *((_QWORD *)v2 + 2);
  *(double *)(a2 + 16) = (double)v3 / sub_100217C0();
  *(_DWORD *)(a2 + 24) = *((_DWORD *)v2 + 6);
  v5 = (double)*((__int64 *)v2 + 4);
  *(double *)(a2 + 32) = v5 / sub_100217C0();
  v6 = (double)*((__int64 *)v2 + 5);
  *(double *)(a2 + 40) = v6 / sub_100217C0();
}

//----- (10021A00) --------------------------------------------------------
int __cdecl sub_10021A00(_BYTE *a1)
{
  _BYTE *v1; // ecx
  int result; // eax
  char v3; // dl

  v1 = a1;
  result = 0;
  if ( a1 && *a1 )
  {
    do
    {
      v3 = *++v1;
      ++result;
    }
    while ( v3 );
  }
  return result;
}

//----- (10021A20) --------------------------------------------------------
BOOL __cdecl sub_10021A20(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // ecx
  _BYTE *v3; // esi
  char i; // al

  v2 = a1;
  v3 = a2;
  if ( !a1 || !a2 )
    return a1 == a2;
  for ( i = *a1; i; ++v3 )
  {
    if ( !*v3 )
      break;
    if ( i != *v3 )
      break;
    i = *++v2;
  }
  return *v3 == *v2;
}

//----- (10021A60) --------------------------------------------------------
BOOL __cdecl sub_10021A60(char *a1, char *a2)
{
  char *v2; // esi
  char *v3; // edi
  char i; // al
  char v5; // bl

  v2 = a2;
  v3 = a1;
  if ( !a1 || !a2 )
    return a1 == a2;
  for ( i = *a1; i; ++v2 )
  {
    if ( !*v2 )
      break;
    v5 = sub_10021DA0(i);
    if ( v5 != sub_10021DA0(*v2) )
      break;
    i = *++v3;
  }
  return *v2 == 0;
}

//----- (10021AC0) --------------------------------------------------------
BOOL __cdecl sub_10021AC0(char *a1, char *a2)
{
  char *v2; // esi
  char *v3; // edi
  char i; // al
  char v5; // bl

  v2 = a1;
  v3 = a2;
  if ( !a1 || !a2 )
    return a1 == a2;
  for ( i = *a1; i; ++v3 )
  {
    if ( !*v3 )
      break;
    v5 = sub_10021DA0(i);
    if ( v5 != sub_10021DA0(*v3) )
      break;
    i = *++v2;
  }
  return *v3 == *v2;
}

//----- (10021B20) --------------------------------------------------------
void __cdecl sub_10021B20(_BYTE *a1, int a2, _BYTE *a3)
{
  _BYTE *v3; // edx
  _BYTE *v4; // ecx
  char v5; // al
  int v6; // esi
  int v7; // edi
  int v8; // eax

  v3 = a1;
  v4 = a3;
  if ( a1 && a3 && (v5 = *a3) != 0 )
  {
    v6 = a2;
    do
    {
      v7 = v6--;
      if ( v7 <= 1 )
        break;
      *v3 = v5;
      v5 = v4[1];
      ++v3;
      ++v4;
    }
    while ( v5 );
  }
  else
  {
    v6 = a2;
  }
  *v3 = 0;
  if ( v6 == 1 )
  {
    if ( *v4 )
    {
      v8 = sub_10021A00(v4);
      sub_10017FE0(
        2,
        12,
        "%s(%d): String overflow in StringEquals (Source is %d characters, but dest can only hold %d)",
        aWPublicGrannyR_22,
        200,
        v8,
        1);
    }
  }
}

//----- (10021B90) --------------------------------------------------------
int __cdecl sub_10021B90(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // edx
  _BYTE *v3; // esi
  bool v4; // zf
  int result; // eax
  char v6; // cl

  v2 = a2;
  v3 = a1;
  v4 = *a1 == 0;
  result = 1;
  *a2 = *a1;
  if ( !v4 )
  {
    do
    {
      v6 = v3[1];
      ++v2;
      ++v3;
      ++result;
      *v2 = v6;
    }
    while ( v6 );
  }
  return result;
}

//----- (10021BC0) --------------------------------------------------------
int __usercall sub_10021BC0@<eax>(double a1@<st0>, char *a2)
{
  sub_10021C20(a2, 0);
  return (int)(float)a1;
}

//----- (10021BF0) --------------------------------------------------------
int __cdecl sub_10021BF0(char *a1)
{
  return (int)sub_10021C40(a1, 0);
}

//----- (10021C20) --------------------------------------------------------
void __cdecl sub_10021C20(char *a1, char a2)
{
  sub_10021C40(a1, a2);
}

//----- (10021C40) --------------------------------------------------------
double __cdecl sub_10021C40(char *a1, char a2)
{
  char *v2; // esi
  char v3; // bl
  double v6; // [esp+10h] [ebp-18h]
  double v7; // [esp+18h] [ebp-10h]
  double v8; // [esp+20h] [ebp-8h]

  v2 = a1;
  v8 = 1.0;
  if ( *a1 == 45 )
  {
    v8 = -1.0;
  }
  else if ( *a1 != 43 )
  {
    goto LABEL_5;
  }
  v2 = a1 + 1;
LABEL_5:
  v3 = 0;
  v6 = 1.0;
  v7 = 0.0;
  if ( *v2 )
  {
    do
    {
      if ( sub_10021D60(*v2) )
      {
        if ( v3 )
        {
          v7 = (double)(unsigned __int8)sub_10021D80(*v2) * v6 + v7;
          v6 = v6 * 0.1;
        }
        else
        {
          v7 = (double)(unsigned __int8)sub_10021D80(*v2) + v7 * 10.0;
        }
      }
      else
      {
        if ( v3 || *v2 != 46 || !a2 )
          return v7 * v8;
        v3 = 1;
        v6 = 0.1;
      }
    }
    while ( *++v2 );
  }
  return v7 * v8;
}

//----- (10021D60) --------------------------------------------------------
BOOL __cdecl sub_10021D60(char a1)
{
  return (byte_10034410[a1] & 0x40) == 64;
}

//----- (10021D80) --------------------------------------------------------
char __cdecl sub_10021D80(char a1)
{
  if ( a1 < 48 || a1 > 57 )
    return 0;
  else
    return a1 - 48;
}

//----- (10021DA0) --------------------------------------------------------
char __cdecl sub_10021DA0(char a1)
{
  char result; // al

  result = a1;
  if ( a1 >= 65 && a1 <= 90 )
    return a1 + 32;
  return result;
}

//----- (10021DC0) --------------------------------------------------------
int sub_10021DC0()
{
  int result; // eax

  result = 2139095040;
  dword_10056320 = 2139095040;
  return result;
}
// 10056320: using guessed type int dword_10056320;

//----- (10021DE0) --------------------------------------------------------
int sub_10021DE0()
{
  int result; // eax

  result = -4194304;
  dword_10056324 = -4194304;
  return result;
}
// 10056324: using guessed type int dword_10056324;

//----- (10021E00) --------------------------------------------------------
int sub_10021E00()
{
  int result; // eax

  result = -8388608;
  dword_10056338 = -8388608;
  return result;
}
// 10056338: using guessed type int dword_10056338;

//----- (10021E20) --------------------------------------------------------
int sub_10021E20()
{
  int result; // eax

  result = 0;
  dbl_10056330 = INFINITY;
  return result;
}
// 10056330: using guessed type double dbl_10056330;

//----- (10021E50) --------------------------------------------------------
int sub_10021E50()
{
  int result; // eax

  result = 0;
  dbl_10056328 = NAN;
  return result;
}
// 10056328: using guessed type double dbl_10056328;

//----- (10021E80) --------------------------------------------------------
int sub_10021E80()
{
  int result; // eax

  result = 0;
  dbl_10056318 = -INFINITY;
  return result;
}
// 10056318: using guessed type double dbl_10056318;

//----- (10021EA0) --------------------------------------------------------
int __cdecl sub_10021EA0(unsigned int a1, _BYTE *a2, char a3)
{
  int result; // eax

  result = 0;
  if ( a1 > 1 )
  {
    *a2 = a3;
    return 1;
  }
  return result;
}

//----- (10021EC0) --------------------------------------------------------
int __cdecl sub_10021EC0(unsigned int a1, _BYTE *a2, int a3, unsigned int a4, char *a5)
{
  unsigned int v5; // edx
  int v6; // esi
  int v7; // edx

  v5 = a3;
  v6 = 0;
  if ( a3 < 0 )
  {
    v6 = sub_10021EA0(a1, a2, 45);
    v5 = -v7;
  }
  return v6 + sub_10021F10(a1 - v6, &a2[v6], v5, a4, a5);
}
// 10021EE3: variable 'v7' is possibly undefined

//----- (10021F10) --------------------------------------------------------
int __cdecl sub_10021F10(unsigned int a1, char *a2, unsigned int a3, unsigned int a4, char *a5)
{
  unsigned int v5; // eax
  int v6; // esi
  int v7; // edi
  char *v8; // eax
  char *i; // ecx
  char v10; // dl

  v5 = a3;
  v6 = 0;
  if ( !a3 )
    return sub_10021EA0(a1, a2, *a5);
  do
  {
    v7 = v5 / a4;
    v6 += sub_10021EA0(a1 - v6, &a2[v6], a5[(unsigned __int8)(v5 % a4)]);
    v5 = v7;
  }
  while ( v7 );
  if ( v6 )
  {
    v8 = &a2[v6 - 1];
    for ( i = a2; i < v8; --v8 )
    {
      v10 = *v8;
      *v8 = *i;
      *i++ = v10;
    }
  }
  return v6;
}
// 10021F1C: conditional instruction was optimized away because %arg_8.4!=0

//----- (10021FA0) --------------------------------------------------------
int __usercall sub_10021FA0@<eax>(char a1@<dil>, int a2, _BYTE *a3, double a4, double a5, int a6, char *a7)
{
  double v8; // st7
  int v9; // edx
  char *v10; // ebx
  int v11; // eax
  int v12; // edx
  char v14; // c0
  char *v15; // ecx
  char *v16; // eax
  int v17; // eax
  int v18; // edx
  double v19; // st7
  int v20; // eax
  int v21; // edx
  int v22; // edx
  int v23; // eax
  int v24; // edx
  char v25; // [esp+3h] [ebp-39h]
  int v26; // [esp+4h] [ebp-38h]
  float v27; // [esp+8h] [ebp-34h]
  float v28; // [esp+Ch] [ebp-30h]
  float v29; // [esp+Ch] [ebp-30h]
  float v30; // [esp+10h] [ebp-2Ch]
  char *v31; // [esp+14h] [ebp-28h]
  float v32; // [esp+18h] [ebp-24h]
  float v33; // [esp+1Ch] [ebp-20h]
  float v34; // [esp+1Ch] [ebp-20h]
  float v35; // [esp+20h] [ebp-1Ch]
  float v36; // [esp+24h] [ebp-18h]
  float v37; // [esp+24h] [ebp-18h]
  float v38; // [esp+28h] [ebp-14h]
  double v39; // [esp+2Ch] [ebp-10h]
  double v40; // [esp+2Ch] [ebp-10h]
  double v41; // [esp+34h] [ebp-8h]

  if ( a4 == dbl_10056330 )
    return sub_10022670(a2, (int)a3, (int)aInfinity, a1);
  if ( a4 == dbl_10056328 )
    return sub_10022670(a2, (int)a3, (int)aQnan, a1);
  if ( a4 == dbl_10056318 )
    return sub_10022670(a2, (int)a3, (int)aSnan, a1);
  v8 = a4;
  v39 = a4;
  v9 = 0;
  if ( a4 < 0.0 )
  {
    v8 = -a4;
    v39 = -a4;
    v9 = sub_10021EA0(a2, a3, 45);
  }
  v10 = a7;
  if ( v8 < 1.0 )
  {
    v17 = sub_10021EA0(a2 - v9, &a3[v9], *a7);
    v9 = v17 + v18;
  }
  else
  {
    v27 = a5;
    v31 = &a3[v9];
    v41 = 1.0 / a5;
    do
    {
      v28 = v8;
      v32 = 1.0 / v27;
      v33 = v32 * v28;
      v35 = v28 - (double)(int)v33 * v27;
      v11 = sub_10021EA0(a2 - v9, &a3[v9], a7[(unsigned __int8)(int)v35]);
      v8 = v41 * v39;
      v9 = v11 + v12;
      v39 = v41 * v39;
    }
    while ( !v14 );
    v15 = v31;
    v16 = &a3[v9 - 1];
    if ( v31 < v16 )
    {
      do
      {
        v25 = *v16;
        *v16 = *v15;
        *v15++ = v25;
        --v16;
      }
      while ( v15 < v16 );
      v10 = a7;
    }
  }
  v34 = a4;
  v19 = v34 - (double)(int)v34;
  if ( v19 < 0.0 )
    v19 = -v19;
  v20 = sub_10021EA0(a2 - v9, &a3[v9], 46);
  v22 = v20 + v21;
  if ( !a6 )
    return v22;
  v26 = a6;
  v30 = a5;
  while ( 1 )
  {
    v40 = v19 * a5;
    v29 = v40;
    v38 = 1.0 / v30;
    v36 = v38 * v29;
    v37 = v29 - (double)(int)v36 * v30;
    v23 = sub_10021EA0(a2 - v22, &a3[v22], v10[(unsigned __int8)(int)v37]);
    v22 = v23 + v24;
    if ( !--v26 )
      break;
    v19 = v40;
  }
  return v22;
}
// 10021FA0: could not find valid save-restore pair for edi
// 10022135: variable 'v12' is possibly undefined
// 10022149: variable 'v14' is possibly undefined
// 10022194: variable 'v18' is possibly undefined
// 100221EB: variable 'v21' is possibly undefined
// 100222AF: variable 'v24' is possibly undefined
// 10056318: using guessed type double dbl_10056318;
// 10056328: using guessed type double dbl_10056328;
// 10056330: using guessed type double dbl_10056330;

//----- (100222E0) --------------------------------------------------------
unsigned int __cdecl sub_100222E0(unsigned int a1, int a2, char *a3, char **a4)
{
  int v4; // ebp
  char *v5; // edi
  unsigned int v6; // esi
  char *v7; // ecx
  int v8; // eax
  char v9; // dl
  char v10; // dl
  char v11; // al
  int v12; // eax
  int v13; // eax
  unsigned int v14; // eax
  unsigned int v15; // eax
  unsigned int v16; // eax
  double v17; // st7
  char *v18; // edx
  char v19; // al
  char *v20; // edx
  int v21; // ecx
  char **v22; // edi
  char *v23; // eax
  char v24; // al
  char *v25; // edx
  char v26; // al
  unsigned int v28; // [esp-8h] [ebp-20h]
  char *v29; // [esp-4h] [ebp-1Ch]
  int v30; // [esp+10h] [ebp-8h]
  int v31; // [esp+24h] [ebp+Ch]
  int v32; // [esp+24h] [ebp+Ch]
  char *v33; // [esp+28h] [ebp+10h]
  char *v34; // [esp+28h] [ebp+10h]

  v4 = a2;
  v5 = *a4;
  v6 = 0;
  v7 = a3;
  v33 = a3;
  if ( *a3 )
  {
    do
    {
      if ( v6 >= a1 )
        break;
      if ( *v7 == 37 )
      {
        v31 = 6;
        while ( 2 )
        {
          v7 = v33 + 1;
          v8 = *++v33 - 32;
          switch ( v8 )
          {
            case 0:
            case 3:
            case 11:
            case 13:
            case 16:
              continue;
            case 10:
              v5 += 4;
              continue;
            case 14:
              v34 = v7 + 1;
              v31 = sub_10021BF0(v7 + 1);
              if ( sub_10021D60(*v34) )
              {
                do
                  v9 = *++v34;
                while ( sub_10021D60(v9) );
              }
              v4 = a2;
              v33 = v34 - 1;
              continue;
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
              sub_10021BF0(v7);
              if ( sub_10021D60(*v33) )
              {
                do
                  v10 = *++v33;
                while ( sub_10021D60(v10) );
              }
              v4 = a2;
              --v33;
              continue;
            case 35:
            case 37:
            case 39:
            case 51:
            case 69:
            case 71:
              goto LABEL_35;
            case 56:
              v29 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
              v28 = 16;
              goto LABEL_19;
            case 67:
              v11 = *v5;
              v5 += 4;
              v12 = sub_10021EA0(a1 - v6, (_BYTE *)(v6 + v4), v11);
              goto LABEL_34;
            case 68:
            case 73:
              v13 = *(_DWORD *)v5;
              v5 += 4;
              v12 = sub_10021EC0(a1 - v6, (_BYTE *)(v6 + v4), v13, 0xAu, "0123456789abcdefghijklmnopqrstuvwxyz");
              goto LABEL_34;
            case 70:
              v17 = *(double *)v5;
              v5 += 8;
              v12 = sub_10021FA0(
                      (char)v5,
                      a1 - v6,
                      (_BYTE *)(v6 + v4),
                      v17,
                      10.0,
                      v31,
                      "0123456789abcdefghijklmnopqrstuvwxyz");
              goto LABEL_34;
            case 76:
              v21 = *(_DWORD *)v5;
              v22 = (char **)(v5 + 4);
              v23 = *v22;
              v5 = (char *)(v22 + 1);
              v32 = (int)v23;
              if ( v23 )
              {
                v24 = *v23;
                if ( v24 )
                {
                  while ( 1 )
                  {
                    v30 = v21 - 1;
                    if ( !v21 )
                      break;
                    ++v32;
                    v6 += sub_10021EA0(a1 - v6, (_BYTE *)(v6 + v4), v24);
                    v24 = *v25;
                    if ( !*v25 )
                      break;
                    v21 = v30;
                  }
                }
              }
              goto LABEL_35;
            case 78:
              v5 += 4;
              *((_DWORD *)v5 - 1) = v6;
              goto LABEL_35;
            case 79:
              v29 = "0123456789abcdefghijklmnopqrstuvwxyz";
              v28 = 8;
LABEL_19:
              v16 = *(_DWORD *)v5;
              v5 += 4;
              v12 = sub_10021F10(a1 - v6, (char *)(v6 + v4), v16, v28, v29);
              goto LABEL_34;
            case 83:
              v18 = *(char **)v5;
              v5 += 4;
              if ( v18 )
              {
                v19 = *v18;
                if ( *v18 )
                {
                  do
                  {
                    v6 += sub_10021EA0(a1 - v6, (_BYTE *)(v6 + v4), v19);
                    v19 = *v20;
                  }
                  while ( *v20 );
                }
              }
              goto LABEL_35;
            case 85:
              v14 = *(_DWORD *)v5;
              v5 += 4;
              v12 = sub_10021F10(a1 - v6, (char *)(v6 + v4), v14, 0xAu, "0123456789abcdefghijklmnopqrstuvwxyz");
              goto LABEL_34;
            case 88:
              v15 = *(_DWORD *)v5;
              v5 += 4;
              v12 = sub_10021F10(a1 - v6, (char *)(v6 + v4), v15, 0x10u, "0123456789abcdefghijklmnopqrstuvwxyz");
              goto LABEL_34;
            default:
              goto LABEL_33;
          }
        }
      }
LABEL_33:
      v12 = sub_10021EA0(a1 - v6, (_BYTE *)(v6 + v4), *v7);
LABEL_34:
      v6 += v12;
LABEL_35:
      v26 = v33[1];
      v7 = ++v33;
    }
    while ( v26 );
  }
  sub_10021EA0(a1 - v6, (_BYTE *)(v6 + v4), 0);
  return v6;
}
// 10022522: variable 'v20' is possibly undefined
// 10022575: variable 'v25' is possibly undefined

//----- (10022670) --------------------------------------------------------
int __cdecl sub_10022670(int a1, int a2, int a3, char a4)
{
  char *v5; // [esp+0h] [ebp-4h] BYREF

  v5 = &a4;
  return sub_100222E0(a1, a2, a3, &v5);
}
// 100222E0: using guessed type _DWORD __cdecl sub_100222E0(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100226A0) --------------------------------------------------------
int __cdecl sub_100226A0(_DWORD *a1, int a2)
{
  int result; // eax

  result = 0;
  if ( a2 < *a1 )
    return *(_DWORD *)(a1[1] + 4 * a2);
  return result;
}

//----- (100226C0) --------------------------------------------------------
int __usercall sub_100226C0@<eax>(int a1@<ebx>, int a2, int a3)
{
  int v3; // esi

  v3 = a2 + 1;
  sub_10019A60(&a2, 28);
  sub_10019BC0(a2, 0, 8, v3, 8);
  sub_10019BC0(a2, 12, 20, a3, 1);
  sub_10019BC0(a2, 0, 24, v3, 4);
  if ( sub_10019C60((int)aWPublicGrannyR_18, 127) )
  {
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    sub_10019D80(a1, 8 * v3, 0, *(char **)(a2 + 8));
    sub_100228F0((int *)a2, byte_100360A8);
  }
  return a2;
}
// 100360A8: using guessed type _BYTE byte_100360A8[4];

//----- (10022770) --------------------------------------------------------
int __cdecl sub_10022770(int *a1)
{
  int result; // eax
  int v2; // eax
  int v3; // eax

  result = 0;
  if ( a1 )
  {
    v2 = sub_100227A0((int)a1);
    v3 = off_10033620((int)aWPublicGrannyR_18, 164, 4, v2);
    return sub_10022820(a1, v3);
  }
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (100227A0) --------------------------------------------------------
int __cdecl sub_100227A0(int a1)
{
  sub_100227D0(a1, &a1);
  return sub_10019D70();
}

//----- (100227D0) --------------------------------------------------------
int __cdecl sub_100227D0(int a1, int *a2)
{
  *(_DWORD *)(a1 + 16) = (*(_DWORD *)(a1 + 16) + 3) & 0xFFFFFFFC;
  sub_10019A60(a2, 16);
  sub_10019BC0(*a2, 0, 4, *(_DWORD *)(a1 + 4), 4);
  return sub_10019BC0(*a2, 8, 12, *(_DWORD *)(a1 + 16), 1);
}

//----- (10022820) --------------------------------------------------------
int __cdecl sub_10022820(int *a1, int a2)
{
  int result; // eax
  int v3; // eax
  int v4; // edx
  int v5; // edi
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // [esp+4h] [ebp-4h] BYREF

  result = 0;
  v8 = 0;
  if ( a1 )
  {
    sub_100227D0((int)a1, &v8);
    if ( sub_10019D50((int)aWPublicGrannyR_18, 186, a2) )
    {
      v3 = v8;
      v4 = 0;
      v5 = *(_DWORD *)(v8 + 4);
      if ( *a1 > 0 )
      {
        do
        {
          v6 = (_DWORD *)(a1[2] + 8 * v4);
          v7 = v6[1];
          if ( v7 )
            *(_DWORD *)(v5 + 4 * *v6) = v7 - a1[5];
          ++v4;
        }
        while ( v4 < *a1 );
        v3 = v8;
      }
      sub_10019E10(*(_DWORD *)(v3 + 8), (_BYTE *)a1[5], *(_DWORD *)(v3 + 12));
    }
    off_10033624((int)aWPublicGrannyR_18, 209, (int)a1);
    return v8;
  }
  return result;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (100228D0) --------------------------------------------------------
char *__cdecl sub_100228D0(int a1, int a2)
{
  char *result; // eax

  result = aIllegalStringA;
  if ( a2 < *(_DWORD *)(a1 + 4) )
    return *(char **)(*(_DWORD *)(a1 + 24) + 4 * a2);
  return result;
}

//----- (100228F0) --------------------------------------------------------
int __cdecl sub_100228F0(int *a1, _BYTE *a2)
{
  int *v2; // ebp
  int result; // eax
  int v4; // ebx
  int v5; // eax
  int v6; // ebx
  int v7; // edi

  v2 = (int *)(a1[2] + 8 * sub_10022990(a1, a2));
  if ( v2[1] )
    return *v2;
  v4 = sub_10021A00(a2);
  v5 = a1[4];
  v6 = v4 + 1;
  if ( v5 + v6 >= a1[3] )
  {
    sub_10017FE0(3, 13, "%s(%d): Out of character space in string table builder.", aWPublicGrannyR_18, 264);
    return 0;
  }
  else
  {
    v7 = v5 + a1[5];
    sub_10019E10(v6, a2, v7);
    a1[4] += v6;
    result = a1[1];
    a1[1] = result + 1;
    v2[1] = v7;
    *v2 = result;
    *(_DWORD *)(a1[6] + 4 * result) = v7;
  }
  return result;
}

//----- (10022990) --------------------------------------------------------
int __cdecl sub_10022990(int *a1, _BYTE *a2)
{
  _BYTE *v2; // ebp
  int v4; // esi
  char v5; // cl
  int v6; // eax
  _BYTE *i; // edx
  int v8; // ebx
  int v9; // esi
  _BYTE *v10; // eax
  _BYTE *v12; // eax
  int v13; // [esp+14h] [ebp+4h]

  v2 = a2;
  v4 = *a1;
  v13 = *a1;
  if ( !a2 )
  {
    v2 = &unk_100360A8;
    a2 = &unk_100360A8;
  }
  v5 = *v2;
  v6 = 0;
  for ( i = v2; v5; ++i )
  {
    v6 += v5;
    v5 = i[1];
  }
  v8 = v6 % v4;
  v9 = v8;
  if ( v8 >= v13 )
  {
LABEL_9:
    v9 = 0;
    if ( v8 <= 0 )
    {
LABEL_10:
      sub_10017FE0(3, 13, "%s(%d): Out of string space in string table builder.", aWPublicGrannyR_18, 107);
      return 0;
    }
    while ( 1 )
    {
      v12 = *(_BYTE **)(a1[2] + 8 * v9 + 4);
      if ( !v12 || sub_10021A20(v12, v2) )
        break;
      if ( ++v9 >= v8 )
        goto LABEL_10;
      v2 = a2;
    }
  }
  else
  {
    while ( 1 )
    {
      v10 = *(_BYTE **)(a1[2] + 8 * v9 + 4);
      if ( !v10 || sub_10021A20(v10, v2) )
        break;
      v2 = a2;
      if ( ++v9 >= v13 )
        goto LABEL_9;
    }
  }
  return v9;
}

//----- (10022A60) --------------------------------------------------------
LARGE_INTEGER *__cdecl sub_10022A60(LARGE_INTEGER *a1)
{
  LARGE_INTEGER *result; // eax
  LARGE_INTEGER PerformanceCount; // [esp+0h] [ebp-10h] BYREF
  DWORD v3; // [esp+8h] [ebp-8h]
  LONG v4; // [esp+Ch] [ebp-4h]

  QueryPerformanceCounter(&PerformanceCount);
  result = a1;
  *a1 = PerformanceCount;
  a1[1].LowPart = v3;
  a1[1].HighPart = v4;
  return result;
}

//----- (10022AA0) --------------------------------------------------------
double __cdecl sub_10022AA0(_QWORD *a1, _QWORD *a2)
{
  LARGE_INTEGER Frequency; // [esp+0h] [ebp-8h] BYREF

  if ( dbl_10056340 == 0.0 )
  {
    QueryPerformanceFrequency(&Frequency);
    dbl_10056340 = 1.0 / (double)Frequency.QuadPart;
  }
  if ( *a1 >= *a2 )
    return 0.0;
  else
    return (double)(__int64)(*a2 - *a1) * dbl_10056340;
}
// 10056340: using guessed type double dbl_10056340;

//----- (10022B20) --------------------------------------------------------
void __cdecl sub_10022B20(float a1)
{
  float v1; // [esp+8h] [ebp+4h]

  v1 = a1 * 1000.0;
  Sleep((int)v1);
}

//----- (10022B50) --------------------------------------------------------
char *__cdecl sub_10022B50(int a1)
{
  if ( a1 >= 2 )
    return aUnknownTexture;
  else
    return off_100346F0[a1];
}
// 100346F0: using guessed type char *off_100346F0[6];

//----- (10022B70) --------------------------------------------------------
char *__cdecl sub_10022B70(int a1)
{
  if ( a1 >= 4 )
    return aUnknownTexture_0;
  else
    return off_100346F8[a1];
}
// 100346F8: using guessed type char *off_100346F8[4];

//----- (10022B90) --------------------------------------------------------
int __cdecl sub_10022B90(int a1, int a2, int a3, int a4)
{
  return a4 * a2;
}

//----- (10022BA0) --------------------------------------------------------
int __cdecl sub_10022BA0(int a1, int a2, int a3)
{
  int result; // eax

  switch ( a1 )
  {
    case 0:
    case 1:
      result = a3 * a2 / 2;
      break;
    case 2:
    case 3:
      result = a3 * a2;
      break;
    default:
      sub_10017FE0(3, 20, "%s(%d): Unrecognized S3TC texture format (%d)", aWPublicGrannyR_39, 151, a1);
      result = 0;
      break;
  }
  return result;
}

//----- (10022C00) --------------------------------------------------------
char __cdecl sub_10022C00(_DWORD *a1, void *a2)
{
  char result; // al

  result = 0;
  switch ( a1[4] )
  {
    case 1:
      goto LABEL_4;
    case 2:
      qmemcpy(a2, sub_1001D970(a1[5]), 0x24u);
      return 1;
    case 3:
LABEL_4:
      qmemcpy(a2, a1 + 6, 0x24u);
      return 1;
  }
  return result;
}

//----- (10022C50) --------------------------------------------------------
char __cdecl sub_10022C50(int *a1, int a2, int a3, unsigned int *a4, int a5, int a6, int a7, unsigned int *a8)
{
  int v8; // ecx
  int v9; // edx
  int *v10; // eax
  int v11; // edx
  int *v12; // eax
  signed int v13; // esi
  int v14; // edi
  bool v15; // al
  int *v17; // eax
  int *v18; // ebx
  int v19; // ebp
  int *v20; // [esp-1Ch] [ebp-30h]
  char v21; // [esp+7h] [ebp-Dh]
  unsigned __int16 *v22; // [esp+10h] [ebp-4h]

  v21 = 0;
  if ( a2 < 0 || a2 >= a1[15] )
  {
    sub_10017FE0(3, 20, "%s(%d): ImageIndex %d is out of range [0, %d)", aWPublicGrannyR_39, 190, a2, a1[15]);
    return 0;
  }
  else
  {
    v8 = a1[16];
    v9 = *(_DWORD *)(v8 + 8 * a2);
    if ( a3 < 0 || a3 >= v9 )
    {
      sub_10017FE0(3, 20, "%s(%d): MIPIndex %d is out of range [0, %d)", aWPublicGrannyR_39, 193, a3, v9);
      return 0;
    }
    else
    {
      v10 = (int *)(*(_DWORD *)(v8 + 8 * a2 + 4) + 12 * a3);
      v11 = *v10;
      v12 = (int *)v10[2];
      v13 = a1[2] >> a3;
      v22 = (unsigned __int16 *)v12;
      if ( v13 < 1 )
        v13 = 1;
      v14 = a1[3] >> a3;
      if ( v14 < 1 )
        v14 = 1;
      if ( a1[4] == 1 )
      {
        if ( v13 == a5 && v14 == a6 )
        {
          sub_10002980(v13, v14, a1 + 6, v11, v12, a4, a7, a8);
          return 1;
        }
        goto LABEL_29;
      }
      if ( a1[4] != 2 )
      {
        if ( a1[4] == 3 )
        {
          if ( v13 == a5 && v14 == a6 )
          {
            v20 = v12;
            v15 = sub_10002820((int)(a1 + 6));
            sub_10009E50((int *)v13, v14, v15, v20, a4, a7, a8);
            return 1;
          }
LABEL_29:
          sub_10017FE0(2, 0, aAutomaticResca);
        }
        return 0;
      }
      v17 = (int *)off_10033620((int)aWPublicGrannyR_39, 230, 4, 4 * v13 * v14);
      v18 = v17;
      if ( !v17 )
        return 0;
      v19 = a1[5];
      switch ( v19 )
      {
        case 0:
        case 1:
          sub_1001E4B0(v17, v22, v13, v14);
          break;
        case 2:
          sub_1001E800(v17, (int *)v22, v13, v14);
          break;
        case 3:
          sub_1001EC40(v17, (unsigned __int8 *)v22, v13, v14);
          break;
        default:
          sub_10017FE0(3, 20, "%s(%d): Unrecognized S3 texture format (%d)", aWPublicGrannyR_39, 261, v19);
          break;
      }
      if ( v13 == a5 && v14 == a6 )
      {
        sub_10002980(v13, v14, dword_1002A300, 4 * v13, v18, a4, a7, a8);
        v21 = 1;
      }
      else
      {
        sub_10017FE0(2, 0, aAutomaticResca);
      }
      off_10033624((int)aWPublicGrannyR_39, 281, (int)v18);
      return v21;
    }
  }
}
// 1002A228: using guessed type int dword_1002A228;
// 1002A300: using guessed type _DWORD dword_1002A300[12];
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10022ED0) --------------------------------------------------------
BOOL __cdecl sub_10022ED0(int a1)
{
  return sub_10002820(a1 + 24);
}

//----- (10022EE0) --------------------------------------------------------
_DWORD *__cdecl sub_10022EE0(int a1, int a2, const void *a3, int a4)
{
  _DWORD *result; // eax

  result = sub_10022F20(a1, a2, 1);
  if ( result )
  {
    qmemcpy(result + 11, a3, 0x24u);
    result[20] = 0;
    result[21] = a4;
  }
  return result;
}

//----- (10022F20) --------------------------------------------------------
_DWORD *__cdecl sub_10022F20(int a1, int a2, int a3)
{
  _DWORD *result; // eax

  result = (_DWORD *)off_10033620((int)aWPublicGrannyR_40, 106, 4, 96);
  if ( result )
  {
    result[1] = a3;
    *result = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = 0;
    result[6] = 0;
    result[7] = 0;
    result[8] = 0;
    result[9] = a1;
    result[10] = a2;
  }
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (10022F70) --------------------------------------------------------
_DWORD *__cdecl sub_10022F70(int a1, int a2, int a3)
{
  _DWORD *v3; // ebx

  v3 = sub_10022F20(a1, a2, 2);
  if ( v3 )
  {
    qmemcpy(v3 + 11, sub_1001D970(a3), 0x24u);
    v3[20] = a3;
  }
  return v3;
}

//----- (10022FC0) --------------------------------------------------------
_DWORD *__cdecl sub_10022FC0(int a1, int a2)
{
  _DWORD *result; // eax

  result = sub_10022F20(a1, a2, 2);
  if ( result )
    result[20] = 0xFFFF;
  return result;
}

//----- (10022FE0) --------------------------------------------------------
_DWORD *__cdecl sub_10022FE0(int a1, int a2, int a3, char a4)
{
  _DWORD *v4; // ebp

  v4 = sub_10022F20(a1, a2, 3);
  if ( v4 )
  {
    qmemcpy(v4 + 11, sub_10009B60(a4), 0x24u);
    *((_BYTE *)v4 + 92) = a4;
    v4[20] = 0;
    v4[22] = a3;
  }
  return v4;
}

//----- (10023030) --------------------------------------------------------
_DWORD *__cdecl sub_10023030(int *a1)
{
  _DWORD *result; // eax
  int v2; // eax
  int v3; // eax

  result = 0;
  if ( a1 )
  {
    v2 = sub_10023060(a1);
    v3 = off_10033620((int)aWPublicGrannyR_40, 196, 4, v2);
    return sub_100230E0(a1, v3);
  }
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (10023060) --------------------------------------------------------
int __cdecl sub_10023060(int *a1)
{
  int v2; // [esp+0h] [ebp-8h] BYREF
  int v3; // [esp+4h] [ebp-4h] BYREF

  sub_10023090(a1, &v3, &v2, &a1);
  return sub_10019D70();
}

//----- (10023090) --------------------------------------------------------
int __cdecl sub_10023090(int *a1, int *a2, _DWORD *a3, _DWORD *a4)
{
  sub_10019A60(a2, 76);
  sub_10019BC0(*a2, 60, 64, a1[2], 8);
  sub_10019A60(a4, a1[4]);
  return sub_10019A60(a3, a1[3]);
}

//----- (100230E0) --------------------------------------------------------
_DWORD *__cdecl sub_100230E0(int *a1, int a2)
{
  int v2; // ebp
  _DWORD *result; // eax
  int *v4; // ebx
  _DWORD *v5; // eax
  int v6; // edx
  int v7; // edi
  int v8; // ecx
  bool v9; // cc
  int v10; // esi
  int v11; // ebp
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  _DWORD *v15; // esi
  int v16; // edx
  int v17; // ecx
  int v18; // esi
  int v19; // eax
  _DWORD *v20; // [esp+8h] [ebp-14h] BYREF
  int v21; // [esp+Ch] [ebp-10h] BYREF
  int v22; // [esp+10h] [ebp-Ch] BYREF
  int v23; // [esp+14h] [ebp-8h]
  int v24; // [esp+18h] [ebp-4h]
  _DWORD *v25; // [esp+24h] [ebp+8h]

  v2 = (int)a1;
  result = 0;
  v20 = 0;
  if ( a1 )
  {
    v21 = 0;
    v22 = 0;
    sub_10023090(a1, (int *)&v20, &v21, &v22);
    if ( sub_10019D50((int)aWPublicGrannyR_40, 233, a2) )
    {
      *v20 = 0;
      v20[1] = *a1;
      v20[2] = a1[9];
      v20[3] = a1[10];
      v20[4] = a1[1];
      v20[5] = a1[20];
      qmemcpy(v20 + 6, a1 + 11, 0x24u);
      v20[17] = 0;
      v20[18] = 0;
      v4 = (int *)v20[16];
      v5 = (_DWORD *)a1[5];
      v6 = v21;
      v7 = v22;
      v25 = v5;
      if ( v5 )
      {
        while ( 1 )
        {
          v8 = *v5;
          v9 = *v5 <= 0;
          v10 = 3 * *v5;
          v4[1] = v6;
          *v4 = v8;
          v24 = v6 + 4 * v10;
          v23 = 0;
          if ( !v9 )
          {
            v11 = 0;
            do
            {
              v12 = v5[1];
              v13 = *(_DWORD *)(v12 + v11);
              v14 = v11 + v12;
              v15 = (_DWORD *)(v11 + v4[1]);
              *v15 = v13;
              v16 = *(_DWORD *)(v14 + 4);
              v15[1] = v16;
              v15[2] = v7;
              sub_10019E10(v16, *(_BYTE **)(v14 + 8), v7);
              v17 = *v4;
              v7 += v15[1];
              v11 += 12;
              ++v23;
              v5 = v25;
            }
            while ( v23 < v17 );
            v2 = (int)a1;
          }
          v4 += 2;
          v25 = (_DWORD *)v5[2];
          if ( !v25 )
            break;
          v6 = v24;
          v5 = (_DWORD *)v5[2];
        }
      }
    }
    v18 = *(_DWORD *)(v2 + 20);
    while ( v18 )
    {
      v19 = v18;
      v18 = *(_DWORD *)(v18 + 8);
      off_10033624((int)aWPublicGrannyR_40, 284, v19);
    }
    off_10033624((int)aWPublicGrannyR_40, 286, v2);
    return v20;
  }
  return result;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10023270) --------------------------------------------------------
void __cdecl sub_10023270(int a1, int a2, int a3)
{
  *(_DWORD *)(a1 + 28) = a2;
  *(_DWORD *)(a1 + 32) = a3;
  if ( a2 != a3 )
    sub_10017FE0(2, 0, aImageScalerDoe);
}

//----- (100232B0) --------------------------------------------------------
int __cdecl sub_100232B0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ebx
  unsigned int *v7; // edi
  unsigned int v8; // esi
  unsigned int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // ebx
  int v13; // eax
  int *v14; // ebx
  int *v15; // eax
  int v16; // ecx
  int v17; // edx
  int v18; // eax
  int v19; // ebx
  int v20; // esi
  int result; // eax
  signed int v22[11]; // [esp-34h] [ebp-184h] BYREF
  int v23; // [esp-8h] [ebp-158h]
  int *v24; // [esp-4h] [ebp-154h]
  unsigned int *v25; // [esp+10h] [ebp-140h] BYREF
  int v26; // [esp+14h] [ebp-13Ch]
  int *v27; // [esp+18h] [ebp-138h]
  int v28; // [esp+1Ch] [ebp-134h]
  int v29; // [esp+20h] [ebp-130h]
  int v30; // [esp+24h] [ebp-12Ch]
  int v31[11]; // [esp+28h] [ebp-128h] BYREF
  _BYTE v32[44]; // [esp+54h] [ebp-FCh] BYREF
  int v33[3]; // [esp+80h] [ebp-D0h] BYREF
  int v34[3]; // [esp+8Ch] [ebp-C4h] BYREF
  signed int v35[3]; // [esp+98h] [ebp-B8h] BYREF
  _BYTE v36[44]; // [esp+A4h] [ebp-ACh] BYREF
  _BYTE v37[128]; // [esp+D0h] [ebp-80h] BYREF

  v6 = 0;
  v29 = 0;
  qmemcpy(v32, sub_100235D0(v36, a1, a2, a3, a4, a5, 0), sizeof(v32));
  qmemcpy(v31, v32, sizeof(v31));
  if ( sub_100235C0((int)v31) )
  {
    v7 = (unsigned int *)v37;
    while ( 1 )
    {
      v8 = 0;
      if ( *(_DWORD *)(a1 + 4) == 1 )
        break;
      if ( *(_DWORD *)(a1 + 4) == 2 )
      {
        v10 = *(_DWORD *)(a1 + 80);
        if ( v10 == 0xFFFF )
          v10 = 2;
        v9 = sub_10022BA0(v10, v31[7], v31[8]);
        goto LABEL_12;
      }
      if ( *(_DWORD *)(a1 + 4) == 3 )
      {
        v9 = sub_10009B80(v31[7], v31[8], *(_BYTE *)(a1 + 92), *(_DWORD *)(a1 + 88));
LABEL_12:
        v8 = v9;
        goto LABEL_13;
      }
      sub_10017FE0(3, 20, "%s(%d): Unrecognized texture encoding %d.", aWPublicGrannyR_40, 594, *(_DWORD *)(a1 + 4));
LABEL_13:
      v24 = v31;
      *v7 = v8;
      v6 += v8;
      sub_10023720(v24);
      ++v7;
      if ( !sub_100235C0((int)v31) )
      {
        v29 = v6;
        goto LABEL_15;
      }
    }
    v24 = (int *)v31[8];
    v23 = v31[7];
    v11 = sub_10023810(a1, v31[7]);
    v9 = sub_10022B90(a1 + 44, v11, v23, (int)v24);
    goto LABEL_12;
  }
LABEL_15:
  v30 = sub_10023770((_DWORD *)a1, a5, v6, &v25);
  v12 = 0;
  v26 = 0;
  qmemcpy(v32, sub_100235D0(v36, a1, a2, a3, a4, a5, a6), sizeof(v32));
  qmemcpy(v31, v32, sizeof(v31));
  if ( sub_100235C0((int)v31) )
  {
    v28 = 0;
    v27 = (int *)v37;
    while ( 1 )
    {
      v13 = *v27;
      v14 = (int *)(v28 + *(_DWORD *)(v30 + 4));
      *v14 = 0;
      v14[1] = 0;
      v14[2] = 0;
      if ( *(_DWORD *)(a1 + 4) == 1 )
      {
        qmemcpy(v22, v31, sizeof(v22));
        v15 = sub_10023840(
                v34,
                a1,
                v22[0],
                v22[1],
                v22[2],
                v22[3],
                v22[4],
                v22[5],
                v22[6],
                v22[7],
                v22[8],
                v22[9],
                (int *)v22[10],
                v13,
                v25);
        goto LABEL_24;
      }
      if ( *(_DWORD *)(a1 + 4) == 2 )
        break;
      if ( *(_DWORD *)(a1 + 4) == 3 )
      {
        qmemcpy(v22, v31, sizeof(v22));
        v15 = sub_100239F0(
                v33,
                a1,
                v22[0],
                v22[1],
                v22[2],
                v22[3],
                v22[4],
                v22[5],
                v22[6],
                v22[7],
                v22[8],
                v22[9],
                (unsigned __int8 *)v22[10],
                v13,
                v25);
LABEL_24:
        v16 = *v15;
        v17 = v15[1];
        v18 = v15[2];
        *v14 = v16;
        v14[1] = v17;
        v14[2] = v18;
        goto LABEL_25;
      }
      sub_10017FE0(3, 20, "%s(%d): Unrecognized texture encoding %d.", aWPublicGrannyR_40, 645, *(_DWORD *)(a1 + 4));
LABEL_25:
      v19 = v14[1];
      v20 = v19 + v26;
      v26 += v19;
      v25 = (unsigned int *)((char *)v25 + v19);
      sub_10023720(v31);
      ++v27;
      v28 += 12;
      if ( !sub_100235C0((int)v31) )
      {
        v12 = v20;
        goto LABEL_27;
      }
    }
    qmemcpy(v22, v31, sizeof(v22));
    v15 = sub_100238A0(
            v35,
            a1,
            v22[0],
            v22[1],
            v22[2],
            v22[3],
            v22[4],
            v22[5],
            v22[6],
            v22[7],
            v22[8],
            v22[9],
            v22[10],
            v13,
            v25);
    goto LABEL_24;
  }
LABEL_27:
  result = v12 - v29 + *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

//----- (100235C0) --------------------------------------------------------
BOOL __cdecl sub_100235C0(int a1)
{
  return *(_DWORD *)(a1 + 4) != 0;
}

//----- (100235D0) --------------------------------------------------------
void *__cdecl sub_100235D0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi
  int v8; // eax
  void *result; // eax
  _DWORD v10[11]; // [esp+8h] [ebp-2Ch] BYREF

  v10[1] = a6;
  v10[4] = a4;
  v7 = *(_DWORD *)(a2 + 36);
  v10[5] = a5;
  v10[9] = a5;
  v10[0] = a2;
  v8 = *(_DWORD *)(a2 + 40);
  v10[3] = a3;
  v10[2] = 0;
  v10[6] = a7;
  v10[7] = v7;
  v10[8] = v8;
  v10[10] = a7;
  sub_10023650(v10);
  result = a1;
  qmemcpy(a1, v10, 0x2Cu);
  return result;
}

//----- (10023650) --------------------------------------------------------
void __cdecl sub_10023650(_DWORD *a1)
{
  int v1; // ecx
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // [esp-4h] [ebp-Ch]

  if ( sub_100235C0((int)a1) )
  {
    v1 = a1[6];
    if ( v1 )
    {
      v2 = a1[7];
      if ( v2 == a1[3] && a1[8] == a1[4] )
      {
        v3 = a1[5];
        a1[2] = 0;
        a1[10] = v1;
        a1[9] = v3;
      }
      else
      {
        v5 = 4 * v2 * a1[8];
        a1[9] = 4 * v2;
        v4 = off_10033620((int)aWPublicGrannyR_40, 330, 4, v5);
        a1[2] = v4;
        a1[10] = v4;
        if ( v4 )
        {
          sub_10016540(*(float *)(*a1 + 32), a1[3], a1[4], a1[5], a1[6], a1[7], a1[8], a1[9], v4);
        }
        else
        {
          a1[1] = 0;
          a1[7] = 0;
          a1[8] = 0;
          sub_10017FE0(3, 20, "%s(%d): Out of memory in texture image builder", aWPublicGrannyR_40, 347);
        }
      }
    }
  }
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (10023720) --------------------------------------------------------
void __cdecl sub_10023720(_DWORD *a1)
{
  int v1; // ecx
  int v2; // edx
  int v3; // eax

  off_10033624((int)aWPublicGrannyR_40, 381, a1[2]);
  v1 = a1[1];
  v2 = a1[8];
  a1[10] = 0;
  a1[2] = 0;
  v3 = (int)a1[7] >> 1;
  a1[1] = v1 - 1;
  a1[7] = v3;
  a1[8] = v2 >> 1;
  sub_10023650(a1);
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10023770) --------------------------------------------------------
int __cdecl sub_10023770(_DWORD *a1, int a2, int a3, _DWORD *a4)
{
  bool v4; // zf
  int result; // eax
  int v6; // esi
  int v7; // edx
  int v8; // [esp+8h] [ebp-4h] BYREF

  sub_10019A60(&v8, 12);
  sub_10019BC0(v8, 0, 4, a2, 12);
  sub_10019A60(a4, a3);
  v4 = sub_10019C60((int)aWPublicGrannyR_40, 401) == 0;
  result = v8;
  if ( !v4 )
  {
    *(_DWORD *)(v8 + 8) = 0;
    result = v8;
    if ( a1[5] )
    {
      *(_DWORD *)(a1[6] + 8) = v8;
      result = v8;
    }
    else
    {
      a1[5] = v8;
    }
    ++a1[2];
    v6 = 12 * a2 + a1[3];
    v7 = a3 + a1[4];
    a1[6] = result;
    a1[3] = v6;
    a1[4] = v7;
  }
  return result;
}

//----- (10023810) --------------------------------------------------------
int __cdecl sub_10023810(int a1, int a2)
{
  int v2; // ecx
  int v3; // esi
  int v4; // eax

  v2 = a2 * *(_DWORD *)(a1 + 44);
  v3 = *(_DWORD *)(a1 + 84);
  v4 = v3 - v2 % v3;
  if ( v4 != v3 )
    v2 += v4;
  return v2;
}

//----- (10023840) --------------------------------------------------------
int *__cdecl sub_10023840(
        int *a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        unsigned int a10,
        int a11,
        int a12,
        int *a13,
        int a14,
        unsigned int *a15)
{
  int v15; // esi
  int *result; // eax

  v15 = sub_10023810(a2, a10);
  sub_10002980(a10, a11, &dword_1002A228, a12, a13, (unsigned int *)(a2 + 44), v15, a15);
  result = a1;
  *a1 = v15;
  a1[1] = a14;
  a1[2] = (int)a15;
  return result;
}
// 1002A228: using guessed type int dword_1002A228;

//----- (100238A0) --------------------------------------------------------
signed int *__cdecl sub_100238A0(
        signed int *a1,
        int a2,
        signed int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        signed int a10,
        unsigned int a11,
        unsigned int a12,
        int a13,
        signed int a14,
        _WORD *a15)
{
  int v15; // eax
  signed int v16; // ebp
  _WORD *v17; // edi
  int v18; // esi
  signed int *result; // eax

  v15 = *(_DWORD *)(a2 + 80);
  v16 = a14;
  v17 = a15;
  if ( v15 > 2 )
  {
    if ( v15 == 3 )
    {
      v18 = a10;
      sub_1001DE70((int)a15, a13, a12, a10, a11);
      goto LABEL_13;
    }
    if ( v15 == 0xFFFF )
    {
      sub_1001DF20(a15, a13, a12, a10, a11, &a14);
      result = a1;
      *(_DWORD *)(a2 + 80) = (a14 != 0) + 2;
      *a1 = a10;
      a1[1] = v16;
      a1[2] = (signed int)v17;
      return result;
    }
    goto LABEL_10;
  }
  if ( v15 == 2 )
  {
    v18 = a10;
    sub_1001DAD0(a15, a13, a12, a10, a11);
    goto LABEL_13;
  }
  if ( !v15 )
  {
    v18 = a10 / 2;
    sub_1001D9B0(a15, a13, a12, a10, a11);
    goto LABEL_13;
  }
  if ( v15 != 1 )
  {
LABEL_10:
    sub_10017FE0(3, 20, "%s(%d): Unrecognized S3TC texture type (%d)", aWPublicGrannyR_40, 520, *(_DWORD *)(a2 + 80));
    result = a1;
    *a1 = a3;
    a1[1] = v16;
    a1[2] = (signed int)v17;
    return result;
  }
  v18 = a10 / 2;
  sub_1001DA40((int)a15, a13, a12, a10, a11);
LABEL_13:
  result = a1;
  *a1 = v18;
  a1[1] = v16;
  a1[2] = (signed int)v17;
  return result;
}

//----- (100239F0) --------------------------------------------------------
_DWORD *__cdecl sub_100239F0(
        _DWORD *a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        unsigned __int8 *a13,
        int a14,
        unsigned int *a15)
{
  int v15; // eax

  v15 = sub_10009C80(a10, a11, a12, a13, *(_BYTE *)(a2 + 92), *(_DWORD *)(a2 + 88), a15);
  *a1 = 0;
  a1[1] = v15;
  a1[2] = a15;
  return a1;
}

//----- (10023A40) --------------------------------------------------------
_DWORD *__cdecl sub_10023A40(int a1, _DWORD *a2)
{
  return sub_100018D0(a1 + 28, a2);
}

//----- (10023A50) --------------------------------------------------------
float *__cdecl sub_10023A50(float *a1, int a2, float *a3)
{
  int i; // edi
  float *result; // eax

  for ( i = a2; i; --i )
  {
    result = sub_100013D0(a3, a1);
    a3 += 3;
  }
  return result;
}

//----- (10023A80) --------------------------------------------------------
int __cdecl sub_10023A80(int a1, int a2, int a3)
{
  int i; // edi
  int result; // eax
  float v6; // ecx
  float v7; // edx
  float v8[4]; // [esp+4h] [ebp-10h] BYREF

  for ( i = a2; i; --i )
  {
    sub_10018BC0(v8, (float *)(a1 + 16), (float *)a3);
    result = LODWORD(v8[1]);
    v6 = v8[2];
    *(float *)a3 = v8[0];
    v7 = v8[3];
    *(_DWORD *)(a3 + 4) = result;
    *(float *)(a3 + 8) = v6;
    *(float *)(a3 + 12) = v7;
    a3 += 16;
  }
  return result;
}

//----- (10023AE0) --------------------------------------------------------
float *__cdecl sub_10023AE0(int a1, int a2, int a3)
{
  float *result; // eax
  int i; // edi
  float v6; // ecx
  float v7; // edx
  float v8; // eax
  float v9; // ecx
  float v10; // edx
  float v11; // ecx
  float v12; // edx
  float v13[9]; // [esp+8h] [ebp-6Ch] BYREF
  float v14[9]; // [esp+2Ch] [ebp-48h] BYREF
  float v15[9]; // [esp+50h] [ebp-24h] BYREF

  sub_100189A0(v14, (float *)(a1 + 16));
  sub_10018450(v13, (float *)(a1 + 32), v14);
  result = sub_10018540(v15, v14, v13);
  for ( i = a2; i; --i )
  {
    sub_10018450(v13, v15, (float *)a3);
    v6 = v13[1];
    v7 = v13[2];
    *(float *)a3 = v13[0];
    v8 = v13[3];
    *(float *)(a3 + 4) = v6;
    v9 = v13[4];
    *(float *)(a3 + 8) = v7;
    v10 = v13[5];
    *(float *)(a3 + 12) = v8;
    result = (float *)LODWORD(v13[6]);
    *(float *)(a3 + 16) = v9;
    v11 = v13[7];
    *(float *)(a3 + 20) = v10;
    v12 = v13[8];
    *(_DWORD *)(a3 + 24) = result;
    *(float *)(a3 + 28) = v11;
    *(float *)(a3 + 32) = v12;
    a3 += 36;
  }
  return result;
}

//----- (10023B90) --------------------------------------------------------
BOOL __cdecl sub_10023B90(_DWORD *a1, int *a2)
{
  char *v2; // edx
  char *v3; // ecx
  char *v4; // eax

  v2 = (char *)a1[5];
  if ( !v2 )
    v2 = (char *)flt_1002A650;
  v3 = (char *)a1[10];
  if ( !v3 )
    v3 = (char *)&unk_1002A660;
  v4 = (char *)a1[15];
  if ( !v4 )
    v4 = (char *)&unk_1002A670;
  return sub_10001080(a2, v2, v3, v4);
}
// 1002A650: using guessed type float flt_1002A650[4];

//----- (10023BD0) --------------------------------------------------------
float *__cdecl sub_10023BD0(int a1)
{
  float *result; // eax
  float v2[17]; // [esp+4h] [ebp-88h] BYREF
  float v3[17]; // [esp+48h] [ebp-44h] BYREF

  sub_10023B90((_DWORD *)a1, (int *)v3);
  sub_10001690((int *)v2, v3);
  if ( *(_DWORD *)(a1 + 20) )
    sub_10023A50(v2, *(_DWORD *)(a1 + 8), *(float **)(a1 + 20));
  if ( *(_DWORD *)(a1 + 40) )
    sub_10023A80((int)v2, *(_DWORD *)(a1 + 28), *(_DWORD *)(a1 + 40));
  result = *(float **)(a1 + 60);
  if ( result )
    return sub_10023AE0((int)v2, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 60));
  return result;
}

//----- (10023C50) --------------------------------------------------------
float *__cdecl sub_10023C50(float *a1, float *a2, int a3, int a4, float *a5)
{
  int i; // edi
  float *result; // eax

  for ( i = a4; i; --i )
  {
    result = sub_100191A0(a1, a2, a5);
    a5 += 3;
  }
  return result;
}

//----- (10023C80) --------------------------------------------------------
int __cdecl sub_10023C80(int a1, float *a2, float *a3, int a4, float *a5)
{
  float *v5; // esi
  int v6; // edi

  v5 = a5;
  v6 = a4;
  if ( a4 )
  {
    do
    {
      sub_10019210(a2, a3, v5);
      v5 += 4;
      --v6;
    }
    while ( v6 );
    v6 = a4;
  }
  return sub_10018D90(v6, a5);
}

//----- (10023CC0) --------------------------------------------------------
float *__cdecl sub_10023CC0(int a1, float *a2, float *a3, int a4, float *a5)
{
  int i; // edi
  float *result; // eax

  for ( i = a4; i; --i )
  {
    result = sub_100192E0(a2, a3, a5);
    a5 += 9;
  }
  return result;
}

//----- (10023CF0) --------------------------------------------------------
void __cdecl sub_10023CF0(int a1, float *a2, float *a3, float *a4)
{
  int v5; // esi
  int v6; // esi
  float *v7; // eax
  int v8; // esi
  bool v9; // cc
  int v10; // edi
  float *v11; // esi
  float *v12; // ebp
  long double v13; // st4
  long double v14; // st4
  long double v15; // st4
  int v16; // [esp+10h] [ebp-4h]
  float *v17; // [esp+18h] [ebp+4h]
  int v18; // [esp+20h] [ebp+Ch]

  v5 = a1;
  v16 = 0;
  if ( *(int *)(a1 + 12) > 0 )
  {
    v18 = 0;
    do
    {
      v6 = *(_DWORD *)(v5 + 16);
      v7 = *(float **)(v6 + v18 + 20);
      v8 = v18 + v6;
      if ( v7 )
        sub_10023C50(a2, a3, (int)a4, *(_DWORD *)(v8 + 8), v7);
      if ( *(_DWORD *)(v8 + 40) )
        sub_10023C80((int)a2, a3, a4, *(_DWORD *)(v8 + 28), *(float **)(v8 + 40));
      if ( *(_DWORD *)(v8 + 60) )
        sub_10023CC0((int)a2, a3, a4, *(_DWORD *)(v8 + 48), *(float **)(v8 + 60));
      v9 = v16 + 1 < *(_DWORD *)(a1 + 12);
      v18 += 64;
      ++v16;
      v5 = a1;
    }
    while ( v9 );
  }
  sub_100191A0(a2, a3, (float *)(v5 + 100));
  v10 = *(_DWORD *)(v5 + 112);
  if ( v10 )
  {
    v11 = (float *)(v10 + 12);
    sub_100191A0(flt_1002A650, a3, (float *)(v10 + 12));
    v12 = (float *)(v10 + 24);
    sub_100191A0(flt_1002A650, a3, (float *)(v10 + 24));
    v17 = (float *)(v10 + 36);
    sub_100191A0(flt_1002A650, a3, (float *)(v10 + 36));
    *(float *)v10 = sqrt(*v11 * *v11 + v11[1] * v11[1] + v11[2] * v11[2]) * *(float *)v10;
    v13 = sqrt(*v11 * *v11 + *(float *)(v10 + 16) * *(float *)(v10 + 16) + *(float *)(v10 + 20) * *(float *)(v10 + 20));
    if ( v13 <= 0.0000099999997 )
    {
      *(_DWORD *)(v10 + 20) = 0;
      *(_DWORD *)(v10 + 16) = 0;
      *v11 = 0.0;
    }
    else
    {
      *v11 = 1.0 / v13 * *v11;
      *(float *)(v10 + 16) = 1.0 / v13 * *(float *)(v10 + 16);
      *(float *)(v10 + 20) = 1.0 / v13 * *(float *)(v10 + 20);
    }
    v14 = sqrt(*v12 * *v12 + *(float *)(v10 + 28) * *(float *)(v10 + 28) + *(float *)(v10 + 32) * *(float *)(v10 + 32));
    if ( v14 <= 0.0000099999997 )
    {
      *(_DWORD *)(v10 + 32) = 0;
      *(_DWORD *)(v10 + 28) = 0;
      *v12 = 0.0;
    }
    else
    {
      *v12 = 1.0 / v14 * *v12;
      *(float *)(v10 + 28) = 1.0 / v14 * *(float *)(v10 + 28);
      *(float *)(v10 + 32) = 1.0 / v14 * *(float *)(v10 + 32);
    }
    v15 = sqrt(*v17 * *v17 + v17[1] * v17[1] + v17[2] * v17[2]);
    if ( v15 <= 0.0000099999997 )
    {
      *(_DWORD *)(v10 + 44) = 0;
      *(_DWORD *)(v10 + 40) = 0;
      *v17 = 0.0;
    }
    else
    {
      *v17 = 1.0 / v15 * *v17;
      *(float *)(v10 + 40) = 1.0 / v15 * *(float *)(v10 + 40);
      *(float *)(v10 + 44) = 1.0 / v15 * *(float *)(v10 + 44);
    }
  }
}
// 1002A170: using guessed type float flt_1002A170;
// 1002A650: using guessed type float flt_1002A650[4];

//----- (10023F10) --------------------------------------------------------
char __cdecl sub_10023F10(int a1, int a2, int a3, int a4, int a5, int a6, float a7, _DWORD *a8, _DWORD *a9)
{
  long double v9; // st7
  long double v10; // st6
  int v12; // ecx
  int v13; // ebp
  int v14; // edi
  int v15; // esi
  float *v16; // eax
  int v17; // esi
  int v18; // edx
  double v19; // st5
  int v21; // [esp+Ch] [ebp+8h]
  int v22; // [esp+18h] [ebp+14h]

  v9 = 0.0;
  v10 = 0.0;
  if ( a3 > 0 )
  {
    v12 = a6 - a5;
    v13 = a5;
    v14 = -4 * a2;
    v15 = a5 - a6;
    v22 = a5 - a6;
    v21 = a3;
    do
    {
      if ( a2 > 0 )
      {
        v16 = (float *)v13;
        v17 = v12 + v15;
        v18 = a2;
        do
        {
          v19 = *v16++;
          --v18;
          v9 = v9 + fabs(v19 - *(float *)((char *)v16 + v17 - 4));
          v10 = v10 + fabs(*(v16 - 1) - *(float *)((char *)v16 + v12 - 4));
        }
        while ( v18 );
        v15 = v22;
      }
      v13 += 4 * a2;
      v12 += v14;
      --v21;
    }
    while ( v21 );
  }
  if ( v10 >= a7 )
  {
    if ( v9 >= a7 )
    {
      *a8 = a1;
      *a9 = a3;
      return 0;
    }
    else
    {
      *a8 = 0;
      *a9 = 1;
      return 1;
    }
  }
  else
  {
    *a8 = 0;
    *a9 = 0;
    return 1;
  }
}

//----- (10024000) --------------------------------------------------------
BOOL __cdecl sub_10024000(int a1)
{
  return sub_100027A0(a1 + 4) || sub_100027A0(a1 + 24) || sub_100027A0(a1 + 44);
}

//----- (10024040) --------------------------------------------------------
int __usercall sub_10024040@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6)
{
  int v7; // [esp+0h] [ebp-4h] BYREF

  v7 = a1;
  sub_10019A60(&v7, 56);
  sub_10019BC0(v7, 8, 16, a4, 24);
  sub_10019BC0(v7, 20, 28, a5, 64);
  sub_10019BC0(v7, 32, 40, a6, 16);
  if ( sub_10019C60((int)aWPublicGrannyR_41, 95) )
  {
    *(_DWORD *)v7 = GrannyNewMemoryArena();
    *(_DWORD *)(v7 + 4) = a3;
    *(_DWORD *)(v7 + 12) = 0;
    *(_DWORD *)(v7 + 24) = 0;
    *(_DWORD *)(v7 + 36) = 0;
    *(_DWORD *)(v7 + 44) = 0;
    *(_DWORD *)(v7 + 48) = 0;
    *(_DWORD *)(v7 + 52) = 0;
    sub_10019D80(a2, 24 * *(_DWORD *)(v7 + 8), 0, *(char **)(v7 + 16));
    sub_10019D80(a2, *(_DWORD *)(v7 + 20) << 6, 0, *(char **)(v7 + 28));
    sub_10019D80(a2, 16 * *(_DWORD *)(v7 + 32), 0, *(char **)(v7 + 40));
  }
  return v7;
}

//----- (10024140) --------------------------------------------------------
_DWORD *__cdecl sub_10024140(int *a1)
{
  _DWORD *result; // eax
  int v2; // eax
  int v3; // eax

  result = 0;
  if ( a1 )
  {
    v2 = sub_10024170(a1);
    v3 = off_10033620((int)aWPublicGrannyR_41, 122, 4, v2);
    return sub_10024240(a1, v3);
  }
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (10024170) --------------------------------------------------------
int __cdecl sub_10024170(int *a1)
{
  int v2; // [esp+0h] [ebp-Ch] BYREF
  int v3; // [esp+4h] [ebp-8h] BYREF
  int v4; // [esp+8h] [ebp-4h] BYREF

  sub_100241B0(a1, &v4, &v3, &v2, &a1);
  return sub_10019D70();
}

//----- (100241B0) --------------------------------------------------------
int __cdecl sub_100241B0(int *a1, int *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  sub_10019A60(a2, 124);
  sub_10019BC0(*a2, 4, 8, a1[3], 24);
  sub_10019BC0(*a2, 12, 16, a1[6], 64);
  sub_10019BC0(*a2, 20, 24, a1[9], 12);
  sub_10019A60(a3, 8 * a1[11]);
  sub_10019A60(a4, 4 * a1[12]);
  return sub_10019A60(a5, 4 * a1[13]);
}

//----- (10024240) --------------------------------------------------------
_DWORD *__cdecl sub_10024240(int *a1, int a2)
{
  int v2; // edi
  int v3; // ebx
  _DWORD *result; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // ebp
  int v7; // esi
  int v8; // eax
  _DWORD *v9; // ecx
  bool v10; // cc
  int v11; // esi
  int v12; // eax
  int v13; // esi
  _DWORD *v14; // edi
  int v15; // edx
  int v16; // esi
  int v17; // edx
  int v18; // eax
  int v19; // ebx
  int v20; // eax
  _DWORD *v21; // ecx
  _DWORD *i; // eax
  _DWORD *v23; // [esp+8h] [ebp-18h] BYREF
  int v24; // [esp+Ch] [ebp-14h] BYREF
  int v25; // [esp+10h] [ebp-10h]
  int v26; // [esp+14h] [ebp-Ch] BYREF
  int v27; // [esp+18h] [ebp-8h] BYREF
  _DWORD *v28; // [esp+1Ch] [ebp-4h] BYREF
  int v29; // [esp+24h] [ebp+4h]

  v2 = (int)a1;
  v3 = 0;
  result = 0;
  v23 = 0;
  if ( a1 )
  {
    sub_100241B0(a1, (int *)&v23, &v28, &v26, &v27);
    if ( sub_10019D50((int)aWPublicGrannyR_41, 199, a2) )
    {
      *v23 = a1[1];
      v24 = v26;
      v5 = v23;
      a2 = v27;
      v6 = v28;
      if ( (int)v23[1] > 0 )
      {
        v7 = 0;
        do
        {
          v8 = a1[4];
          v9 = (_DWORD *)(v7 + v5[2]);
          *v9 = *(_DWORD *)(v8 + v7);
          sub_10024420(v7 + v8 + 4, v9 + 1, &v24, &a2);
          v5 = v23;
          ++v3;
          v7 += 24;
        }
        while ( v3 < v23[1] );
        v3 = 0;
      }
      v10 = v5[3] <= 0;
      v25 = 0;
      if ( !v10 )
      {
        do
        {
          v11 = *(_DWORD *)(v2 + 28);
          v12 = *(_DWORD *)(v11 + v3);
          v13 = v3 + v11;
          v14 = (_DWORD *)(v3 + v5[4]);
          *v14 = v12;
          sub_10024420(v13 + 4, v14 + 1, &v24, &a2);
          sub_10024420(v13 + 24, v14 + 6, &v24, &a2);
          sub_10024420(v13 + 44, v14 + 11, &v24, &a2);
          v5 = v23;
          v15 = v23[3];
          v2 = (int)a1;
          v3 += 64;
          ++v25;
        }
        while ( v25 < v15 );
      }
      v29 = 0;
      if ( (int)v5[5] > 0 )
      {
        v16 = 0;
        v17 = 0;
        do
        {
          v18 = *(_DWORD *)(v2 + 40);
          v19 = *(_DWORD *)(v18 + v17);
          v20 = v17 + v18;
          v21 = (_DWORD *)(v16 + v5[6]);
          *v21 = v19;
          v21[1] = *(_DWORD *)(v20 + 4);
          v21[2] = v6;
          for ( i = *(_DWORD **)(v20 + 8); i; v6 += 2 )
          {
            *v6 = *i;
            v6[1] = i[1];
            i = (_DWORD *)i[2];
          }
          v5 = v23;
          v17 += 16;
          v16 += 12;
          ++v29;
        }
        while ( v29 < v23[5] );
      }
      v5[24] = 0;
      v23[28] = 0;
      v23[29] = 0;
      v23[30] = 0;
    }
    sub_1001A000(*(_DWORD **)v2);
    off_10033624((int)aWPublicGrannyR_41, 270, v2);
    return v23;
  }
  return result;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10024420) --------------------------------------------------------
int __cdecl sub_10024420(int a1, _DWORD *a2, int *a3, int *a4)
{
  int result; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // [esp-4h] [ebp-14h]
  int v8; // [esp-4h] [ebp-14h]

  *a2 = *(_DWORD *)a1;
  result = *(_DWORD *)(a1 + 8);
  if ( result )
  {
    v5 = *(_DWORD *)(a1 + 4);
    a2[1] = v5;
    v7 = *a3;
    a2[2] = *a3;
    sub_10019E10(4 * v5, *(_BYTE **)(a1 + 8), v7);
    result = 4 * a2[1] + *a3;
    *a3 = result;
  }
  else
  {
    a2[1] = 0;
    a2[2] = 0;
  }
  if ( *(_DWORD *)(a1 + 16) )
  {
    v6 = *(_DWORD *)(a1 + 12);
    a2[3] = v6;
    v8 = *a4;
    a2[4] = *a4;
    sub_10019E10(4 * v6, *(_BYTE **)(a1 + 16), v8);
    result = 4 * a2[3] + *a4;
    *a4 = result;
  }
  else
  {
    a2[3] = 0;
    a2[4] = 0;
  }
  return result;
}

//----- (100244C0) --------------------------------------------------------
void *__cdecl sub_100244C0(int a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  int v6; // ecx
  int v7; // esi
  _DWORD *v8; // ebx
  void *result; // eax
  _BYTE v10[20]; // [esp+Ch] [ebp-28h] BYREF
  _BYTE v11[20]; // [esp+20h] [ebp-14h] BYREF

  v6 = *(_DWORD *)(a1 + 12);
  v7 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) = v6 + 1;
  v8 = (_DWORD *)(v7 + 24 * v6);
  *v8 = a2;
  result = sub_10024530(v11, a1, a3, a4, a5, a4, a6);
  qmemcpy(v10, result, sizeof(v10));
  qmemcpy(v8 + 1, v10, 0x14u);
  return result;
}

//----- (10024530) --------------------------------------------------------
void *__cdecl sub_10024530(void *a1, int a2, int a3, int a4, _DWORD *a5, int a6, _DWORD *a7)
{
  void *result; // eax
  _DWORD v8[5]; // [esp+8h] [ebp-14h] BYREF

  v8[0] = a3;
  v8[1] = a4;
  v8[2] = sub_10024590(a2, a4, a5);
  v8[3] = a6;
  v8[4] = sub_100245E0(a2, a6, a7);
  result = a1;
  qmemcpy(a1, v8, 0x14u);
  return result;
}

//----- (10024590) --------------------------------------------------------
int __cdecl sub_10024590(int a1, int a2, _DWORD *a3)
{
  int result; // eax
  int v4; // eax
  int v5; // esi

  result = 0;
  if ( a3 )
  {
    v4 = sub_1001A030(*(_DWORD **)a1, 4 * a2);
    v5 = v4;
    if ( v4 )
    {
      sub_10019E30(a2, a3, v4);
      *(_DWORD *)(a1 + 48) += a2;
    }
    return v5;
  }
  return result;
}

//----- (100245E0) --------------------------------------------------------
int __cdecl sub_100245E0(int a1, int a2, _DWORD *a3)
{
  int result; // eax
  int v4; // eax
  int v5; // esi

  result = 0;
  if ( a3 )
  {
    v4 = sub_1001A030(*(_DWORD **)a1, 4 * a2);
    v5 = v4;
    if ( v4 )
    {
      sub_10019E30(a2, a3, v4);
      *(_DWORD *)(a1 + 52) += a2;
    }
    return v5;
  }
  return result;
}

//----- (10024630) --------------------------------------------------------
int __cdecl sub_10024630(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)((*(_DWORD *)(a1 + 24) << 6) + *(_DWORD *)(a1 + 28)) = a2;
  return result;
}

//----- (10024650) --------------------------------------------------------
void *__cdecl sub_10024650(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  int v5; // ebx
  void *result; // eax
  _BYTE v7[20]; // [esp+Ch] [ebp-14h] BYREF

  v5 = *(_DWORD *)(a1 + 28) + (*(_DWORD *)(a1 + 24) << 6);
  result = sub_10024530(v7, a1, a2, a3, a4, 3 * a3, a5);
  qmemcpy(v7, result, sizeof(v7));
  qmemcpy((void *)(v5 + 4), v7, 0x14u);
  return result;
}

//----- (100246B0) --------------------------------------------------------
void *__cdecl sub_100246B0(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  int v5; // ebx
  void *result; // eax
  _BYTE v7[20]; // [esp+Ch] [ebp-14h] BYREF

  v5 = *(_DWORD *)(a1 + 28) + (*(_DWORD *)(a1 + 24) << 6);
  result = sub_10024530(v7, a1, a2, a3, a4, 4 * a3, a5);
  qmemcpy(v7, result, sizeof(v7));
  qmemcpy((void *)(v5 + 24), v7, 0x14u);
  return result;
}

//----- (10024720) --------------------------------------------------------
void *__cdecl sub_10024720(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  int v5; // ebx
  void *result; // eax
  _BYTE v7[20]; // [esp+Ch] [ebp-14h] BYREF

  v5 = *(_DWORD *)(a1 + 28) + (*(_DWORD *)(a1 + 24) << 6);
  result = sub_10024530(v7, a1, a2, a3, a4, 9 * a3, a5);
  qmemcpy(v7, result, sizeof(v7));
  qmemcpy((void *)(v5 + 44), v7, 0x14u);
  return result;
}

//----- (10024780) --------------------------------------------------------
int __cdecl sub_10024780(int a1)
{
  int result; // eax

  result = a1;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

//----- (10024790) --------------------------------------------------------
int __cdecl sub_10024790(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(16 * *(_DWORD *)(a1 + 36) + *(_DWORD *)(a1 + 40)) = a2;
  return result;
}

//----- (100247B0) --------------------------------------------------------
_DWORD *__cdecl sub_100247B0(int a1, int a2, int a3)
{
  _DWORD *v3; // esi
  _DWORD *result; // eax
  int v5; // ecx

  v3 = (_DWORD *)(*(_DWORD *)(a1 + 40) + 16 * *(_DWORD *)(a1 + 36));
  result = (_DWORD *)sub_1001A030(*(_DWORD **)a1, 12);
  *result = a2;
  result[1] = a3;
  result[2] = 0;
  if ( v3[2] )
  {
    *(_DWORD *)(v3[3] + 8) = result;
    v5 = v3[1];
  }
  else
  {
    v5 = v3[1];
    v3[2] = result;
  }
  v3[3] = result;
  v3[1] = v5 + 1;
  ++*(_DWORD *)(a1 + 44);
  return result;
}

//----- (10024820) --------------------------------------------------------
int __cdecl sub_10024820(int a1)
{
  int result; // eax

  result = a1;
  ++*(_DWORD *)(a1 + 36);
  return result;
}

//----- (10024830) --------------------------------------------------------
_DWORD *__cdecl sub_10024830(int a1, int a2)
{
  _DWORD *v3; // [esp+Ch] [ebp-4h] BYREF

  sub_10019A60(&v3, 36);
  sub_10019BC0((int)v3, 12, 16, 3 * a2 * a1, 4);
  sub_10019BC0((int)v3, 20, 24, 4 * a2 * a1, 4);
  sub_10019BC0((int)v3, 28, 32, 9 * a2 * a1, 4);
  if ( sub_10019C60((int)aWPublicGrannyR_42, 61) )
  {
    *v3 = a1;
    v3[1] = a2;
    v3[2] = 0;
  }
  return v3;
}

//----- (100248D0) --------------------------------------------------------
int __cdecl sub_100248D0(int a1)
{
  return off_10033624((int)aWPublicGrannyR_42, 74, a1);
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (100248F0) --------------------------------------------------------
int __cdecl sub_100248F0(int a1, int a2)
{
  return *(_DWORD *)(a1 + 16) + 12 * a2 * *(_DWORD *)(a1 + 4);
}

//----- (10024910) --------------------------------------------------------
int __cdecl sub_10024910(int a1, int a2)
{
  return *(_DWORD *)(a1 + 24) + 16 * a2 * *(_DWORD *)(a1 + 4);
}

//----- (10024930) --------------------------------------------------------
int __cdecl sub_10024930(int a1, int a2)
{
  return *(_DWORD *)(a1 + 32) + 36 * a2 * *(_DWORD *)(a1 + 4);
}

//----- (10024950) --------------------------------------------------------
_DWORD *__cdecl sub_10024950(int a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  int v5; // ebx
  int v6; // ebp
  int v7; // eax

  v5 = sub_10024910(a1, a2);
  v6 = sub_10024930(a1, a2);
  v7 = sub_100248F0(a1, a2);
  sub_10019E30(3, a3, v7 + 12 * *(_DWORD *)(a1 + 8));
  sub_10019E30(4, a4, v5 + 16 * *(_DWORD *)(a1 + 8));
  return sub_10019E30(9, a5, v6 + 36 * *(_DWORD *)(a1 + 8));
}

//----- (100249C0) --------------------------------------------------------
int __cdecl sub_100249C0(int a1)
{
  int result; // eax

  result = a1;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

//----- (100249D0) --------------------------------------------------------
int __cdecl sub_100249D0(float a1, int a2)
{
  int v2; // eax
  int v4; // [esp+4h] [ebp-4h] BYREF

  sub_10019A60(&v4, 12);
  sub_10019BC0(v4, 4, 8, a2, 4);
  if ( sub_10019C60((int)aWPublicGrannyR_43, 37) )
  {
    v2 = 0;
    for ( *(float *)v4 = a1; v2 < a2; ++v2 )
      *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4 * v2) = *(_DWORD *)v4;
  }
  return v4;
}

//----- (10024A30) --------------------------------------------------------
double __cdecl sub_10024A30(_DWORD *a1, int a2)
{
  if ( a2 >= a1[1] )
    return *(float *)a1;
  else
    return *(float *)(a1[2] + 4 * a2);
}

//----- (10024A50) --------------------------------------------------------
void __cdecl sub_10024A50(int a1, int a2, float a3)
{
  if ( a2 >= *(_DWORD *)(a1 + 4) )
    sub_10017FE0(
      3,
      32,
      "%s(%d): BoneIndex %d is out-of-bounds (only %d bones in this track mask)",
      aWPublicGrannyR_43,
      72,
      a2,
      *(_DWORD *)(a1 + 4));
  else
    *(float *)(*(_DWORD *)(a1 + 8) + 4 * a2) = a3;
}

//----- (10024A90) --------------------------------------------------------
int __cdecl sub_10024A90(int a1)
{
  return off_10033624((int)aWPublicGrannyR_43, 79, a1);
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10024AB0) --------------------------------------------------------
int __cdecl sub_10024AB0(int a1)
{
  int v1; // esi

  v1 = sub_100249D0(*(float *)a1, *(_DWORD *)(a1 + 4));
  if ( v1 )
  {
    sub_10019E30(*(_DWORD *)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD *)(v1 + 8));
    return v1;
  }
  else
  {
    sub_10017FE0(3, 32, "%s(%d): Unable to create new track mask for copying", aWPublicGrannyR_43, 93);
    return 0;
  }
}

//----- (10024B10) --------------------------------------------------------
int __cdecl sub_10024B10(int a1)
{
  int result; // eax
  int v2; // ecx
  double v3; // st7
  float *v4; // ecx

  for ( result = 0; result < *(_DWORD *)(a1 + 4); *v4 = v3 )
  {
    v2 = *(_DWORD *)(a1 + 8);
    v3 = 1.0 - *(float *)(v2 + 4 * result);
    v4 = (float *)(v2 + 4 * result++);
  }
  return result;
}

//----- (10024B40) --------------------------------------------------------
int __cdecl sub_10024B40(_DWORD *a1)
{
  int v1; // edx
  int *v2; // ecx
  unsigned int v3; // edx
  int result; // eax
  int v5; // ecx
  unsigned int *v6; // esi
  unsigned int v7; // edi
  unsigned int v8; // ecx
  unsigned int *v9; // [esp-Ch] [ebp-14h]

  v1 = a1[2];
  v2 = (int *)a1[3];
  if ( v1 >= 3 )
  {
    v3 = v1 / 3u;
    do
    {
      result = *v2;
      *v2 = v2[2];
      v2[2] = result;
      v2 += 3;
      --v3;
    }
    while ( v3 );
  }
  v5 = a1[10];
  v6 = (unsigned int *)a1[11];
  if ( v5 >= 3 )
  {
    v7 = v5 / 3u;
    do
    {
      v8 = v6[2];
      v6[2] = *v6;
      *v6 = v8;
      sub_10024BC0(v6);
      sub_10024BC0(v6 + 1);
      v9 = v6 + 2;
      v6 += 3;
      result = sub_10024BC0(v9);
      --v7;
    }
    while ( v7 );
  }
  return result;
}

//----- (10024BC0) --------------------------------------------------------
int __cdecl sub_10024BC0(unsigned int *a1)
{
  unsigned int v1; // ecx
  int result; // eax

  v1 = *a1;
  result = *a1 & 3;
  if ( result == 2 )
  {
    result = 0;
    *a1 = v1 & 0xFFFFFFFC;
  }
  else
  {
    if ( !result )
      result = 2;
    *a1 = result | v1 & 0xFFFFFFFC;
  }
  return result;
}

//----- (10024BF0) --------------------------------------------------------
void __cdecl sub_10024BF0(int *a1, int a2, int a3)
{
  _DWORD *v3; // esi
  int v4; // ebp

  v3 = (_DWORD *)a1[1];
  if ( *a1 )
  {
    v4 = *a1;
    do
    {
      if ( *v3 >= a2 )
        sub_10017FE0(
          2,
          15,
          "%s(%d): tri_topology material group had out-of-range index %d during remapping",
          aWPublicGrannyR_32,
          132,
          *v3);
      else
        *v3 = *(_DWORD *)(a3 + 4 * *v3);
      v3 += 3;
      --v4;
    }
    while ( v4 );
  }
}

//----- (10024C50) --------------------------------------------------------
void __cdecl sub_10024C50(int a1, unsigned int a2, _DWORD *a3, unsigned int a4, int *a5)
{
  unsigned int v5; // ebx
  unsigned int v6; // esi
  int v7; // eax
  int v8; // edi
  _DWORD *v9; // edx
  int *v10; // eax
  int v11; // ecx
  int v12; // ebp
  unsigned int v13; // ecx
  int v14; // [esp+10h] [ebp-4h]

  v5 = a2;
  if ( a2 > 4 )
  {
    sub_10017FE0(3, 15, "%s(%d): FromBytesPerIndex %d is out of range [%d, %d]", aWPublicGrannyR_32, 157, a2, 0, 4);
  }
  else
  {
    v6 = a4;
    if ( a4 > 4 )
    {
      sub_10017FE0(3, 15, "%s(%d): ToBytesPerIndex %d is out of range [%d, %d]", aWPublicGrannyR_32, 158, a4, 0, 4);
    }
    else
    {
      v7 = sub_10024D70(a2);
      v8 = a1;
      v9 = a3;
      v14 = v7;
      v10 = a5;
      if ( a1 > 4 )
      {
        v11 = a1 - 4;
        v8 = 4;
        do
        {
          v12 = v14 & *v9;
          v9 = (_DWORD *)((char *)v9 + v5);
          *v10 = v12;
          v10 = (int *)((char *)v10 + v6);
          --v11;
        }
        while ( v11 );
      }
      if ( v8 )
      {
        a3 = (_DWORD *)v8;
        do
        {
          v13 = 0;
          a2 = 0;
          if ( v5 )
          {
            qmemcpy(&a2, v9, v5);
            v13 = a2;
            v6 = a4;
            v9 = (_DWORD *)((char *)v9 + v5);
          }
          a2 = v14 & v13;
          if ( v6 )
          {
            qmemcpy(v10, &a2, v6);
            v6 = a4;
            v10 = (int *)((char *)v10 + a4);
          }
          a3 = (_DWORD *)((char *)a3 - 1);
        }
        while ( a3 );
      }
    }
  }
}

//----- (10024D70) --------------------------------------------------------
int __cdecl sub_10024D70(int a1)
{
  int v1; // ecx
  int result; // eax

  v1 = a1;
  for ( result = 0; v1; --v1 )
    result = (result << 8) | 0xFF;
  return result;
}

//----- (10024D90) --------------------------------------------------------
_DWORD *__cdecl sub_10024D90(int a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)off_10033620((int)aWPublicGrannyR_44, 56, 4, 20);
  if ( result )
  {
    *result = a1;
    result[1] = 1;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
  }
  return result;
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (10024DD0) --------------------------------------------------------
BOOL __cdecl sub_10024DD0(int a1, _DWORD *a2, int a3)
{
  int *v3; // ebx
  _DWORD *v4; // edi
  int v5; // eax
  int v6; // eax

  v3 = (int *)a3;
  v4 = a2;
  *a2 = 0;
  *v3 = 0;
  if ( a1 )
  {
    a3 = 0;
    a2 = 0;
    v5 = sub_10024E60(a1);
    sub_10019A60(&a3, v5);
    v6 = sub_10002150(a1);
    sub_10019A60(&a2, v6);
    sub_10019C60((int)aWPublicGrannyR_44, 86);
    sub_10024E70(a1, a3, v4, (int)a2, v3);
  }
  return *v4 && *v3;
}

//----- (10024E60) --------------------------------------------------------
int __cdecl sub_10024E60(int a1)
{
  return 32 * *(_DWORD *)(a1 + 4);
}

//----- (10024E70) --------------------------------------------------------
BOOL __cdecl sub_10024E70(int a1, int a2, _DWORD *a3, int a4, int *a5)
{
  int v5; // ebx
  int *v6; // ebp
  _DWORD *v7; // edi
  int v8; // ebx
  _DWORD *v9; // ebp
  int v10; // esi
  int v11; // esi
  int v12; // eax
  int v14; // [esp+14h] [ebp+8h]

  v5 = a1;
  v6 = a5;
  v7 = a3;
  *a3 = 0;
  *a5 = 0;
  if ( a1 )
  {
    if ( a2 && a4 )
    {
      *a3 = a2;
      *a5 = a4;
      v8 = *(_DWORD *)(a1 + 12);
      v9 = (_DWORD *)*a3;
      v14 = a4;
      if ( v8 )
      {
        do
        {
          qmemcpy(v9, (const void *)v8, 0x20u);
          v9 += 8;
          v10 = sub_10001990(v8);
          sub_10019E10(v10, *(_BYTE **)(v8 + 32), v14);
          v8 = *(_DWORD *)(v8 + 36);
          v14 += v10;
        }
        while ( v8 );
        v7 = a3;
      }
      v5 = a1;
      *v9 = 0;
      v6 = a5;
    }
    v11 = *(_DWORD *)(v5 + 12);
    while ( v11 )
    {
      v12 = v11;
      v11 = *(_DWORD *)(v11 + 36);
      off_10033624((int)aWPublicGrannyR_44, 145, v12);
    }
    off_10033624((int)aWPublicGrannyR_44, 148, v5);
  }
  return *v7 && *v6;
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10024F60) --------------------------------------------------------
int sub_10024F60(int **a1, _BYTE *a2, ...)
{
  int v2; // eax
  int v4[8]; // [esp+8h] [ebp-20h] BYREF
  va_list va; // [esp+34h] [ebp+Ch] BYREF

  va_start(va, a2);
  v2 = sub_100228F0(*a1, a2);
  v4[1] = (int)sub_100228D0((int)*a1, v2);
  v4[0] = 10;
  memset(&v4[2], 0, 0x18u);
  return sub_10024FC0(a1, v4, va);
}

//----- (10024FC0) --------------------------------------------------------
int __cdecl sub_10024FC0(_DWORD *a1, int *a2, _BYTE *a3)
{
  int *v3; // esi
  int v4; // ebx
  int result; // eax
  int v6; // ecx
  int v7; // edx
  int *v8; // ecx

  v3 = a2;
  v4 = sub_10001990((int)a2);
  sub_10019A60(&a2, 40);
  sub_10019B90((int)a2, 32, v4);
  result = sub_10019C60((int)aWPublicGrannyR_44, 162);
  if ( result )
  {
    qmemcpy(a2, v3, 0x20u);
    a2[9] = 0;
    sub_10019E10(v4, a3, a2[8]);
    result = (int)a1;
    v6 = a1[3];
    v7 = a1[1] + 1;
    a1[2] += v4;
    a1[1] = v7;
    if ( v6 )
    {
      *(_DWORD *)(a1[4] + 36) = a2;
      a1[4] = a2;
    }
    else
    {
      v8 = a2;
      a1[3] = a2;
      a1[4] = v8;
    }
  }
  return result;
}

//----- (10025070) --------------------------------------------------------
int sub_10025070(int **a1, _BYTE *a2, ...)
{
  int v2; // eax
  int v4[8]; // [esp+8h] [ebp-20h] BYREF
  va_list va; // [esp+34h] [ebp+Ch] BYREF

  va_start(va, a2);
  v2 = sub_100228F0(*a1, a2);
  v4[1] = (int)sub_100228D0((int)*a1, v2);
  v4[0] = 19;
  memset(&v4[2], 0, 0x18u);
  return sub_10024FC0(a1, v4, va);
}

//----- (100250D0) --------------------------------------------------------
int __cdecl sub_100250D0(int **a1, _BYTE *a2, int a3, _BYTE *a4)
{
  int v4; // eax
  int v6[8]; // [esp+4h] [ebp-20h] BYREF

  v4 = sub_100228F0(*a1, a2);
  v6[1] = (int)sub_100228D0((int)*a1, v4);
  memset(&v6[4], 0, 16);
  v6[3] = a3;
  v6[0] = 10;
  v6[2] = 0;
  return sub_10024FC0(a1, v6, a4);
}

//----- (10025140) --------------------------------------------------------
int __cdecl sub_10025140(int **a1, char *a2, _BYTE *a3)
{
  int v3; // eax
  int v4; // eax
  int v6[8]; // [esp+8h] [ebp-20h] BYREF

  v3 = sub_100228F0(*a1, a2);
  v6[1] = (int)sub_100228D0((int)*a1, v3);
  v6[0] = 8;
  memset(&v6[2], 0, 0x18u);
  v4 = sub_100228F0(*a1, a3);
  a2 = sub_100228D0((int)*a1, v4);
  return sub_10024FC0(a1, v6, &a2);
}

//----- (100251B0) --------------------------------------------------------
int sub_100251B0(int **a1, _BYTE *a2, int a3, ...)
{
  int v3; // eax
  int v5[8]; // [esp+4h] [ebp-20h] BYREF
  va_list va; // [esp+34h] [ebp+10h] BYREF

  va_start(va, a3);
  v3 = sub_100228F0(*a1, a2);
  v5[1] = (int)sub_100228D0((int)*a1, v3);
  memset(&v5[3], 0, 20);
  v5[2] = a3;
  v5[0] = 2;
  return sub_10024FC0(a1, v5, va);
}

//----- (10025210) --------------------------------------------------------
char *GrannyGetVersionString()
{
  return a2105;
}

//----- (10025220) --------------------------------------------------------
_DWORD *__cdecl sub_10025220(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *result; // eax

  *a1 = 2;
  result = a4;
  *a2 = 1;
  *a3 = 0;
  *a4 = 5;
  return result;
}

//----- (10025250) --------------------------------------------------------
char __cdecl sub_10025250(int a1, int a2, int a3, int a4)
{
  if ( a1 == 2 && a2 == 1 && !a3 && a4 == 5 )
    return 1;
  sub_10017FE0(
    2,
    39,
    "%s(%d): Version of DLL (%d.%d.%d.%d) does not match version of .h (%d.%d.%d.%d)",
    aWPublicGrannyR_45,
    54,
    2,
    1,
    0,
    5,
    a1,
    a2,
    a3,
    a4);
  return 0;
}

//----- (100252A0) --------------------------------------------------------
int __usercall sub_100252A0@<eax>(double a1@<st0>, int a2, _DWORD *a3, int a4, _DWORD *a5, char *a6)
{
  int v7; // ebp
  int result; // eax
  int v11; // [esp+10h] [ebp-4h]
  int v12; // [esp+1Ch] [ebp+8h]

  v7 = sub_100019C0(a3);
  v11 = sub_100019C0(a5);
  result = a2;
  if ( a2 )
  {
    v12 = a2;
    do
    {
      sub_10010650((int)a3, a1, (int)a3, a4, (int)a5, a6);
      a4 += v7;
      a6 += v11;
      result = --v12;
    }
    while ( v12 );
  }
  return result;
}

//----- (10025300) --------------------------------------------------------
void __cdecl sub_10025300(_DWORD *a1, int a2)
{
  int v2; // eax
  int v3; // esi
  int i; // ecx
  int v5; // edx
  int k; // esi
  char v7; // cl
  int j; // ecx
  char v9; // al
  int v10; // esi
  int m; // ecx
  int v12; // edx
  int ii; // esi
  char v14; // cl
  int n; // ecx
  char v16; // al
  int v17; // edx
  int jj; // ecx
  int v19; // ecx
  int mm; // edx
  __int16 v21; // di
  int kk; // edx
  __int16 v23; // ax
  int v24; // edx
  int nn; // ecx
  int v26; // ecx
  int i2; // edx
  __int16 v28; // di
  int i1; // edx
  __int16 v30; // ax

  v2 = a1[3];
  switch ( *a1 )
  {
    case 0xA:
      return;
    case 0xD:
      v3 = 0;
      for ( i = 0; i < v2; ++i )
        v3 += *(char *)(i + a2);
      v5 = 127 - v3;
      if ( 127 - v3 <= 0 )
      {
        if ( 127 - v3 < 0 && v3 - 127 <= v2 )
        {
          for ( j = v2 - 1; j >= 0; --j )
          {
            if ( v5 >= 0 )
              break;
            v9 = *(_BYTE *)(j + a2);
            if ( v9 > 0 )
            {
              *(_BYTE *)(j + a2) = v9 - 1;
              ++v5;
            }
          }
        }
      }
      else if ( v5 <= v2 )
      {
        for ( k = 0; k < v2; --k )
        {
          if ( v5 <= 0 )
            break;
          v7 = *(_BYTE *)(k + a2);
          if ( v7 != 127 )
          {
            *(_BYTE *)(k + a2) = v7 + 1;
            --v5;
          }
        }
      }
      break;
    case 0xE:
      v10 = 0;
      for ( m = 0; m < v2; ++m )
        v10 += *(unsigned __int8 *)(m + a2);
      v12 = 255 - v10;
      if ( 255 - v10 <= 0 )
      {
        if ( 255 - v10 < 0 && v10 - 255 <= v2 )
        {
          for ( n = v2 - 1; n >= 0; --n )
          {
            if ( v12 >= 0 )
              break;
            v16 = *(_BYTE *)(n + a2);
            if ( v16 )
            {
              *(_BYTE *)(n + a2) = v16 - 1;
              ++v12;
            }
          }
        }
      }
      else if ( v12 <= v2 )
      {
        for ( ii = 0; ii < v2; --ii )
        {
          if ( v12 <= 0 )
            break;
          v14 = *(_BYTE *)(ii + a2);
          if ( v14 != -1 )
          {
            *(_BYTE *)(ii + a2) = v14 + 1;
            --v12;
          }
        }
      }
      break;
    case 0x11:
      v17 = 0;
      for ( jj = 0; jj < v2; ++jj )
        v17 += *(__int16 *)(a2 + 2 * jj);
      v19 = 0x7FFF - v17;
      if ( 0x7FFF - v17 <= 0 )
      {
        if ( 0x7FFF - v17 < 0 && v17 - 0x7FFF <= v2 )
        {
          for ( kk = v2 - 1; kk >= 0; --kk )
          {
            if ( v19 >= 0 )
              break;
            v23 = *(_WORD *)(a2 + 2 * kk);
            if ( v23 > 0 )
            {
              *(_WORD *)(a2 + 2 * kk) = v23 - 1;
              ++v19;
            }
          }
        }
      }
      else if ( v19 <= v2 )
      {
        for ( mm = 0; mm < v2; --mm )
        {
          if ( v19 <= 0 )
            break;
          v21 = *(_WORD *)(a2 + 2 * mm);
          if ( v21 != 0x7FFF )
          {
            *(_WORD *)(a2 + 2 * mm) = v21 + 1;
            --v19;
          }
        }
      }
      break;
    case 0x12:
      v24 = 0;
      for ( nn = 0; nn < v2; ++nn )
        v24 += *(unsigned __int16 *)(a2 + 2 * nn);
      v26 = 0xFFFF - v24;
      if ( 0xFFFF - v24 <= 0 )
      {
        if ( 0xFFFF - v24 < 0 && v24 - 0xFFFF <= v2 )
        {
          for ( i1 = v2 - 1; i1 >= 0; --i1 )
          {
            if ( v26 >= 0 )
              break;
            v30 = *(_WORD *)(a2 + 2 * i1);
            if ( v30 )
            {
              *(_WORD *)(a2 + 2 * i1) = v30 - 1;
              ++v26;
            }
          }
        }
      }
      else if ( v26 <= v2 )
      {
        for ( i2 = 0; i2 < v2; --i2 )
        {
          if ( v26 <= 0 )
            break;
          v28 = *(_WORD *)(a2 + 2 * i2);
          if ( v28 != -1 )
          {
            *(_WORD *)(a2 + 2 * i2) = v28 + 1;
            --v26;
          }
        }
      }
      break;
    default:
      sub_10017FE0(3, 15, "%s(%d): EnsureExactOneNorm called on unsupported type %d\n", aWPublicGrannyR_35, 294, *a1);
      break;
  }
}

//----- (100255A0) --------------------------------------------------------
int __usercall sub_100255A0@<eax>(double a1@<st0>, int a2, _DWORD *a3, char *a4)
{
  int result; // eax
  _DWORD *v6; // ebp
  int v7; // edx
  int v8; // edi
  int v9; // eax
  int i; // eax
  int v11; // [esp+10h] [ebp-810h]
  int v12; // [esp+14h] [ebp-80Ch]
  int v13; // [esp+1Ch] [ebp-804h]
  float v14[512]; // [esp+20h] [ebp-800h] BYREF

  v12 = sub_100019C0(a3);
  result = sub_10010600((int)a3, 0, aBoneweights);
  v6 = (_DWORD *)result;
  v13 = v7;
  if ( result )
  {
    result = a2;
    v8 = v6[3];
    if ( a2 )
    {
      v11 = a2;
      do
      {
        sub_10010650((int)a3, a1, (int)a3, (int)a4, (int)&unk_10035C28, (char *)v14);
        a1 = 0.0;
        v9 = 0;
        if ( v8 > 0 )
        {
          do
            a1 = a1 + v14[v9++];
          while ( v9 < v8 );
          if ( a1 != 0.0 )
          {
            a1 = 1.0 / a1;
            for ( i = 0; i < v8; v14[i - 1] = a1 * v14[i - 1] )
              ++i;
          }
        }
        sub_10010D60((int)a3, a1, (int)&unk_10035C28, (int)v14, (int)a3, a4);
        sub_10025300(v6, (int)&a4[v13]);
        a4 += v12;
        result = --v11;
      }
      while ( v11 );
    }
  }
  return result;
}
// 100255D6: variable 'v7' is possibly undefined
// 1002A170: using guessed type float flt_1002A170;

//----- (10025690) --------------------------------------------------------
int __usercall sub_10025690@<eax>(double a1@<st0>, int a2, _DWORD *a3, char *a4, float *a5, float *a6, float *a7)
{
  int result; // eax
  double v9; // st7
  double v10; // st6
  double v11; // st7
  double v12; // st7
  double v13; // st6
  double v14; // st7
  double v15; // st6
  double v16; // st7
  double v17; // st6
  double v18; // st7
  double v19; // st6
  int v20; // [esp+4h] [ebp-40h]
  float v21; // [esp+8h] [ebp-3Ch] BYREF
  float v22; // [esp+Ch] [ebp-38h]
  float v23; // [esp+10h] [ebp-34h]
  float v24; // [esp+14h] [ebp-30h]
  float v25; // [esp+18h] [ebp-2Ch]
  float v26; // [esp+1Ch] [ebp-28h]
  float v27; // [esp+20h] [ebp-24h]
  float v28; // [esp+24h] [ebp-20h]
  float v29; // [esp+28h] [ebp-1Ch]
  float v30; // [esp+2Ch] [ebp-18h]
  float v31; // [esp+30h] [ebp-14h]
  float v32; // [esp+34h] [ebp-10h]
  float v33; // [esp+38h] [ebp-Ch]
  float v34; // [esp+3Ch] [ebp-8h]
  float v35; // [esp+40h] [ebp-4h]
  int v36; // [esp+50h] [ebp+Ch]

  v20 = sub_100019C0(a3);
  result = a2;
  if ( a2 > 0 )
  {
    v36 = a2;
    do
    {
      sub_10010650((int)a4, a1, (int)a3, (int)a4, (int)&unk_10035708, (char *)&v21);
      v9 = v21;
      v10 = v22;
      v21 = v23 * a6[2] + v21 * *a6 + v22 * a6[1];
      v22 = v9 * a6[3] + v23 * a6[5] + v22 * a6[4];
      v11 = v9 * a6[6] + v23 * a6[8] + v10 * a6[7];
      v21 = v21 + *a5;
      v22 = v22 + a5[1];
      v23 = v11 + a5[2];
      v12 = v27;
      v13 = v28;
      v27 = v29 * a6[2] + v28 * a6[1] + v27 * *a6;
      v28 = v12 * a6[3] + v29 * a6[5] + v28 * a6[4];
      v29 = v12 * a6[6] + v29 * a6[8] + v13 * a6[7];
      v14 = v30;
      v15 = v31;
      v30 = v32 * a6[2] + v31 * a6[1] + v30 * *a6;
      v31 = v14 * a6[3] + v32 * a6[5] + v31 * a6[4];
      v32 = v14 * a6[6] + v32 * a6[8] + v15 * a6[7];
      v16 = v33;
      v17 = v34;
      v33 = v34 * a7[3] + v33 * *a7 + v35 * a7[6];
      v34 = v35 * a7[7] + v16 * a7[1] + v34 * a7[4];
      v35 = v17 * a7[5] + v35 * a7[8] + v16 * a7[2];
      v18 = v24;
      v19 = v25;
      v24 = v25 * a7[3] + v24 * *a7 + v26 * a7[6];
      v25 = v26 * a7[7] + v18 * a7[1] + v25 * a7[4];
      a1 = v19 * a7[5] + v26 * a7[8] + v18 * a7[2];
      v26 = a1;
      sub_10010D60((int)a4, a1, (int)&unk_10035708, (int)&v21, (int)a3, a4);
      a4 += v20;
      result = --v36;
    }
    while ( v36 );
  }
  return result;
}

//----- (100258E0) --------------------------------------------------------
int __cdecl sub_100258E0(int a1, int a2)
{
  return sub_10022670(64, a2, (int)aSD, (char)aTexturecoordin);
}

//----- (10025900) --------------------------------------------------------
int __cdecl sub_10025900(int a1, int a2)
{
  return sub_10022670(64, a2, (int)aSD, (char)aDiffusecolor);
}

//----- (10025920) --------------------------------------------------------
int __cdecl sub_10025920(int a1, int a2)
{
  return sub_10022670(64, a2, (int)aSD, (char)aSpecularcolor);
}

//----- (10025940) --------------------------------------------------------
BOOL __cdecl sub_10025940(_BYTE *a1)
{
  return sub_10021A20(a1, aPosition)
      || sub_10021A20(a1, aNormal)
      || sub_10021A20(a1, aTangent)
      || sub_10021A20(a1, aBinormal)
      || sub_10021A20(a1, aTangentbinorma)
      || sub_10021A20(a1, aBoneindices)
      || sub_10021A20(a1, aBoneweights);
}

//----- (100259D0) --------------------------------------------------------
int __cdecl sub_100259D0(int a1)
{
  int v1; // eax
  int v3; // eax

  v1 = sub_10010600(a1, 0, aBoneweights);
  if ( v1 )
    return *(_DWORD *)(v1 + 12);
  v3 = sub_10010600(a1, 0, aBoneindices);
  if ( v3 )
    return *(_DWORD *)(v3 + 12);
  else
    return 0;
}

//----- (10025A20) --------------------------------------------------------
int __cdecl sub_10025A20(_DWORD *a1)
{
  _DWORD *v1; // esi
  int v2; // edi
  int v3; // eax

  v1 = a1;
  v2 = 0;
  if ( *a1 )
  {
    do
    {
      if ( !sub_10025940((_BYTE *)v1[1]) )
        ++v2;
      v3 = v1[8];
      v1 += 8;
    }
    while ( v3 );
  }
  return v2;
}

//----- (10025A50) --------------------------------------------------------
void __usercall sub_10025A50(double a1@<st0>, int *a2, int a3, _DWORD *a4, char *a5)
{
  int v5; // eax

  if ( a4 )
  {
    if ( a5 )
    {
      if ( a3 < 0 || a3 >= a2[1] )
      {
        sub_10017FE0(3, 14, "%s(%d): VertexIndex %d is out of range [0, %d)", aWPublicGrannyR_35, 465, a3, a2[1]);
        sub_10001B60(a4, (int)a5);
      }
      else
      {
        v5 = sub_100019C0((_DWORD *)*a2);
        sub_10010650(a2[2], a1, *a2, a2[2] + a3 * v5, (int)a4, a5);
      }
    }
    else
    {
      sub_10017FE0(3, 14, "%s(%d): Dest is not allowed to be 0", aWPublicGrannyR_35, 463);
    }
  }
  else
  {
    sub_10017FE0(3, 14, "%s(%d): As is not allowed to be 0", aWPublicGrannyR_35, 462);
  }
}

//----- (10025B10) --------------------------------------------------------
int __cdecl sub_10025B10(int a1)
{
  int v1; // eax
  int v2; // eax

  v1 = sub_10025B60(a1);
  v2 = off_10033620((int)aWPublicGrannyR_28, 56, 32, v1);
  return sub_10025BC0(a1, v2);
}
// 10033620: using guessed type int (__cdecl *off_10033620)(int, int, int, int);

//----- (10025B40) --------------------------------------------------------
int __cdecl sub_10025B40(int a1)
{
  return off_10033624((int)aWPublicGrannyR_28, 64, a1);
}
// 10033624: using guessed type int (__cdecl *off_10033624)(int, int, int);

//----- (10025B60) --------------------------------------------------------
int __cdecl sub_10025B60(int a1)
{
  sub_10025B80(a1, &a1);
  return sub_10019D70();
}

//----- (10025B80) --------------------------------------------------------
int __cdecl sub_10025B80(int a1, int *a2)
{
  sub_10019A60(a2, 12);
  sub_10019A50(32);
  sub_10019BC0(*a2, 0, 4, a1, 64);
  return sub_10019BC0(*a2, 0, 8, a1, 64);
}

//----- (10025BC0) --------------------------------------------------------
int __cdecl sub_10025BC0(int a1, int a2)
{
  bool v2; // zf
  int result; // eax
  int v4; // [esp+0h] [ebp-4h] BYREF

  v4 = 0;
  sub_10025B80(a1, &v4);
  v2 = sub_10019D50((int)aWPublicGrannyR_28, 99, a2) == 0;
  result = v4;
  if ( !v2 )
  {
    if ( (*(_BYTE *)(v4 + 4) & 0x1F) != 0 )
    {
      sub_10017FE0(2, 34, "%s(%d): world_pose WorldTransformBuffer is unaligned", aWPublicGrannyR_28, 105);
      result = v4;
    }
    if ( (*(_BYTE *)(result + 8) & 0x1F) != 0 )
    {
      sub_10017FE0(2, 34, "%s(%d): world_pose CompositeTransformBuffer is unaligned", aWPublicGrannyR_28, 111);
      return v4;
    }
  }
  return result;
}

//----- (10025C40) --------------------------------------------------------
int __cdecl sub_10025C40(_DWORD *a1, int a2)
{
  int result; // eax

  result = 0;
  if ( a2 < *a1 )
    return a1[1] + (a2 << 6);
  return result;
}

//----- (10025C60) --------------------------------------------------------
int __cdecl sub_10025C60(_DWORD *a1, int a2)
{
  int result; // eax

  result = 0;
  if ( a2 < *a1 )
    return a1[2] + (a2 << 6);
  return result;
}

//----- (10025C80) --------------------------------------------------------
int __cdecl sub_10025C80(int a1, int a2, int a3, int *a4, float *a5, int *a6)
{
  void *v6; // ebp
  int v7; // esi
  int v8; // esi
  float *v9; // edi
  int v10; // edx
  int v11; // ebx
  int v12; // ecx
  int v13; // ebx
  int v14; // eax
  bool v15; // zf
  float *v16; // ebp
  int v17; // esi
  int v18; // eax
  int v19; // eax
  _DWORD *v20; // eax
  int v21; // esi
  int v22; // esi
  int v23; // eax
  int result; // eax
  unsigned __int64 v25; // [esp+10h] [ebp-58h]
  void *v26; // [esp+18h] [ebp-50h]
  unsigned __int64 v27; // [esp+18h] [ebp-50h]
  float v28[16]; // [esp+28h] [ebp-40h] BYREF
  int v29; // [esp+80h] [ebp+18h]

  if ( (byte_10056358 & 1) == 0 )
  {
    byte_10056358 |= 1u;
    dword_10056354 = (int)sub_100218A0((int)aBuildworldtran);
  }
  v6 = off_1003440C;
  v26 = off_1003440C;
  off_1003440C = (_UNKNOWN *)dword_10056354;
  v25 = __rdtsc();
  v7 = a2 + a3;
  if ( a2 + a3 < 0 || v7 > sub_100043A0((int)a4) )
  {
    v19 = sub_100043A0((int)a4);
    sub_10017FE0(3, 34, "%s(%d): OnePastLastBone %d is out of range [%d, %d]", aWPublicGrannyR_28, 168, v7, 0, v19);
    v27 = __rdtsc();
  }
  else if ( v7 > *a6 )
  {
    sub_10017FE0(3, 34, "%s(%d): OnePastLastBone %d is out of range [%d, %d]", aWPublicGrannyR_28, 169, v7, 0, *a6);
    v27 = __rdtsc();
  }
  else
  {
    v29 = sub_1001A7A0((int)a6);
    v8 = *(_DWORD *)(a1 + 8) + 156 * a2;
    v9 = (float *)((a2 << 6) + v29);
    v11 = sub_10002150(v10);
    v13 = v12 + v11;
    if ( a3 )
    {
      while ( *(_DWORD *)(v8 + 4) == -1 )
      {
        v14 = sub_10017830(a4, a2);
        if ( a5 )
        {
          sub_100018D0(v14, v28);
          sub_10018630((int)v9, v28, a5);
        }
        else
        {
          sub_100018D0(v14, v9);
        }
        sub_10018630(v13, (float *)(v8 + 76), v9);
        v8 += 156;
        v9 += 16;
        v13 += 64;
        v15 = a3 == 1;
        ++a2;
        --a3;
        if ( v15 )
          goto LABEL_17;
      }
      if ( a3 )
      {
        v16 = (float *)(v8 + 76);
        do
        {
          v17 = *((_DWORD *)v16 - 18);
          v18 = sub_10017830(a4, a2);
          sub_100018D0(v18, v28);
          sub_10018630((int)v9, v28, (float *)(v29 + (v17 << 6)));
          sub_10018630(v13, v16, v9);
          v16 += 39;
          v9 += 16;
          v13 += 64;
          v15 = a3 == 1;
          ++a2;
          --a3;
        }
        while ( !v15 );
        v6 = v26;
      }
    }
LABEL_17:
    v27 = __rdtsc();
  }
  v20 = off_1003440C;
  v21 = *((_DWORD *)off_1003440C + 1) + 1;
  *((_QWORD *)off_1003440C + 1) += v27 - v25;
  v20[1] = v21;
  off_1003440C = v6;
  v22 = *((_DWORD *)v6 + 4);
  v23 = *((_DWORD *)v6 + 5);
  *((_DWORD *)v6 + 4) = v27 - v25 + v22;
  result = ((v27 - v25) >> 32) + __CFADD__(v27 - v25, v22) + v23;
  *((_DWORD *)v6 + 5) = result;
  return result;
}
// 10025D2D: variable 'v10' is possibly undefined
// 10025D3F: variable 'v12' is possibly undefined
// 1003440C: using guessed type _UNKNOWN *off_1003440C;
// 10056354: using guessed type int dword_10056354;
// 10056358: using guessed type char byte_10056358;

//----- (10025F20) --------------------------------------------------------
HLOCAL __cdecl sub_10025F20(char a1, const char *a2, int a3, const char *a4)
{
  int v4; // ecx
  HLOCAL result; // eax
  CHAR Buffer[4]; // [esp+0h] [ebp-4h] BYREF

  *(_DWORD *)Buffer = v4;
  result = (HLOCAL)GetLastError();
  if ( result )
  {
    if ( !FormatMessageA(0x1100u, 0, (DWORD)result, 0x400u, Buffer, 0, 0) )
      *(_DWORD *)Buffer = aUnknownWin32Er;
    sub_10017FE0(
      (a1 != 0) + 2,
      2,
      "%s(%d): %s failed with error \"%s\" at %s(%d)",
      aWPublicGrannyR_4,
      50,
      a4,
      *(const char **)Buffer,
      a2,
      a3);
    return LocalFree(*(HLOCAL *)Buffer);
  }
  return result;
}
// 10025F20: variable 'v4' is possibly undefined
// 10017FE0: using guessed type _DWORD sub_10017FE0(_DWORD, _DWORD, _DWORD, ...);

//----- (10025FA0) --------------------------------------------------------
DWORD __cdecl sub_10025FA0(HANDLE hFile, LONG lDistanceToMove, DWORD dwMoveMethod)
{
  DWORD v3; // esi

  v3 = SetFilePointer(hFile, lDistanceToMove, 0, dwMoveMethod);
  if ( v3 == -1 && GetLastError() )
    sub_10025F20(0, aWPublicGrannyR_4, 63, aSetfilepointer);
  return v3;
}

//----- (10025FF0) --------------------------------------------------------
_DWORD *__stdcall GrannySetTransform(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  return sub_10001000(a1, a2, a3, a4);
}

//----- (10026010) --------------------------------------------------------
BOOL __stdcall GrannySetTransformWithIdentityCheck(int *a1, char *a2, char *a3, char *a4)
{
  return sub_10001080(a1, a2, a3, a4);
}

//----- (10026030) --------------------------------------------------------
_DWORD *__stdcall GrannyMakeIdentity(_DWORD *a1)
{
  return sub_10001190(a1);
}

//----- (10026040) --------------------------------------------------------
_DWORD *__stdcall GrannyZeroTransform(_DWORD *a1)
{
  return sub_100011F0(a1);
}

//----- (10026050) --------------------------------------------------------
void __stdcall GrannyGetTransformDeterminant(float *a1)
{
  sub_10001230(a1);
}

//----- (10026060) --------------------------------------------------------
float *__stdcall GrannyTransformVectorInPlace(float *a1, int a2)
{
  return sub_10001270(a1, a2);
}

//----- (10026080) --------------------------------------------------------
float *__stdcall GrannyTransformVectorInPlaceTransposed(float *a1, float *a2)
{
  return sub_100012D0(a1, a2);
}

//----- (100260A0) --------------------------------------------------------
float *__stdcall GrannyTransformVector(float *a1, float *a2, float *a3)
{
  return sub_10001360(a1, a2, a3);
}

//----- (100260C0) --------------------------------------------------------
float *__stdcall GrannyTransformPointInPlace(float *a1, float *a2)
{
  return sub_100013D0(a1, a2);
}

//----- (100260E0) --------------------------------------------------------
float *__stdcall GrannyTransformPoint(float *a1, float *a2, float *a3)
{
  return sub_10001450(a1, a2, a3);
}

//----- (10026100) --------------------------------------------------------
int __stdcall GrannyPreMultiplyBy(void *a1, int a2)
{
  return sub_100014D0(a1, a2);
}

//----- (10026120) --------------------------------------------------------
int __stdcall GrannyPostMultiplyBy(void *a1, int a2)
{
  return sub_10001500(a1, a2);
}

//----- (10026140) --------------------------------------------------------
int __stdcall GrannyMultiply(int a1, int a2, int a3)
{
  return sub_10001530(a1, a2, a3);
}

//----- (10026160) --------------------------------------------------------
BOOL __stdcall GrannyBuildInverse(int *a1, float *a2)
{
  return sub_10001690(a1, a2);
}

//----- (10026180) --------------------------------------------------------
float *__stdcall GrannySimilarityTransform(float *a1, float *a2, float *a3, float *a4)
{
  return sub_10001820(a1, a2, a3, a4);
}

//----- (100261A0) --------------------------------------------------------
float *__stdcall GrannyBuildCompositeTransform(int a1, int a2, float *a3)
{
  return sub_10001850(a1, a2, a3);
}

//----- (100261C0) --------------------------------------------------------
_DWORD *__stdcall GrannyBuildCompositeTransform4x4(int a1, _DWORD *a2)
{
  return sub_100018D0(a1, a2);
}

//----- (100261E0) --------------------------------------------------------
int __stdcall GrannyGetMemberUnitSize(_DWORD *a1)
{
  return sub_10001980(a1);
}

//----- (100261F0) --------------------------------------------------------
int __stdcall GrannyGetMemberTypeSize(int a1)
{
  return sub_10001990(a1);
}

//----- (10026200) --------------------------------------------------------
int __stdcall GrannyGetTotalObjectSize(_DWORD *a1)
{
  return sub_100019C0(a1);
}

//----- (10026210) --------------------------------------------------------
int __stdcall GrannyGetTotalTypeSize(int *a1)
{
  return sub_100019F0(a1);
}

//----- (10026220) --------------------------------------------------------
char *__stdcall GrannyGetMemberTypeName(int a1)
{
  return sub_10001A10(a1);
}

//----- (10026230) --------------------------------------------------------
int __stdcall GrannyGetMemberCTypeName(int a1)
{
  return sub_10001A20(a1);
}

//----- (10026240) --------------------------------------------------------
char __stdcall GrannyMemberHasPointers(int *a1)
{
  return sub_10001A30(a1);
}

//----- (10026250) --------------------------------------------------------
char __stdcall GrannyTypeHasPointers(_DWORD *a1)
{
  return sub_10001A70(a1);
}

//----- (10026260) --------------------------------------------------------
int __stdcall GrannyGetMemberMarshalling(int a1)
{
  return sub_10001AA0(a1);
}

//----- (10026270) --------------------------------------------------------
int __stdcall GrannyGetObjectMarshalling(_DWORD *a1)
{
  return sub_10001AD0(a1);
}

//----- (10026280) --------------------------------------------------------
BOOL __stdcall GrannyIsMixedMarshalling(int a1)
{
  return sub_10001B00(a1);
}

//----- (10026290) --------------------------------------------------------
int __userpurge GrannyMakeEmptyDataTypeMember@<eax>(int a1@<ebx>, int a2, char *a3)
{
  return sub_10001B10(a1, a2, a3);
}

//----- (100262B0) --------------------------------------------------------
int __stdcall GrannyMakeEmptyDataTypeObject(_DWORD *a1, int a2)
{
  return sub_10001B60(a1, a2);
}

//----- (100262D0) --------------------------------------------------------
int __stdcall GrannyGetMemberArrayWidth(int a1)
{
  return sub_10001B90(a1);
}

//----- (100262E0) --------------------------------------------------------
int __stdcall GrannyGetTypeTableFor(_DWORD *a1)
{
  return sub_10001BB0(a1);
}

//----- (100262F0) --------------------------------------------------------
int __stdcall GrannyGetTypeTableCount(_DWORD *a1)
{
  return sub_10001BD0(a1);
}

//----- (10026300) --------------------------------------------------------
int __stdcall GrannyReverseTypeArray(_DWORD *a1, int a2, unsigned int *a3)
{
  return sub_10001D50(a1, a2, a3);
}

//----- (10026320) --------------------------------------------------------
_DWORD *__stdcall GrannyGetModelInitialPlacement4x4(int a1, _DWORD *a2)
{
  return sub_10001DD0(a1, a2);
}

//----- (10026340) --------------------------------------------------------
int __stdcall GrannyGetMaterialTextureByType(int a1, char *a2)
{
  return sub_10001DE0(a1, a2);
}

//----- (10026360) --------------------------------------------------------
int __stdcall GrannyModelControlsBegin(int a1)
{
  return sub_10002100(a1);
}

//----- (10026370) --------------------------------------------------------
int __stdcall GrannyModelControlsNext(int a1)
{
  return sub_1001A7C0(a1);
}

//----- (10026380) --------------------------------------------------------
int __stdcall GrannyModelControlsEnd(int a1)
{
  return sub_10002120(a1);
}

//----- (10026390) --------------------------------------------------------
int __stdcall GrannyControlModelsBegin(int a1)
{
  return sub_10002130(a1);
}

//----- (100263A0) --------------------------------------------------------
int __stdcall GrannyControlModelsEnd(int a1)
{
  return sub_10002160(a1);
}

//----- (100263B0) --------------------------------------------------------
_DWORD *__stdcall GrannyInstantiateModel(int a1)
{
  return sub_10002170(a1);
}

//----- (100263C0) --------------------------------------------------------
void __stdcall GrannyFreeModelInstance(unsigned int a1)
{
  sub_100021A0(a1);
}

//----- (100263D0) --------------------------------------------------------
int __stdcall GrannyGetSourceSkeleton(int a1)
{
  return sub_100021D0(a1);
}

//----- (100263E0) --------------------------------------------------------
void __stdcall GrannySetModelClock(int a1, float a2)
{
  sub_100021F0(a1, a2);
}

//----- (10026400) --------------------------------------------------------
char __stdcall GrannyFreeCompletedModelControls(int a1)
{
  return sub_10002230(a1);
}

//----- (10026410) --------------------------------------------------------
char __stdcall GrannyAccumulateModelAnimations(int a1, int a2, int a3, int a4)
{
  return sub_10002260(a1, a2, a3, a4);
}

//----- (10026430) --------------------------------------------------------
int __stdcall GrannySampleModelAnimations(int a1, int a2, int a3, int *a4)
{
  return sub_100022A0(a1, a2, a3, a4);
}

//----- (10026450) --------------------------------------------------------
int __stdcall GrannyUpdateModelMatrix(int a1, int a2, float *a3, float *a4)
{
  return sub_10002390(a1, a2, a3, a4);
}

//----- (10026470) --------------------------------------------------------
int __stdcall GrannyGetModelUserDataArray(int a1)
{
  return sub_10002790(a1);
}

//----- (10026480) --------------------------------------------------------
BOOL __stdcall GrannyCurveIsUncompressed(int a1)
{
  return sub_100027A0(a1);
}

//----- (10026490) --------------------------------------------------------
BOOL __stdcall GrannyPixelLayoutsAreEqual(_DWORD *a1, _DWORD *a2)
{
  return sub_100027C0(a1, a2);
}

//----- (100264B0) --------------------------------------------------------
BOOL __stdcall GrannyPixelLayoutHasAlpha(int a1)
{
  return sub_10002820(a1);
}

//----- (100264C0) --------------------------------------------------------
int __stdcall GrannySetStockSpecification(int *a1, int a2, int a3)
{
  return sub_10002830(a1, a2, a3);
}

//----- (100264E0) --------------------------------------------------------
int __stdcall GrannySetStockRGBASpecification(int *a1, int a2, int a3, int a4, int a5)
{
  return sub_10002880(a1, a2, a3, a4, a5);
}

//----- (10026510) --------------------------------------------------------
int __stdcall GrannySetStockBGRASpecification(int *a1, int a2, int a3, int a4, int a5)
{
  return sub_100028E0(a1, a2, a3, a4, a5);
}

//----- (10026540) --------------------------------------------------------
int __stdcall GrannySwapRGBAToBGRA(_DWORD *a1)
{
  return sub_10002940(a1);
}

//----- (10026550) --------------------------------------------------------
unsigned int *__stdcall GrannyConvertPixelFormat(
        unsigned int a1,
        int a2,
        _DWORD *a3,
        int a4,
        int *a5,
        unsigned int *a6,
        int a7,
        unsigned int *a8)
{
  return sub_10002980(a1, a2, a3, a4, a5, a6, a7, a8);
}

//----- (10026590) --------------------------------------------------------
char __stdcall GrannyFindTrackGroupForModel(int a1, char *a2, int *a3)
{
  return sub_10003EE0(a1, a2, a3);
}

//----- (100265B0) --------------------------------------------------------
void __stdcall GrannyComputeBasisConversion(
        int a1,
        float a2,
        float *a3,
        float *a4,
        float *a5,
        float *a6,
        float *a7,
        float *a8,
        float *a9)
{
  sub_10003F40(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

//----- (100265F0) --------------------------------------------------------
int __userpurge GrannyTransformMesh@<eax>(double a1@<st0>, int a2, float *a3, float *a4, float *a5)
{
  return sub_100040C0(a1, a2, a3, a4, a5);
}

//----- (10026610) --------------------------------------------------------
int __stdcall GrannyTransformSkeleton(int a1, float *a2, float *a3, float *a4)
{
  return sub_100041C0(a1, a2, a3, a4);
}

//----- (10026630) --------------------------------------------------------
int __userpurge GrannyTransformModel@<eax>(double a1@<st0>, _DWORD *a2, float *a3, float *a4, float *a5)
{
  return sub_10004220(a1, a2, a3, a4, a5);
}

//----- (10026650) --------------------------------------------------------
int __stdcall GrannyTransformAnimation(int a1, float *a2, float *a3, float *a4)
{
  return sub_10004280(a1, a2, a3, a4);
}

//----- (10026670) --------------------------------------------------------
int __userpurge GrannyTransformFile@<eax>(double a1@<st0>, _DWORD *a2, float *a3, float *a4, float *a5)
{
  return sub_100042D0(a1, a2, a3, a4, a5);
}

//----- (10026690) --------------------------------------------------------
_DWORD *__stdcall GrannySampleBSpline0x1(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  return sub_1000A020(a1, a2, a3, a4);
}

//----- (100266B0) --------------------------------------------------------
int __stdcall GrannySampleBSpline0x3(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  return sub_1000A030(a1, a2, a3, a4);
}

//----- (100266D0) --------------------------------------------------------
int __stdcall GrannySampleBSpline0x4(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  return sub_1000A050(a1, a2, a3, a4);
}

//----- (100266F0) --------------------------------------------------------
int __stdcall GrannySampleBSpline0x9(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  return sub_1000A070(a1, a2, a3, a4);
}

//----- (10026710) --------------------------------------------------------
float *__stdcall GrannySampleBSpline1x1(float *a1, float *a2, float a3, float *a4)
{
  return sub_1000A0B0(a1, a2, a3, a4);
}

//----- (10026730) --------------------------------------------------------
float *__stdcall GrannySampleBSpline1x3(float *a1, float *a2, float a3, float *a4)
{
  return sub_1000A0F0(a1, a2, a3, a4);
}

//----- (10026750) --------------------------------------------------------
float *__stdcall GrannySampleBSpline1x4n(float *a1, float *a2, float a3, float *a4)
{
  return sub_1000A140(a1, a2, a3, a4);
}

//----- (10026770) --------------------------------------------------------
float *__stdcall GrannySampleBSpline1x9(float *a1, float *a2, float a3, float *a4)
{
  return sub_1000A1F0(a1, a2, a3, a4);
}

//----- (10026790) --------------------------------------------------------
float *__stdcall GrannySampleBSpline2x1(float *a1, float *a2, float a3, float *a4)
{
  return sub_1000A2A0(a1, a2, a3, a4);
}

//----- (100267B0) --------------------------------------------------------
float *__stdcall GrannySampleBSpline2x3(float *a1, float *a2, float a3, float *a4)
{
  return sub_1000A330(a1, a2, a3, a4);
}

//----- (100267D0) --------------------------------------------------------
float *__stdcall GrannySampleBSpline2x4n(float *a1, float *a2, float a3, float *a4)
{
  return sub_1000A3E0(a1, a2, a3, a4);
}

//----- (100267F0) --------------------------------------------------------
float *__stdcall GrannySampleBSpline2x9(float *a1, float *a2, float a3, float *a4)
{
  return sub_1000A500(a1, a2, a3, a4);
}

//----- (10026810) --------------------------------------------------------
float *__stdcall GrannySampleBSpline3x1(float *a1, float *a2, float a3, float *a4)
{
  return sub_1000A640(a1, a2, a3, a4);
}

//----- (10026830) --------------------------------------------------------
float *__stdcall GrannySampleBSpline3x3(float *a1, float *a2, float a3, float *a4)
{
  return sub_1000A760(a1, a2, a3, a4);
}

//----- (10026850) --------------------------------------------------------
float *__stdcall GrannySampleBSpline3x4n(float *a1, float *a2, float a3, float *a4)
{
  return sub_1000A8E0(a1, a2, a3, a4);
}

//----- (10026870) --------------------------------------------------------
float *__stdcall GrannySampleBSpline3x9(float *a1, float *a2, float a3, float *a4)
{
  return sub_1000AAD0(a1, a2, a3, a4);
}

//----- (10026890) --------------------------------------------------------
void __stdcall GrannySampleBSpline(unsigned int a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  sub_1000AD10(a1, a2, a3, a4, a5, a6);
}

//----- (100268C0) --------------------------------------------------------
int __stdcall GrannyFindKnot(int a1, int a2, float a3)
{
  return sub_1000ADC0(a1, a2, a3);
}

//----- (100268E0) --------------------------------------------------------
int __stdcall GrannyFindCloseKnot(int a1, int a2, float a3, int a4)
{
  return sub_1000AE30(a1, a2, a3, a4);
}

//----- (10026900) --------------------------------------------------------
char __stdcall GrannyConstructBSplineBuffers(
        int a1,
        _DWORD *a2,
        _DWORD *a3,
        int a4,
        int a5,
        _DWORD *a6,
        int a7,
        _DWORD *a8,
        _DWORD *a9)
{
  return sub_1000AEB0(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

//----- (10026940) --------------------------------------------------------
int __stdcall GrannyFitBSplineToSamples(
        float a1,
        int a2,
        char a3,
        int a4,
        _DWORD *a5,
        int a6,
        float a7,
        int a8,
        int a9)
{
  return sub_1000CC90(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

//----- (10026980) --------------------------------------------------------
int __stdcall GrannyInitializeDefaultCamera(int a1)
{
  return sub_1000CD70(a1);
}

//----- (10026990) --------------------------------------------------------
float *__stdcall GrannySetCameraAspectRatios(float *a1, float a2, float a3, float a4, float a5, float a6)
{
  return sub_1000CDF0(a1, a2, a3, a4, a5, a6);
}

//----- (100269C0) --------------------------------------------------------
float *__stdcall GrannyMoveCameraRelative(float *a1, float a2, float a3, float a4)
{
  return sub_1000CE20(a1, a2, a3, a4);
}

//----- (100269E0) --------------------------------------------------------
int __stdcall GrannyBuildCameraMatrices(float *a1)
{
  return sub_1000CEC0(a1);
}

//----- (100269F0) --------------------------------------------------------
int __stdcall GrannyGetCameraLocation(_DWORD *a1, _DWORD *a2)
{
  return sub_1000D2F0(a1, a2);
}

//----- (10026A10) --------------------------------------------------------
float *__stdcall GrannyGetCameraLeft(float *a1, float *a2)
{
  return sub_1000D320(a1, a2);
}

//----- (10026A30) --------------------------------------------------------
int __stdcall GrannyGetCameraRight(_DWORD *a1, _DWORD *a2)
{
  return sub_1000D350(a1, a2);
}

//----- (10026A50) --------------------------------------------------------
int __stdcall GrannyGetCameraUp(_DWORD *a1, _DWORD *a2)
{
  return sub_1000D380(a1, a2);
}

//----- (10026A70) --------------------------------------------------------
float *__stdcall GrannyGetCameraDown(float *a1, float *a2)
{
  return sub_1000D3B0(a1, a2);
}

//----- (10026A90) --------------------------------------------------------
float *__stdcall GrannyGetCameraForward(float *a1, float *a2)
{
  return sub_1000D3E0(a1, a2);
}

//----- (10026AB0) --------------------------------------------------------
int __stdcall GrannyGetCameraBack(_DWORD *a1, _DWORD *a2)
{
  return sub_1000D410(a1, a2);
}

//----- (10026AD0) --------------------------------------------------------
float *__stdcall GrannyWindowSpaceToWorldSpace(float *a1, float a2, float a3, float *a4, float *a5)
{
  return sub_1000D440(a1, a2, a3, a4, a5);
}

//----- (10026B00) --------------------------------------------------------
float *__stdcall GrannyWorldSpaceToWindowSpace(float *a1, float a2, float a3, float *a4, float *a5)
{
  return sub_1000D630(a1, a2, a3, a4, a5);
}

//----- (10026B30) --------------------------------------------------------
float *__stdcall GrannyGetPickingRay(float *a1, float a2, float a3, int a4, int a5, int a6, float *a7)
{
  return sub_1000D800(a1, a2, a3, a4, a5, a6, a7);
}

//----- (10026B60) --------------------------------------------------------
void __stdcall GrannyGetCameraRelativePlanarBases(_DWORD *a1, float a2, float *a3, float *a4, int a5, float *a6)
{
  sub_1000D8B0(a1, a2, a3, a4, a5, a6);
}

//----- (10026B90) --------------------------------------------------------
void __stdcall GrannyGetMostLikelyPhysicalAspectRatio(int a1, int a2)
{
  sub_1000DA00(a1, a2);
}

//----- (10026BB0) --------------------------------------------------------
void __stdcall GrannyFreeControl(unsigned int a1)
{
  sub_1000F0F0(a1);
}

//----- (10026BC0) --------------------------------------------------------
char __stdcall GrannyFreeControlOnceUnused(int a1)
{
  return sub_1000F150(a1);
}

//----- (10026BD0) --------------------------------------------------------
int __stdcall GrannyCompleteControlAt(int a1, int a2)
{
  return sub_1000F170(a1, a2);
}

//----- (10026BF0) --------------------------------------------------------
void __stdcall GrannyGetControlClock(int a1)
{
  sub_1000F180(a1);
}

//----- (10026C00) --------------------------------------------------------
void __stdcall GrannySetControlClock(int a1, float a2)
{
  sub_1000F190(a1, a2);
}

//----- (10026C20) --------------------------------------------------------
int __stdcall GrannySetControlClockOnly(int a1, float a2)
{
  return sub_1000F360(a1, a2);
}

//----- (10026C40) --------------------------------------------------------
BOOL __stdcall GrannyControlIsComplete(int a1)
{
  return sub_1000F370(a1);
}

//----- (10026C50) --------------------------------------------------------
char __stdcall GrannyFreeControlIfComplete(int a1)
{
  return sub_1000F3A0(a1);
}

//----- (10026C60) --------------------------------------------------------
void __stdcall GrannyGetControlWeight(int a1)
{
  sub_1000F410(a1);
}

//----- (10026C70) --------------------------------------------------------
int __stdcall GrannySetControlWeight(int a1, float a2)
{
  return sub_1000F5E0(a1, a2);
}

//----- (10026C90) --------------------------------------------------------
int __stdcall GrannyGetControlLoopCount(int a1)
{
  return sub_1000F5F0(a1);
}

//----- (10026CA0) --------------------------------------------------------
int __stdcall GrannySetControlLoopCount(int a1, int a2)
{
  return sub_1000F600(a1, a2);
}

//----- (10026CC0) --------------------------------------------------------
bool __stdcall GrannyGetControlLoopState(int a1, bool *a2, bool *a3)
{
  return sub_1000F610(a1, a2, a3);
}

//----- (10026CE0) --------------------------------------------------------
int __stdcall GrannyGetControlLoopIndex(int a1)
{
  return sub_1000F650(a1);
}

//----- (10026CF0) --------------------------------------------------------
int __stdcall GrannySetControlLoopIndex(int a1, int a2)
{
  return sub_1000F660(a1, a2);
}

//----- (10026D10) --------------------------------------------------------
void __stdcall GrannyGetControlSpeed(int a1)
{
  sub_1000F670(a1);
}

//----- (10026D20) --------------------------------------------------------
int __stdcall GrannySetControlSpeed(int a1, float a2)
{
  return sub_1000F680(a1, a2);
}

//----- (10026D40) --------------------------------------------------------
void __stdcall GrannyGetControlDuration(int a1)
{
  sub_1000F690(a1);
}

//----- (10026D50) --------------------------------------------------------
void __stdcall GrannyGetControlDurationLeft(float a1)
{
  sub_1000F6D0(a1);
}

//----- (10026D60) --------------------------------------------------------
char __stdcall GrannyControlIsActive(int a1)
{
  return sub_1000F740(a1);
}

//----- (10026D70) --------------------------------------------------------
char __stdcall GrannySetControlActive(int a1, char a2)
{
  return sub_1000F750(a1, a2);
}

//----- (10026D90) --------------------------------------------------------
void __stdcall GrannyGetControlClampedLocalClock(int a1)
{
  sub_1000F760(a1);
}

//----- (10026DA0) --------------------------------------------------------
void __stdcall GrannyGetControlLocalDuration(int a1)
{
  sub_1000F790(a1);
}

//----- (10026DB0) --------------------------------------------------------
void __stdcall GrannyGetControlEaseCurveMultiplier(int a1)
{
  sub_1000F420(a1);
}

//----- (10026DC0) --------------------------------------------------------
void __stdcall GrannyGetControlEffectiveWeight(int a1)
{
  sub_1000F5C0(a1);
}

//----- (10026DD0) --------------------------------------------------------
char __stdcall GrannySetControlEaseIn(int a1, char a2)
{
  return sub_1000F7A0(a1, a2);
}

//----- (10026DF0) --------------------------------------------------------
int __stdcall GrannySetControlEaseInCurve(int a1, float a2, int a3, int a4, int a5, int a6, int a7)
{
  return sub_1000F7B0(a1, a2, a3, a4, a5, a6, a7);
}

//----- (10026E20) --------------------------------------------------------
char __stdcall GrannySetControlEaseOut(int a1, char a2)
{
  return sub_1000F7E0(a1, a2);
}

//----- (10026E40) --------------------------------------------------------
int __stdcall GrannySetControlEaseOutCurve(int a1, float a2, int a3, int a4, int a5, int a6, int a7)
{
  return sub_1000F7F0(a1, a2, a3, a4, a5, a6, a7);
}

//----- (10026E70) --------------------------------------------------------
void __stdcall GrannyGetControlRawLocalClock(int a1)
{
  sub_1000F820(a1);
}

//----- (10026E80) --------------------------------------------------------
int __stdcall GrannySetControlRawLocalClock(int a1, float a2)
{
  return sub_1000F830(a1, a2);
}

//----- (10026EA0) --------------------------------------------------------
void __stdcall GrannyEaseControlIn(int a1, float a2, char a3)
{
  sub_1000F840(a1, a2, a3);
}

//----- (10026EC0) --------------------------------------------------------
void __stdcall GrannyEaseControlOut(int a1, int a2)
{
  sub_1000F8C0(a1, a2);
}

//----- (10026EE0) --------------------------------------------------------
int __stdcall GrannyGetControlUserDataArray(int a1)
{
  return sub_1000F920(a1);
}

//----- (10026EF0) --------------------------------------------------------
float *__stdcall GrannyRecenterAllControlClocks(float a1)
{
  return sub_1000F930(a1);
}

//----- (10026F00) --------------------------------------------------------
_DWORD *__stdcall GrannyPlayControlledAnimation(float a1, int a2, int a3)
{
  return sub_100100C0(a1, a2, a3);
}

//----- (10026F20) --------------------------------------------------------
int __stdcall GrannyBeginControlledAnimation(float a1, int a2)
{
  return sub_10010120(a1, a2);
}

//----- (10026F40) --------------------------------------------------------
_DWORD *__stdcall GrannyEndControlledAnimation(int *a1)
{
  return sub_100101C0(a1);
}

//----- (10026F50) --------------------------------------------------------
void __stdcall GrannySetTrackGroupTarget(int a1, int a2, int a3)
{
  sub_10010280(a1, a2, a3);
}

//----- (10026F70) --------------------------------------------------------
void __stdcall GrannySetTrackGroupBasisTransform(int a1, int a2, int a3, int a4)
{
  sub_100102D0(a1, a2, a3, a4);
}

//----- (10026F90) --------------------------------------------------------
void __stdcall GrannySetTrackGroupTrackMask(int a1, int a2, int a3)
{
  sub_10010320(a1, a2, a3);
}

//----- (10026FB0) --------------------------------------------------------
void __stdcall GrannySetTrackGroupModelMask(int a1, int a2, int a3)
{
  sub_10010370(a1, a2, a3);
}

//----- (10026FD0) --------------------------------------------------------
void __stdcall GrannySetTrackGroupAccumulation(int a1, int a2, char a3)
{
  sub_100103C0(a1, a2, a3);
}

//----- (10026FF0) --------------------------------------------------------
_DWORD *__stdcall GrannyPlayControlledPose(int a1, int a2, int a3, int a4, int a5)
{
  return sub_10010500(a1, a2, a3, a4, a5);
}

//----- (10027020) --------------------------------------------------------
_DWORD *__stdcall GrannyBeginCRC32(_DWORD *a1)
{
  return sub_100105A0(a1);
}

//----- (10027030) --------------------------------------------------------
unsigned int __stdcall GrannyAddToCRC32(int *a1, int a2, unsigned __int8 *a3)
{
  return sub_100105B0(a1, a2, a3);
}

//----- (10027050) --------------------------------------------------------
int *__stdcall GrannyEndCRC32(int *a1)
{
  return sub_100105F0(a1);
}

//----- (10027060) --------------------------------------------------------
int __stdcall GrannyFindMatchingMember(int a1, int a2, char *a3)
{
  return sub_10010600(a1, a2, a3);
}

//----- (10027080) --------------------------------------------------------
char *__userpurge GrannyConvertSingleObject@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, char *a6)
{
  return sub_10010650(a1, a2, a3, a4, a5, a6);
}

//----- (100270A0) --------------------------------------------------------
char *__userpurge GrannyMergeSingleObject@<eax>(int a1@<ebx>, double a2@<st0>, int a3, int a4, int a5, char *a6)
{
  return sub_10010D60(a1, a2, a3, a4, a5, a6);
}

//----- (100270C0) --------------------------------------------------------
int __userpurge GrannyConvertTree@<eax>(double a1@<st0>, int a2, unsigned int a3, int *a4)
{
  return sub_10010DA0(a1, a2, a3, a4);
}

//----- (100270E0) --------------------------------------------------------
int __userpurge GrannyGetConvertedTreeSize@<eax>(double a1@<st0>, int a2, unsigned int a3, int *a4)
{
  return sub_10010DF0(a1, a2, a3, a4);
}

//----- (10027100) --------------------------------------------------------
char *__userpurge GrannyConvertTreeInPlace@<eax>(double a1@<st0>, int a2, unsigned int a3, int *a4, int a5)
{
  return sub_10011290(a1, a2, a3, a4, a5);
}

//----- (10027120) --------------------------------------------------------
int __stdcall GrannyBeginFileDataTreeWriting(int a1, int a2, int a3)
{
  return sub_10011510(a1, a2, a3);
}

//----- (10027140) --------------------------------------------------------
int __stdcall GrannyEndFileDataTreeWriting(int a1)
{
  return sub_10011650(a1);
}

//----- (10027150) --------------------------------------------------------
int __stdcall GrannySetFileDataTreeFlags(int a1, int a2)
{
  return sub_10011690(a1, a2);
}

//----- (10027170) --------------------------------------------------------
int __stdcall GrannySetFileSectionForObjectsOfType(int a1, unsigned int a2, int a3)
{
  return sub_100116A0(a1, a2, a3);
}

//----- (10027190) --------------------------------------------------------
int __stdcall GrannySetFileSectionForObject(int a1, unsigned int a2, int a3)
{
  return sub_10011740(a1, a2, a3);
}

//----- (100271B0) --------------------------------------------------------
char __stdcall GrannyWriteDataTreeToFileBuilder(int a1, _DWORD *a2)
{
  return sub_10011760(a1, a2);
}

//----- (100271D0) --------------------------------------------------------
char __stdcall GrannyWriteDataTreeToFile(int a1, int a2, const CHAR *a3, int a4)
{
  return sub_100121A0(a1, a2, a3, a4);
}

//----- (100271F0) --------------------------------------------------------
int __stdcall GrannyClipTransformDOFs(int a1, __int16 a2)
{
  return sub_10012410(a1, a2);
}

//----- (10027210) --------------------------------------------------------
bool __stdcall GrannyFileCRCIsValid(const CHAR *a1)
{
  return sub_10012A30(a1);
}

//----- (10027220) --------------------------------------------------------
int __stdcall GrannyReadEntireFile(const CHAR *a1)
{
  return sub_10012CF0(a1);
}

//----- (10027230) --------------------------------------------------------
int __stdcall GrannyReadEntireFileFromMemory(int a1, int a2)
{
  return sub_10012E40(a1, a2);
}

//----- (10027250) --------------------------------------------------------
int __stdcall GrannyReadEntireFileFromReader(int a1)
{
  return sub_10012E90(a1);
}

//----- (10027260) --------------------------------------------------------
int __userpurge GrannyReadPartialFileFromReader@<eax>(int a1@<ebx>, int a2)
{
  return sub_10012F90(a1, a2);
}

//----- (10027270) --------------------------------------------------------
void __stdcall GrannyFreeFileSection(_DWORD *a1, int a2)
{
  sub_100130A0(a1, a2);
}

//----- (10027290) --------------------------------------------------------
int __stdcall GrannyFreeAllFileSections(_DWORD *a1)
{
  return sub_10013110(a1);
}

//----- (100272A0) --------------------------------------------------------
int __stdcall GrannyReadFileSection(int a1, int a2, int a3)
{
  return sub_10012520(a1, a2, a3);
}

//----- (100272C0) --------------------------------------------------------
int __stdcall GrannyFixupFileSection(int a1, int a2, int a3)
{
  return sub_10012800(a1, a2, a3);
}

//----- (100272E0) --------------------------------------------------------
int __stdcall GrannyFreeFile(_DWORD *a1)
{
  return sub_10013140(a1);
}

//----- (100272F0) --------------------------------------------------------
int __stdcall GrannyGetDataTreeFromFile(int a1)
{
  return sub_10013190(a1);
}

//----- (10027300) --------------------------------------------------------
int __stdcall GrannyGetFileTypeTag(int a1)
{
  return sub_100131D0(a1);
}

//----- (10027310) --------------------------------------------------------
_DWORD *__userpurge GrannyBeginFile@<eax>(int a1@<ebx>, int a2, int a3, _BYTE *a4, _BYTE *a5)
{
  return sub_10013200(a1, a2, a3, a4, a5);
}

//----- (10027330) --------------------------------------------------------
char __stdcall GrannyEndFile(int a1, const CHAR *a2)
{
  return sub_100135C0(a1, a2);
}

//----- (10027350) --------------------------------------------------------
char __stdcall GrannyEndFileToWriter(int a1, HANDLE *a2)
{
  return sub_10013610(a1, a2);
}

//----- (10027370) --------------------------------------------------------
int __stdcall GrannyAbortFile(int a1)
{
  return sub_10013B70(a1);
}

//----- (10027380) --------------------------------------------------------
void __stdcall GrannySetFileSectionFormat(int a1, int a2, int a3, int a4)
{
  sub_10013BB0(a1, a2, a3, a4);
}

//----- (100273A0) --------------------------------------------------------
int *__stdcall GrannyWriteFileChunk(int *a1, int a2, int a3, int a4, DWORD a5, unsigned __int8 *a6)
{
  int *v6; // eax
  int v7; // ecx
  int v8; // edx
  int v9; // eax
  int v11[3]; // [esp+8h] [ebp-Ch] BYREF

  v6 = sub_10013C10(v11, a2, a3, a4, a5, a6);
  v7 = *v6;
  v8 = v6[1];
  v9 = v6[2];
  *a1 = v7;
  a1[1] = v8;
  a1[2] = v9;
  return a1;
}

//----- (100273F0) --------------------------------------------------------
_DWORD *__stdcall GrannyOffsetFileLocation(_DWORD *a1, int a2, _DWORD *a3, int a4)
{
  int *v4; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // eax
  _DWORD v9[3]; // [esp+8h] [ebp-Ch] BYREF

  v4 = sub_10013E00(v9, a2, a3, a4);
  v5 = *v4;
  v6 = v4[1];
  v7 = v4[2];
  *a1 = v5;
  a1[1] = v6;
  a1[2] = v7;
  return a1;
}

//----- (10027440) --------------------------------------------------------
_DWORD *__stdcall GrannyMarkFileFixup(_DWORD *a1, unsigned int *a2, int a3, unsigned int *a4)
{
  return sub_10013E30(a1, a2, a3, a4);
}

//----- (10027460) --------------------------------------------------------
_DWORD *__stdcall GrannyAdjustFileFixup(int a1, _DWORD *a2, _DWORD *a3)
{
  return sub_10013F50(a1, a2, a3);
}

//----- (10027480) --------------------------------------------------------
void __stdcall GrannyMarkMarshallingFixup(_DWORD *a1, unsigned int *a2, unsigned int *a3, int a4)
{
  sub_10013F70(a1, a2, a3, a4);
}

//----- (100274A0) --------------------------------------------------------
_DWORD *__stdcall GrannyMarkFileRootObject(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  return sub_10014080(a1, a2, a3);
}

//----- (100274C0) --------------------------------------------------------
int __stdcall GrannyGetCompressedBytesPaddingSize(int a1)
{
  return sub_100140C0(a1);
}

//----- (100274D0) --------------------------------------------------------
char __stdcall GrannyDecompressData(int a1, int a2, _BYTE *a3, int a4, int a5, int a6, _BYTE *a7)
{
  return sub_100140D0(a1, a2, a3, a4, a5, a6, a7);
}

//----- (10027500) --------------------------------------------------------
_DWORD *__userpurge GrannyBeginFileCompression@<eax>(int a1@<ebx>, int a2, int a3, int a4, int a5)
{
  return sub_100141D0(a1, a2, a3, a4, a5);
}

//----- (10027520) --------------------------------------------------------
bool __stdcall GrannyCompressContentsOfFile(_DWORD *a1, unsigned int a2, const CHAR *a3, int a4, unsigned __int8 *a5)
{
  return sub_100142B0(a1, a2, a3, a4, a5);
}

//----- (10027550) --------------------------------------------------------
char __stdcall GrannyEndFileCompression(_DWORD *a1, DWORD *a2)
{
  return sub_100143D0(a1, a2);
}

//----- (10027570) --------------------------------------------------------
char __stdcall GrannyIsGrannyFile(int a1, unsigned int *a2, _BYTE *a3)
{
  return sub_10014460(a1, a2, a3);
}

//----- (10027590) --------------------------------------------------------
int __stdcall GrannyGetGRNSectionArray(int a1)
{
  return sub_100144F0(a1);
}

//----- (100275A0) --------------------------------------------------------
int __stdcall GrannyReverseSection(int a1, int a2, int a3, unsigned int *a4)
{
  return sub_10014500(a1, a2, a3, a4);
}

//----- (100275C0) --------------------------------------------------------
_DWORD *__stdcall GrannyGRNFixUp(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  return sub_10014530(a1, a2, a3, a4);
}

//----- (100275E0) --------------------------------------------------------
int __stdcall GrannyGRNMarshall(int a1, int *a2, int a3, int a4)
{
  return sub_10014580(a1, a2, a3, a4);
}

//----- (10027600) --------------------------------------------------------
int __stdcall GrannyDecodeGRNReference(int a1, _DWORD *a2)
{
  return sub_100145D0(a1, a2);
}

//----- (10027620) --------------------------------------------------------
unsigned int __userpurge GrannyGetFileInfo@<eax>(double a1@<st0>, int a2)
{
  return sub_100145F0(a1, a2);
}

//----- (10027630) --------------------------------------------------------
_DWORD *__stdcall GrannyInitializeFileReader(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  return sub_10014720(a1, a2, a3, a4, a5);
}

//----- (10027660) --------------------------------------------------------
int __stdcall GrannyUnlinkFileReader(int a1)
{
  return sub_10014780(a1);
}

//----- (10027670) --------------------------------------------------------
_DWORD *__stdcall GrannyCreatePlatformFileReader(int a1, int a2, LPCSTR lpFileName)
{
  return sub_100147C0(a1, a2, lpFileName);
}

//----- (100276A0) --------------------------------------------------------
int (__cdecl *__stdcall GrannySetDefaultFileReaderOpenCallback(
        int (__cdecl *a1)(int, int, LPCSTR lpFileName)))(int, int, LPCSTR lpFileName)
{
  return sub_100147B0(a1);
}

//----- (100276B0) --------------------------------------------------------
int __stdcall GrannyNewFileWriter(LPCSTR lpFileName, char a2)
{
  return sub_10014B00(lpFileName, a2);
}

//----- (100276D0) --------------------------------------------------------
void __stdcall GrannyDeleteFileWriter(HANDLE *a1)
{
  sub_10014B80(a1);
}

//----- (100276E0) --------------------------------------------------------
DWORD __stdcall GrannyGetWriterPosition(HANDLE *a1)
{
  return sub_10014BC0(a1);
}

//----- (100276F0) --------------------------------------------------------
DWORD __stdcall GrannySeekWriterFromStart(HANDLE *a1, LONG a2)
{
  return sub_10014BE0(a1, a2);
}

//----- (10027710) --------------------------------------------------------
DWORD __stdcall GrannySeekWriterFromEnd(HANDLE *a1, LONG a2)
{
  return sub_10014C00(a1, a2);
}

//----- (10027730) --------------------------------------------------------
DWORD __stdcall GrannySeekWriterFromCurrentPosition(HANDLE *a1, LONG a2)
{
  return sub_10014C20(a1, a2);
}

//----- (10027750) --------------------------------------------------------
char __stdcall GrannyWrite(DWORD NumberOfBytesWritten, DWORD nNumberOfBytesToWrite, unsigned __int8 *lpBuffer)
{
  return sub_10014C40(NumberOfBytesWritten, nNumberOfBytesToWrite, lpBuffer);
}

//----- (10027770) --------------------------------------------------------
_DWORD *__stdcall GrannyBeginWriterCRC(int a1)
{
  return sub_10014CB0(a1);
}

//----- (10027780) --------------------------------------------------------
char __stdcall GrannyWriterIsCRCing(int a1)
{
  return sub_10014CD0(a1);
}

//----- (10027790) --------------------------------------------------------
int __stdcall GrannyEndWriterCRC(int a1)
{
  return sub_10014CE0(a1);
}

//----- (100277A0) --------------------------------------------------------
int __stdcall GrannyAlignWriter(HANDLE *a1)
{
  return sub_10014A90(a1);
}

//----- (100277B0) --------------------------------------------------------
int __stdcall GrannyPredictWriterAlignment(int a1)
{
  return sub_10014AF0(a1);
}

//----- (100277C0) --------------------------------------------------------
// attributes: thunk
void __stdcall GrannyGetGrannyHeadWidthOverHeight()
{
  sub_10016130();
}

//----- (100277E0) --------------------------------------------------------
char *__stdcall GrannyGetGrannyHeadBezier(int a1)
{
  return sub_10016150(a1);
}

//----- (100277F0) --------------------------------------------------------
unsigned int __userpurge GrannyGetIGCInfo@<eax>(double a1@<st0>, int a2)
{
  return sub_10016170(a1, a2);
}

//----- (10027800) --------------------------------------------------------
unsigned int *__stdcall GrannyDecompressIGCTexture(int a1, int a2, unsigned int *a3)
{
  return sub_100161E0(a1, a2, a3);
}

//----- (10027820) --------------------------------------------------------
int __stdcall GrannyIKUpdate(int a1, int a2, float *a3, int a4, int a5, float *a6, int *a7, int *a8)
{
  return sub_10016220(a1, a2, a3, a4, a5, a6, a7, a8);
}

//----- (10027860) --------------------------------------------------------
void __stdcall GrannyScaleImage(
        float a1,
        unsigned int a2,
        unsigned int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9)
{
  sub_10016540(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

//----- (100278A0) --------------------------------------------------------
int __stdcall GrannyRayIntersectsPlaneAt(float *a1, float a2, float *a3, float *a4, float *a5)
{
  return sub_10016FB0(a1, a2, a3, a4, a5);
}

//----- (100278D0) --------------------------------------------------------
BOOL __stdcall GrannyRayIntersectsSphere(int a1, float a2, int a3, int a4)
{
  return sub_10017020();
}

//----- (100278F0) --------------------------------------------------------
BOOL __stdcall GrannyRayIntersectsSphereAt(float *a1, float a2, float *a3, float *a4, float *a5, float *a6)
{
  return sub_10017090(a1, a2, a3, a4, a5, a6);
}

//----- (10027920) --------------------------------------------------------
BOOL __stdcall GrannyRayIntersectsBox(float *a1, float *a2, int a3, float *a4, float *a5)
{
  return sub_10017140(a1, a2, a3, a4, a5);
}

//----- (10027950) --------------------------------------------------------
BOOL __stdcall GrannyRayIntersectsBoxAt(int a1, float *a2, int a3, float *a4, float *a5, int a6)
{
  return sub_10017300(a1, a2, a3, a4, a5, a6);
}

//----- (10027980) --------------------------------------------------------
int __stdcall GrannyRayIntersectsTriangleAt(float *a1, float *a2, float *a3, float *a4, float *a5, int a6)
{
  return sub_10017510(a1, a2, a3, a4, a5, a6);
}

//----- (100279B0) --------------------------------------------------------
int __userpurge GrannyNewLocalPose@<eax>(int a1@<ebx>, int a2)
{
  return sub_10017720(a1, a2);
}

//----- (100279C0) --------------------------------------------------------
int __stdcall GrannyFreeLocalPose(int a1)
{
  return sub_10017750(a1);
}

//----- (100279D0) --------------------------------------------------------
int __stdcall GrannyGetResultingLocalPoseSize(int a1)
{
  return sub_10017770(a1);
}

//----- (100279E0) --------------------------------------------------------
int __userpurge GrannyNewLocalPoseInPlace@<eax>(int a1@<ebx>, int a2, int a3)
{
  return sub_100177C0(a1, a2, a3);
}

//----- (10027A00) --------------------------------------------------------
int __stdcall GrannyGetLocalPoseTransform(int *a1, int a2)
{
  return sub_10017830(a1, a2);
}

//----- (10027A20) --------------------------------------------------------
int __stdcall GrannyBeginLocalPoseAccumulation(int a1, int a2, int a3)
{
  return sub_10017870(a1);
}

//----- (10027A40) --------------------------------------------------------
int __stdcall GrannyAccumulateLocalTransform(int a1, int a2, float a3, float *a4)
{
  return sub_10017880(a1, a2, a3, a4);
}

//----- (10027A60) --------------------------------------------------------
void __stdcall GrannyEndLocalPoseAccumulation(int *a1, int a2, int a3, int a4, int a5)
{
  sub_10017AA0(a1, a2, a3, a4, a5);
}

//----- (10027A90) --------------------------------------------------------
void __stdcall GrannyGetLocalPoseFillThreshold(int a1)
{
  sub_10017CE0(a1);
}

//----- (10027AA0) --------------------------------------------------------
void __stdcall GrannyGetWorldMatrixFromLocalPose(int a1, int a2, int *a3, float *a4, int a5)
{
  sub_10017D00(a1, a2, a3, a4, a5);
}

//----- (10027AD0) --------------------------------------------------------
int __stdcall GrannyGetAttachmentOffset(int a1, int *a2, int *a3, float *a4, int a5)
{
  return sub_10017EF0(a1, a2, a3, a4, a5);
}

//----- (10027B00) --------------------------------------------------------
char __stdcall GrannySetLogFileName(CHAR *lpFileName, char a2)
{
  return sub_10017F30(lpFileName, a2);
}

//----- (10027B30) --------------------------------------------------------
__int64 *__stdcall GrannySetLogCallback(__int64 *a1)
{
  return sub_10017FA0(a1);
}

//----- (10027B50) --------------------------------------------------------
bool __stdcall GrannyFilterMessage(int a1, char a2)
{
  return sub_10018150(a1, a2);
}

//----- (10027B70) --------------------------------------------------------
__int16 __fastcall GrannyFilterAllMessages(int a1, int a2, char a3)
{
  return sub_10018170(a2, a3);
}

//----- (10027BB0) --------------------------------------------------------
int __stdcall GrannyEnsureQuaternionContinuity(int a1, float *a2)
{
  return sub_10018D90(a1, a2);
}

//----- (10027BD0) --------------------------------------------------------
char __stdcall GrannyPolarDecompose(int a1, float a2, int a3, int a4)
{
  return sub_10018E60(a1, a2, a3, a4);
}

//----- (10027BF0) --------------------------------------------------------
int __stdcall GrannyColumnMatrixMultiply4x3(int a1, float *a2, float *a3)
{
  return sub_10018630(a1, a2, a3);
}

//----- (10027C10) --------------------------------------------------------
float *__stdcall GrannyColumnMatrixMultiply4x4(float *a1, float *a2, float *a3)
{
  return sub_10018780(a1, a2, a3);
}

//----- (10027C30) --------------------------------------------------------
float *__stdcall GrannyMatrixEqualsQuaternion3x3(float *a1, float *a2)
{
  return sub_100189A0(a1, a2);
}

//----- (10027C50) --------------------------------------------------------
int __stdcall GrannyQuaternionEqualsMatrix3x3(float *a1, float *a2)
{
  return sub_10018A70(a1, a2);
}

//----- (10027C70) --------------------------------------------------------
float *__stdcall GrannyInPlaceSimilarityTransformPosition(float *a1, float *a2, float *a3)
{
  return sub_100191A0(a1, a2, a3);
}

//----- (10027C90) --------------------------------------------------------
int __stdcall GrannyInPlaceSimilarityTransformOrientation(float *a1, float *a2, float *a3)
{
  return sub_10019210(a1, a2, a3);
}

//----- (10027CB0) --------------------------------------------------------
float *__stdcall GrannyInPlaceSimilarityTransformScaleShear(float *a1, float *a2, float *a3)
{
  return sub_100192E0(a1, a2, a3);
}

//----- (10027CD0) --------------------------------------------------------
float *__stdcall GrannyInPlaceSimilarityTransform(float *a1, float *a2, float *a3, float *a4, float *a5, float *a6)
{
  return sub_10019310(a1, a2, a3, a4, a5, a6);
}

//----- (10027D00) --------------------------------------------------------
int __stdcall GrannyInPlaceSimilarityTransform4x3(float *a1, float *a2, float *a3, float *a4)
{
  return sub_10019350(a1, a2, a3, a4);
}

//----- (10027D30) --------------------------------------------------------
int __stdcall GrannyNextAllocation(int a1)
{
  return sub_100198E0(a1);
}

//----- (10027D50) --------------------------------------------------------
int __stdcall GrannyGetAllocationInformation(_DWORD *a1, int *a2)
{
  return sub_10019900(a1, a2);
}

//----- (10027D80) --------------------------------------------------------
int __stdcall GrannyCheckedAllocationsEnd(int a1)
{
  return sub_10019970(a1);
}

//----- (10027D90) --------------------------------------------------------
bool __stdcall GrannyEndAllocationCheck(int a1)
{
  return sub_10019980(a1);
}

//----- (10027DA0) --------------------------------------------------------
int (__cdecl *__stdcall GrannyGetAllocator(_DWORD *a1, _DWORD *a2))(int, int, int)
{
  return sub_10019F40(a1, a2);
}

//----- (10027DC0) --------------------------------------------------------
int (__cdecl *__stdcall GrannySetAllocator(
        int (__cdecl *a1)(int, int, int, int),
        int (__cdecl *a2)(int, int, int)))(int, int, int, int)
{
  return sub_10019F60(a1, a2);
}

//----- (10027DE0) --------------------------------------------------------
int __stdcall GrannyFreeBuilderResult(int a1)
{
  return sub_10019F20(a1);
}

//----- (10027E00) --------------------------------------------------------
int __stdcall GrannyClearArena(_DWORD **a1)
{
  return sub_10019FE0(a1);
}

//----- (10027E10) --------------------------------------------------------
int __stdcall GrannyFreeMemoryArena(_DWORD *a1)
{
  return sub_1001A000(a1);
}

//----- (10027E20) --------------------------------------------------------
int __stdcall GrannyMemoryArenaPush(_DWORD *a1, int a2)
{
  return sub_1001A030(a1, a2);
}

//----- (10027E40) --------------------------------------------------------
_DWORD *__stdcall GrannyCreateMemoryFileReader(int a1, int a2, int a3, int a4, int a5)
{
  return sub_1001A090(a1, a2, a3, a4, a5);
}

//----- (10027E70) --------------------------------------------------------
int __stdcall GrannyGetMeshTriangleGroupCount(int a1)
{
  return sub_1001A160(a1);
}

//----- (10027E80) --------------------------------------------------------
int __stdcall GrannyGetMeshTriangleGroups(int a1)
{
  return sub_1001A170(a1);
}

//----- (10027E90) --------------------------------------------------------
int __stdcall GrannyGetMeshVertexType(int a1)
{
  return sub_1001A190(a1);
}

//----- (10027EA0) --------------------------------------------------------
int __stdcall GrannyGetMeshVertexCount(int a1)
{
  return sub_1001A1A0(a1);
}

//----- (10027EB0) --------------------------------------------------------
void __userpurge GrannyCopyMeshVertices(double a1@<st0>, const char **a2, _DWORD *a3, char *a4)
{
  sub_1001A1C0(a1, a2, a3, a4);
}

//----- (10027ED0) --------------------------------------------------------
int __stdcall GrannyGetMeshVertices(int a1)
{
  return sub_1001A220(a1);
}

//----- (10027EE0) --------------------------------------------------------
BOOL __stdcall GrannyMeshIsRigid(int a1)
{
  return sub_1001A240(a1);
}

//----- (10027EF0) --------------------------------------------------------
int __stdcall GrannyGetMeshIndexCount(int a1)
{
  return sub_1001A250(a1);
}

//----- (10027F00) --------------------------------------------------------
int __stdcall GrannyGetMeshBytesPerIndex(int a1)
{
  return sub_1001A270(a1);
}

//----- (10027F10) --------------------------------------------------------
int __stdcall GrannyGetMeshIndices(int a1)
{
  return sub_1001A290(a1);
}

//----- (10027F20) --------------------------------------------------------
void __stdcall GrannyCopyMeshIndices(const char **a1, unsigned int a2, int *a3)
{
  sub_1001A2B0(a1, a2, a3);
}

//----- (10027F40) --------------------------------------------------------
int __stdcall GrannyTransformBoundingBox(float *a1, float *a2, int a3, float *a4)
{
  return sub_1001A310(a1, a2, a3, a4);
}

//----- (10027F60) --------------------------------------------------------
int __stdcall GrannyNewMeshBinding(int a1, int a2, int a3)
{
  return sub_1001A4B0(a1, a2, a3);
}

//----- (10027F80) --------------------------------------------------------
int __stdcall GrannyFreeMeshBinding(int a1)
{
  return sub_1001A4F0(a1);
}

//----- (10027F90) --------------------------------------------------------
int __stdcall GrannyGetResultingMeshBindingSize(int a1, int a2, int a3)
{
  return sub_1001A510(a1, a2, a3);
}

//----- (10027FB0) --------------------------------------------------------
int __stdcall GrannyNewMeshBindingInPlace(int a1, int a2, int a3, int a4)
{
  return sub_1001A590(a1, a2, a3, a4);
}

//----- (10027FD0) --------------------------------------------------------
bool __stdcall GrannyMeshBindingIsTransferred(int a1)
{
  return sub_1001A6A0(a1);
}

//----- (10027FE0) --------------------------------------------------------
int __stdcall GrannyGetMeshBinding4x4ArraySize(int a1, int a2)
{
  return sub_1001A6C0(a1, a2);
}

//----- (10028000) --------------------------------------------------------
void __stdcall GrannyBuildMeshBinding4x4Array(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5)
{
  sub_1001A6D0(a1, a2, a3, a4, a5);
}

//----- (10028030) --------------------------------------------------------
int __stdcall GrannyGetWorldPose4x4Array(int a1)
{
  return sub_1001A7A0(a1);
}

//----- (10028040) --------------------------------------------------------
int __stdcall GrannyGetModelInstanceFromBinding(int a1)
{
  return sub_1001A7B0(a1);
}

//----- (10028050) --------------------------------------------------------
int __stdcall GrannyBeginMesh(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1001A7D0(a1, a2, a3, a4, a5);
}

//----- (10028080) --------------------------------------------------------
BOOL __stdcall GrannyEndMesh(int a1, int *a2, int *a3)
{
  return sub_1001ABD0(a1, a2, a3);
}

//----- (100280A0) --------------------------------------------------------
int __stdcall GrannyGetResultingVertexCount(int a1)
{
  return sub_1001ADA0(a1);
}

//----- (100280B0) --------------------------------------------------------
int __stdcall GrannyGetResultingCoincidentVertexMap(int a1)
{
  return sub_1001ADB0(a1);
}

//----- (100280C0) --------------------------------------------------------
int __stdcall GrannyGetResultingVertexToTriangleMap(int a1)
{
  return sub_1001ADC0(a1);
}

//----- (100280D0) --------------------------------------------------------
int __stdcall GrannyGetResultingVertexDataSize(int a1)
{
  return sub_1001AC60(a1);
}

//----- (100280E0) --------------------------------------------------------
int __stdcall GrannyGetResultingTopologySize(_DWORD *a1)
{
  return sub_1001ACE0(a1);
}

//----- (100280F0) --------------------------------------------------------
void __stdcall GrannyEndMeshInPlace(int a1, int a2, int *a3, int a4, int *a5)
{
  sub_1001ADD0(a1, a2, a3, a4, a5);
}

//----- (10028120) --------------------------------------------------------
float *__stdcall GrannySetNormalTolerance(float *a1, float a2)
{
  return sub_1001B2E0(a1, a2);
}

//----- (10028140) --------------------------------------------------------
int __stdcall GrannySetTangentTolerance(int a1, float a2)
{
  return sub_1001B2F0(a1, a2);
}

//----- (10028160) --------------------------------------------------------
int __stdcall GrannySetLocalPoseFillThreshold(int a1, float a2)
{
  return sub_10017CF0(a1, a2);
}

//----- (10028180) --------------------------------------------------------
int __stdcall GrannySetTangentBinormalCrossTolerance(int a1, float a2)
{
  return sub_1001B300(a1, a2);
}

//----- (100281A0) --------------------------------------------------------
int __stdcall GrannySetChannelTolerance(int a1, int a2, float a3)
{
  return sub_1001B310(a1, a2, a3);
}

//----- (100281C0) --------------------------------------------------------
_DWORD *__stdcall GrannySetPosition(_DWORD *a1, int a2, int a3, int a4)
{
  return sub_1001B330(a1, a2, a3, a4);
}

//----- (100281E0) --------------------------------------------------------
float *__stdcall GrannyAddWeight(int a1, int a2, float a3)
{
  return sub_1001B360(a1, a2, a3);
}

//----- (10028200) --------------------------------------------------------
int __userpurge GrannyPushVertex@<eax>(int a1@<ebx>, double a2@<st0>, int *a3)
{
  return sub_1001B380(a1, a2, a3);
}

//----- (10028210) --------------------------------------------------------
int __stdcall GrannySetVertexIndex(int a1, int a2, int a3)
{
  return sub_1001B530(a1, a2, a3);
}

//----- (10028230) --------------------------------------------------------
_DWORD *__stdcall GrannySetNormal(int a1, int a2, int a3, int a4, int a5)
{
  return sub_1001B550(a1, a2, a3, a4, a5);
}

//----- (10028260) --------------------------------------------------------
_DWORD *__stdcall GrannySetTangent(int a1, int a2, int a3, int a4, int a5)
{
  return sub_1001B580(a1, a2, a3, a4, a5);
}

//----- (10028290) --------------------------------------------------------
_DWORD *__stdcall GrannySetBinormal(int a1, int a2, int a3, int a4, int a5)
{
  return sub_1001B5B0(a1, a2, a3, a4, a5);
}

//----- (100282C0) --------------------------------------------------------
_DWORD *__stdcall GrannySetTangentBinormalCross(int a1, int a2, int a3, int a4, int a5)
{
  return sub_1001B5E0(a1, a2, a3, a4, a5);
}

//----- (100282F0) --------------------------------------------------------
_DWORD *__stdcall GrannySetChannel(int a1, int a2, int a3, _DWORD *a4)
{
  return sub_1001B610(a1, a2, a3, a4);
}

//----- (10028310) --------------------------------------------------------
int __stdcall GrannySetMaterial(int a1, int a2)
{
  return sub_1001B660(a1, a2);
}

//----- (10028330) --------------------------------------------------------
int __userpurge GrannyPushTriangle@<eax>(double a1@<st0>, _DWORD *a2)
{
  return sub_1001B670(a1, a2);
}

//----- (10028340) --------------------------------------------------------
void *__stdcall GrannyNewMeshDeformer(_DWORD *a1, _DWORD *a2, int a3)
{
  return sub_1001B980(a1, a2, a3);
}

//----- (10028360) --------------------------------------------------------
int __stdcall GrannyFreeMeshDeformer(int a1)
{
  return sub_1001B9E0(a1);
}

//----- (10028370) --------------------------------------------------------
int __stdcall GrannyDeformVertices(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return sub_1001BA00(a1, a2, a3, a4, a5, a6);
}

//----- (100283A0) --------------------------------------------------------
void __userpurge GrannyZeroPeriodicLoop(int a1@<ebx>, char *a2)
{
  sub_1001D220(a1, a2);
}

//----- (100283B0) --------------------------------------------------------
void __stdcall GrannyFitPeriodicLoop(float *a1, float *a2, float *a3, float *a4, float a5, int a6)
{
  sub_1001D240(a1, a2, a3, a4, a5, a6);
}

//----- (100283E0) --------------------------------------------------------
float *__stdcall GrannyComputePeriodicLoopVector(float *a1, float a2, float *a3)
{
  return sub_1001D650(a1, a2, a3);
}

//----- (10028400) --------------------------------------------------------
float *__stdcall GrannyComputePeriodicLoopLog(float *a1, float a2, float *a3)
{
  return sub_1001D6D0(a1, a2, a3);
}

//----- (10028420) --------------------------------------------------------
float *__stdcall GrannyStepPeriodicLoop(float *a1, float a2, float *a3, float *a4)
{
  return sub_1001D700(a1, a2, a3, a4);
}

//----- (10028440) --------------------------------------------------------
void *__stdcall GrannyGetS3TCPixelLayout(int a1)
{
  return sub_1001D970(a1);
}

//----- (10028450) --------------------------------------------------------
char *__stdcall GrannyGetS3TCTextureFormatName(int a1)
{
  return sub_1001D990(a1);
}

//----- (10028460) --------------------------------------------------------
_BYTE *__stdcall GrannyBuildSkeletonRelativeTransform(int a1, int a2, int a3, int a4, int a5, void *a6)
{
  return sub_10020F50(a1, a2, a3, a4, a5, a6);
}

//----- (10028490) --------------------------------------------------------
void __stdcall GrannyBuildSkeletonRelativeTransforms(int a1, char *a2, int a3, _DWORD *a4, int a5, int a6, char *a7)
{
  sub_10020FE0(a1, a2, a3, a4, a5, a6, a7);
}

//----- (100284C0) --------------------------------------------------------
char __stdcall GrannyFindBoneByName(int a1, char *a2, int *a3)
{
  return sub_10021080(a1, a2, a3);
}

//----- (100284E0) --------------------------------------------------------
int __stdcall GrannyBeginSkeleton(int a1)
{
  return sub_100210E0(a1);
}

//----- (100284F0) --------------------------------------------------------
_DWORD *__stdcall GrannyEndSkeleton(int a1, int a2)
{
  return sub_10021160(a1, a2);
}

//----- (10028510) --------------------------------------------------------
int __stdcall GrannyGetResultingSkeletonSize(int a1)
{
  return sub_100211A0(a1);
}

//----- (10028520) --------------------------------------------------------
_DWORD *__stdcall GrannyEndSkeletonInPlace(int a1, int a2, int a3)
{
  return sub_100211F0(a1, a2, a3);
}

//----- (10028540) --------------------------------------------------------
void __stdcall GrannyAddBone(_DWORD *a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7)
{
  sub_100213B0(a1, a2, a3, a4, a5, a6, a7);
}

//----- (10028570) --------------------------------------------------------
void __stdcall GrannySetBoneParent(int *a1, int a2, int a3)
{
  sub_10021430(a1, a2, a3);
}

//----- (100285C0) --------------------------------------------------------
void __stdcall GrannyGetCounterResults(int a1, int a2)
{
  sub_10021960(a1, a2);
}

//----- (100285E0) --------------------------------------------------------
int __userpurge GrannyBeginStringTable@<eax>(int a1@<ebx>, int a2, int a3)
{
  return sub_100226C0(a1, a2, a3);
}

//----- (10028600) --------------------------------------------------------
int __stdcall GrannyEndStringTable(int *a1)
{
  return sub_10022770(a1);
}

//----- (10028610) --------------------------------------------------------
int __stdcall GrannyGetResultingStringTableSize(int a1)
{
  return sub_100227A0(a1);
}

//----- (10028620) --------------------------------------------------------
int __stdcall GrannyEndStringTableInPlace(int *a1, int a2)
{
  return sub_10022820(a1, a2);
}

//----- (10028640) --------------------------------------------------------
char *__stdcall GrannyGetMappedString(int a1, int a2)
{
  return sub_100228D0(a1, a2);
}

//----- (10028660) --------------------------------------------------------
int __stdcall GrannyMapString(int *a1, _BYTE *a2)
{
  return sub_100228F0(a1, a2);
}

//----- (10028680) --------------------------------------------------------
DWORD *__stdcall GrannyGetSystemSeconds(DWORD *a1)
{
  LARGE_INTEGER *v1; // eax
  DWORD LowPart; // esi
  DWORD v3; // ecx
  LONG HighPart; // edx
  LONG v5; // eax
  LARGE_INTEGER v7[2]; // [esp+Ch] [ebp-10h] BYREF

  v1 = sub_10022A60(v7);
  LowPart = v1[1].LowPart;
  v3 = v1->LowPart;
  HighPart = v1->HighPart;
  v5 = v1[1].HighPart;
  *a1 = v3;
  a1[1] = HighPart;
  a1[2] = LowPart;
  a1[3] = v5;
  return a1;
}

//----- (100286C0) --------------------------------------------------------
void __stdcall GrannyGetSecondsElapsed(_QWORD *a1, _QWORD *a2)
{
  sub_10022AA0(a1, a2);
}

//----- (100286E0) --------------------------------------------------------
void __stdcall GrannySleepForSeconds(float a1)
{
  sub_10022B20(a1);
}

//----- (100286F0) --------------------------------------------------------
char *__stdcall GrannyGetTextureTypeName(int a1)
{
  return sub_10022B50(a1);
}

//----- (10028700) --------------------------------------------------------
char *__stdcall GrannyGetTextureEncodingName(int a1)
{
  return sub_10022B70(a1);
}

//----- (10028710) --------------------------------------------------------
int __stdcall GrannyGetRawImageSize(int a1, int a2, int a3, int a4)
{
  return sub_10022B90(a1, a2, a3, a4);
}

//----- (10028730) --------------------------------------------------------
int __stdcall GrannyGetS3TCImageSize(int a1, int a2, int a3)
{
  return sub_10022BA0(a1, a2, a3);
}

//----- (10028750) --------------------------------------------------------
char __stdcall GrannyGetRecommendedPixelLayout(_DWORD *a1, void *a2)
{
  return sub_10022C00(a1, a2);
}

//----- (10028770) --------------------------------------------------------
char __stdcall GrannyCopyTextureImage(
        int *a1,
        int a2,
        int a3,
        unsigned int *a4,
        int a5,
        int a6,
        int a7,
        unsigned int *a8)
{
  return sub_10022C50(a1, a2, a3, a4, a5, a6, a7, a8);
}

//----- (100287B0) --------------------------------------------------------
BOOL __stdcall GrannyTextureHasAlpha(int a1)
{
  return sub_10022ED0(a1);
}

//----- (100287C0) --------------------------------------------------------
_DWORD *__stdcall GrannyBeginRawTexture(int a1, int a2, const void *a3, int a4)
{
  return sub_10022EE0(a1, a2, a3, a4);
}

//----- (100287E0) --------------------------------------------------------
_DWORD *__stdcall GrannyBeginS3TCTexture(int a1, int a2, int a3)
{
  return sub_10022F70(a1, a2, a3);
}

//----- (10028800) --------------------------------------------------------
_DWORD *__stdcall GrannyBeginBestMatchS3TCTexture(int a1, int a2)
{
  return sub_10022FC0(a1, a2);
}

//----- (10028820) --------------------------------------------------------
_DWORD *__stdcall GrannyBeginBinkTexture(int a1, int a2, int a3, char a4)
{
  return sub_10022FE0(a1, a2, a3, a4);
}

//----- (10028840) --------------------------------------------------------
_DWORD *__stdcall GrannyEndTexture(int *a1)
{
  return sub_10023030(a1);
}

//----- (10028850) --------------------------------------------------------
int __stdcall GrannyGetResultingTextureSize(int *a1)
{
  return sub_10023060(a1);
}

//----- (10028860) --------------------------------------------------------
_DWORD *__stdcall GrannyEndTextureInPlace(int *a1, int a2)
{
  return sub_100230E0(a1, a2);
}

//----- (10028880) --------------------------------------------------------
void __stdcall GrannySetImageScalingFilter(int a1, int a2, int a3)
{
  sub_10023270(a1, a2, a3);
}

//----- (100288A0) --------------------------------------------------------
int __stdcall GrannyEncodeImage(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return sub_100232B0(a1, a2, a3, a4, a5, a6);
}

//----- (100288D0) --------------------------------------------------------
_DWORD *__stdcall GrannyGetTrackGroupInitialPlacement4x4(int a1, _DWORD *a2)
{
  return sub_10023A40(a1, a2);
}

//----- (100288F0) --------------------------------------------------------
float *__stdcall GrannyTransformCurve3(float *a1, int a2, float *a3)
{
  return sub_10023A50(a1, a2, a3);
}

//----- (10028910) --------------------------------------------------------
int __stdcall GrannyTransformCurve4(int a1, int a2, int a3)
{
  return sub_10023A80(a1, a2, a3);
}

//----- (10028930) --------------------------------------------------------
float *__stdcall GrannyTransformCurve3x3(int a1, int a2, int a3)
{
  return sub_10023AE0(a1, a2, a3);
}

//----- (10028950) --------------------------------------------------------
BOOL __stdcall GrannyGetTrackInitialTransform(_DWORD *a1, int *a2)
{
  return sub_10023B90(a1, a2);
}

//----- (10028970) --------------------------------------------------------
float *__stdcall GrannyRemoveTrackInitialTransform(int a1)
{
  return sub_10023BD0(a1);
}

//----- (10028980) --------------------------------------------------------
float *__stdcall GrannySimilarityTransformCurve3(float *a1, float *a2, int a3, int a4, float *a5)
{
  return sub_10023C50(a1, a2, a3, a4, a5);
}

//----- (100289B0) --------------------------------------------------------
int __stdcall GrannySimilarityTransformCurve4(int a1, float *a2, float *a3, int a4, float *a5)
{
  return sub_10023C80(a1, a2, a3, a4, a5);
}

//----- (100289E0) --------------------------------------------------------
float *__stdcall GrannySimilarityTransformCurve3x3(int a1, float *a2, float *a3, int a4, float *a5)
{
  return sub_10023CC0(a1, a2, a3, a4, a5);
}

//----- (10028A10) --------------------------------------------------------
void __stdcall GrannySimilarityTransformTrackGroup(int a1, float *a2, float *a3, float *a4)
{
  sub_10023CF0(a1, a2, a3, a4);
}

//----- (10028A30) --------------------------------------------------------
char __stdcall GrannyKnotsAreReducible(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        float a7,
        _DWORD *a8,
        _DWORD *a9)
{
  return sub_10023F10(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

//----- (10028A70) --------------------------------------------------------
BOOL __stdcall GrannyTransformTrackHasUncompressedCurves(int a1)
{
  return sub_10024000(a1);
}

//----- (10028A80) --------------------------------------------------------
int __userpurge GrannyBeginTrackGroup@<eax>(int a1@<ebx>, int a2, int a3, int a4, int a5)
{
  return sub_10024040(a4, a1, a2, a3, a4, a5);
}

//----- (10028AA0) --------------------------------------------------------
_DWORD *__stdcall GrannyEndTrackGroup(int *a1)
{
  return sub_10024140(a1);
}

//----- (10028AB0) --------------------------------------------------------
int __stdcall GrannyGetResultingTrackGroupSize(int *a1)
{
  return sub_10024170(a1);
}

//----- (10028AC0) --------------------------------------------------------
_DWORD *__stdcall GrannyEndTrackGroupInPlace(int *a1, int a2)
{
  return sub_10024240(a1, a2);
}

//----- (10028AE0) --------------------------------------------------------
void *__stdcall GrannyPushScalarTrack(int a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  return sub_100244C0(a1, a2, a3, a4, a5, a6);
}

//----- (10028B10) --------------------------------------------------------
int __stdcall GrannySetTransformTrackName(int a1, int a2)
{
  return sub_10024630(a1, a2);
}

//----- (10028B30) --------------------------------------------------------
void *__stdcall GrannySetTransformTrackPosition(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  return sub_10024650(a1, a2, a3, a4, a5);
}

//----- (10028B60) --------------------------------------------------------
void *__stdcall GrannySetTransformTrackOrientation(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  return sub_100246B0(a1, a2, a3, a4, a5);
}

//----- (10028B90) --------------------------------------------------------
void *__stdcall GrannySetTransformTrackScaleShear(int a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  return sub_10024720(a1, a2, a3, a4, a5);
}

//----- (10028BC0) --------------------------------------------------------
int __stdcall GrannyPushTransformTrack(int a1)
{
  return sub_10024780(a1);
}

//----- (10028BD0) --------------------------------------------------------
int __stdcall GrannySetTextTrackName(int a1, int a2)
{
  return sub_10024790(a1, a2);
}

//----- (10028BF0) --------------------------------------------------------
_DWORD *__stdcall GrannyAddTextEntry(int a1, int a2, int a3)
{
  return sub_100247B0(a1, a2, a3);
}

//----- (10028C10) --------------------------------------------------------
int __stdcall GrannyPushTextTrack(int a1)
{
  return sub_10024820(a1);
}

//----- (10028C20) --------------------------------------------------------
_DWORD *__stdcall GrannyBeginSampledAnimation(int a1, int a2)
{
  return sub_10024830(a1, a2);
}

//----- (10028C40) --------------------------------------------------------
int __stdcall GrannyEndSampledAnimation(int a1)
{
  return sub_100248D0(a1);
}

//----- (10028C50) --------------------------------------------------------
int __stdcall GrannyGetPositionSamples(int a1, int a2)
{
  return sub_100248F0(a1, a2);
}

//----- (10028C70) --------------------------------------------------------
int __stdcall GrannyGetOrientationSamples(int a1, int a2)
{
  return sub_10024910(a1, a2);
}

//----- (10028C90) --------------------------------------------------------
int __stdcall GrannyGetScaleShearSamples(int a1, int a2)
{
  return sub_10024930(a1, a2);
}

//----- (10028CB0) --------------------------------------------------------
_DWORD *__stdcall GrannySetTransformSample(int a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  return sub_10024950(a1, a2, a3, a4, a5);
}

//----- (10028CE0) --------------------------------------------------------
int __stdcall GrannyPushSampledFrame(int a1)
{
  return sub_100249C0(a1);
}

//----- (10028CF0) --------------------------------------------------------
int __stdcall GrannyNewTrackMask(float a1, int a2)
{
  return sub_100249D0(a1, a2);
}

//----- (10028D10) --------------------------------------------------------
void __stdcall GrannyGetTrackMaskBoneWeight(_DWORD *a1, int a2)
{
  sub_10024A30(a1, a2);
}

//----- (10028D30) --------------------------------------------------------
void __stdcall GrannySetTrackMaskBoneWeight(int a1, int a2, float a3)
{
  sub_10024A50(a1, a2, a3);
}

//----- (10028D50) --------------------------------------------------------
int __stdcall GrannyFreeTrackMask(int a1)
{
  return sub_10024A90(a1);
}

//----- (10028D60) --------------------------------------------------------
int __stdcall GrannyCopyTrackMask(int a1)
{
  return sub_10024AB0(a1);
}

//----- (10028D70) --------------------------------------------------------
int __stdcall GrannyInvertTrackMask(int a1)
{
  return sub_10024B10(a1);
}

//----- (10028D80) --------------------------------------------------------
int __stdcall GrannyInvertTriTopologyWinding(_DWORD *a1)
{
  return sub_10024B40(a1);
}

//----- (10028D90) --------------------------------------------------------
void __stdcall GrannyRemapTopologyMaterials(int *a1, int a2, int a3)
{
  sub_10024BF0(a1, a2, a3);
}

//----- (10028DB0) --------------------------------------------------------
void __stdcall GrannyConvertIndices(int a1, unsigned int a2, _DWORD *a3, unsigned int a4, int *a5)
{
  sub_10024C50(a1, a2, a3, a4, a5);
}

//----- (10028DE0) --------------------------------------------------------
_DWORD *__stdcall GrannyBeginVariant(int a1)
{
  return sub_10024D90(a1);
}

//----- (10028DF0) --------------------------------------------------------
BOOL __stdcall GrannyEndVariant(int a1, _DWORD *a2, int a3)
{
  return sub_10024DD0(a1, a2, a3);
}

//----- (10028E10) --------------------------------------------------------
int __stdcall GrannyGetResultingVariantTypeSize(int a1)
{
  return sub_10024E60(a1);
}

//----- (10028E20) --------------------------------------------------------
int __stdcall GrannyGetWorldPoseComposite4x4Array(int a1)
{
  return sub_10002150(a1);
}

//----- (10028E30) --------------------------------------------------------
BOOL __stdcall GrannyEndVariantInPlace(int a1, int a2, _DWORD *a3, int a4, int *a5)
{
  return sub_10024E70(a1, a2, a3, a4, a5);
}

//----- (10028E60) --------------------------------------------------------
int __stdcall GrannyAddScalarMember(int **a1, _BYTE *a2, int a3)
{
  return sub_10024F60(a1, a2, a3);
}

//----- (10028E80) --------------------------------------------------------
int __stdcall GrannyAddIntegerMember(int **a1, _BYTE *a2, int a3)
{
  return sub_10025070(a1, a2, a3);
}

//----- (10028EA0) --------------------------------------------------------
int __stdcall GrannyAddScalarArrayMember(int **a1, _BYTE *a2, int a3, _BYTE *a4)
{
  return sub_100250D0(a1, a2, a3, a4);
}

//----- (10028EC0) --------------------------------------------------------
int __stdcall GrannyAddStringMember(int **a1, char *a2, _BYTE *a3)
{
  return sub_10025140(a1, a2, a3);
}

//----- (10028EE0) --------------------------------------------------------
int __stdcall GrannyAddReferenceMember(int **a1, _BYTE *a2, int a3, int a4)
{
  return sub_100251B0(a1, a2, a3, a4);
}

//----- (10028F10) --------------------------------------------------------
_DWORD *__stdcall GrannyGetVersion(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  return sub_10025220(a1, a2, a3, a4);
}

//----- (10028F30) --------------------------------------------------------
char __stdcall GrannyVersionsMatch_(int a1, int a2, int a3, int a4)
{
  return sub_10025250(a1, a2, a3, a4);
}

//----- (10028F50) --------------------------------------------------------
int __userpurge GrannyConvertVertexLayouts@<eax>(double a1@<st0>, int a2, _DWORD *a3, int a4, _DWORD *a5, char *a6)
{
  return sub_100252A0(a1, a2, a3, a4, a5, a6);
}

//----- (10028F80) --------------------------------------------------------
void __stdcall GrannyEnsureExactOneNorm(_DWORD *a1, int a2)
{
  sub_10025300(a1, a2);
}

//----- (10028FA0) --------------------------------------------------------
int __userpurge GrannyOneNormalizeWeights@<eax>(double a1@<st0>, int a2, _DWORD *a3, char *a4)
{
  return sub_100255A0(a1, a2, a3, a4);
}

//----- (10028FC0) --------------------------------------------------------
int __userpurge GrannyTransformVertices@<eax>(
        double a1@<st0>,
        int a2,
        _DWORD *a3,
        char *a4,
        float *a5,
        float *a6,
        float *a7)
{
  return sub_10025690(a1, a2, a3, a4, a5, a6, a7);
}

//----- (10028FF0) --------------------------------------------------------
int __stdcall GrannyGetVertexTextureCoordinatesName(int a1, int a2)
{
  return sub_100258E0(a1, a2);
}

//----- (10029010) --------------------------------------------------------
int __stdcall GrannyGetVertexDiffuseColorName(int a1, int a2)
{
  return sub_10025900(a1, a2);
}

//----- (10029030) --------------------------------------------------------
int __stdcall GrannyGetVertexSpecularColorName(int a1, int a2)
{
  return sub_10025920(a1, a2);
}

//----- (10029050) --------------------------------------------------------
BOOL __stdcall GrannyIsSpatialVertexMember(_BYTE *a1)
{
  return sub_10025940(a1);
}

//----- (10029060) --------------------------------------------------------
int __stdcall GrannyGetVertexBoneCount(int a1)
{
  return sub_100259D0(a1);
}

//----- (10029070) --------------------------------------------------------
int __stdcall GrannyGetVertexChannelCount(_DWORD *a1)
{
  return sub_10025A20(a1);
}

//----- (10029080) --------------------------------------------------------
void __userpurge GrannyGetSingleVertex(double a1@<st0>, int *a2, int a3, _DWORD *a4, char *a5)
{
  sub_10025A50(a1, a2, a3, a4, a5);
}

//----- (100290A0) --------------------------------------------------------
int __stdcall GrannyNewWorldPose(int a1)
{
  return sub_10025B10(a1);
}

//----- (100290B0) --------------------------------------------------------
int __stdcall GrannyFreeWorldPose(int a1)
{
  return sub_10025B40(a1);
}

//----- (100290C0) --------------------------------------------------------
int __stdcall GrannyGetWorldPoseBoneCount(int a1)
{
  return sub_100043A0(a1);
}

//----- (100290D0) --------------------------------------------------------
int __stdcall GrannyGetResultingWorldPoseSize(int a1)
{
  return sub_10025B60(a1);
}

//----- (100290E0) --------------------------------------------------------
int __stdcall GrannyNewWorldPoseInPlace(int a1, int a2)
{
  return sub_10025BC0(a1, a2);
}

//----- (10029100) --------------------------------------------------------
int __stdcall GrannyGetWorldPose4x4(_DWORD *a1, int a2)
{
  return sub_10025C40(a1, a2);
}

//----- (10029120) --------------------------------------------------------
int __stdcall GrannyGetWorldPoseComposite4x4(_DWORD *a1, int a2)
{
  return sub_10025C60(a1, a2);
}

//----- (10029140) --------------------------------------------------------
int __stdcall GrannyBuildWorldPose(int a1, int a2, int a3, int *a4, float *a5, int *a6)
{
  return sub_10025C80(a1, a2, a3, a4, a5, a6);
}

// nfuncs=1297 queued=1254 decompiled=1254 lumina nreq=0 worse=0 better=0
// ALL OK, 1254 function(s) have been successfully decompiled
